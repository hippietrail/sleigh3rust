use sleigh4rust::*;
pub type AddrType = u32;
pub trait GlobalSetTrait {
    fn set_LRset(&mut self, address: Option<u32>, value: i128);
    fn set_REToverride(&mut self, address: Option<u32>, value: i128);
    fn set_CALLoverride(&mut self, address: Option<u32>, value: i128);
    fn set_counter(&mut self, address: Option<u32>, value: i128);
    fn set_regNum(&mut self, address: Option<u32>, value: i128);
    fn set_counter2(&mut self, address: Option<u32>, value: i128);
    fn set_reg2Num(&mut self, address: Option<u32>, value: i128);
    fn set_regInc(&mut self, address: Option<u32>, value: i128);
    fn set_ARMcond(&mut self, address: Option<u32>, value: i128);
    fn set_ARMcondCk(&mut self, address: Option<u32>, value: i128);
}
#[derive(Default)]
pub struct GlobalSetDefault<C: ContextTrait>(
    pub std::collections::HashMap<AddrType, C>,
);
impl<C: ContextTrait> GlobalSetTrait for GlobalSetDefault<C> {
    fn set_LRset(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_LRset_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_REToverride(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_REToverride_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_CALLoverride(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_CALLoverride_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_counter(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_counter_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_regNum(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_regNum_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_counter2(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_counter2_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_reg2Num(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_reg2Num_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_regInc(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_regInc_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_ARMcond(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_ARMcond_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_ARMcondCk(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_ARMcondCk_disassembly(value)
                .unwrap();
            context
        });
    }
}
pub trait ContextregisterTrait:
    MemoryRead<AddressType = u32> + MemoryWrite
{
    fn read_LRset_raw(&self) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<false>(0, 1, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_LRset_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<false>(u8::from(param), 0, 1, 1)
    }
    fn read_LRset_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_LRset_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_LRset_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_LRset_raw(param as u8)
    }
    fn read_LRset_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_LRset_raw()
    }
    fn write_LRset_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_LRset_raw(param)
    }
    fn LRset_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_LRset_raw()?))
    }
    fn read_REToverride_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<false>(0, 2, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_REToverride_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<false>(u8::from(param), 0, 2, 1)
    }
    fn read_REToverride_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_REToverride_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_REToverride_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_REToverride_raw(param as u8)
    }
    fn read_REToverride_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_REToverride_raw()
    }
    fn write_REToverride_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_REToverride_raw(param)
    }
    fn REToverride_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_REToverride_raw()?))
    }
    fn read_CALLoverride_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<false>(0, 3, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_CALLoverride_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<false>(u8::from(param), 0, 3, 1)
    }
    fn read_CALLoverride_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_CALLoverride_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_CALLoverride_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_CALLoverride_raw(param as u8)
    }
    fn read_CALLoverride_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_CALLoverride_raw()
    }
    fn write_CALLoverride_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_CALLoverride_raw(param)
    }
    fn CALLoverride_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_CALLoverride_raw()?))
    }
    fn read_counter_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u16::<false>(1, 6, 5)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_counter_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u16::<false>(u16::from(param), 1, 6, 5)
    }
    fn read_counter_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_counter_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_counter_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_counter_raw(param as u8)
    }
    fn read_counter_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_counter_raw()
    }
    fn write_counter_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_counter_raw(param)
    }
    fn counter_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_counter_raw()?))
    }
    fn read_regNum_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<false>(2, 3, 5)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_regNum_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<false>(u8::from(param), 2, 3, 5)
    }
    fn read_regNum_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_regNum_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_regNum_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_regNum_raw(param as u8)
    }
    fn read_regNum_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_regNum_raw()
    }
    fn write_regNum_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_regNum_raw(param)
    }
    fn regNum_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_regNum_raw()?))
    }
    fn read_counter2_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<false>(3, 0, 3)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_counter2_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<false>(u8::from(param), 3, 0, 3)
    }
    fn read_counter2_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_counter2_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_counter2_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_counter2_raw(param as u8)
    }
    fn read_counter2_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_counter2_raw()
    }
    fn write_counter2_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_counter2_raw(param)
    }
    fn counter2_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_counter2_raw()?))
    }
    fn read_reg2Num_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<false>(3, 3, 5)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_reg2Num_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<false>(u8::from(param), 3, 3, 5)
    }
    fn read_reg2Num_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_reg2Num_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_reg2Num_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_reg2Num_raw(param as u8)
    }
    fn read_reg2Num_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_reg2Num_raw()
    }
    fn write_reg2Num_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_reg2Num_raw(param)
    }
    fn reg2Num_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_reg2Num_raw()?))
    }
    fn read_regInc_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<false>(4, 0, 2)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_regInc_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<false>(u8::from(param), 4, 0, 2)
    }
    fn read_regInc_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_regInc_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_regInc_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_regInc_raw(param as u8)
    }
    fn read_regInc_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_regInc_raw()
    }
    fn write_regInc_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_regInc_raw(param)
    }
    fn regInc_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_regInc_raw()?))
    }
    fn read_ARMcond_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<false>(4, 2, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_ARMcond_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<false>(u8::from(param), 4, 2, 1)
    }
    fn read_ARMcond_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_ARMcond_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_ARMcond_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_ARMcond_raw(param as u8)
    }
    fn read_ARMcond_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_ARMcond_raw()
    }
    fn write_ARMcond_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_ARMcond_raw(param)
    }
    fn ARMcond_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_ARMcond_raw()?))
    }
    fn read_ARMcondCk_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<false>(4, 3, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_ARMcondCk_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<false>(u8::from(param), 4, 3, 1)
    }
    fn read_ARMcondCk_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_ARMcondCk_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_ARMcondCk_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_ARMcondCk_raw(param as u8)
    }
    fn read_ARMcondCk_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_ARMcondCk_raw()
    }
    fn write_ARMcondCk_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_ARMcondCk_raw(param)
    }
    fn ARMcondCk_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_ARMcondCk_raw()?))
    }
}
pub trait ContextTrait: Default {
    type Typeregister: ContextregisterTrait;
    fn register(&self) -> &Self::Typeregister;
    fn register_mut(&mut self) -> &mut Self::Typeregister;
}
#[derive(Debug, Clone, Copy)]
pub struct ContextregisterStructDebug {
    pub chunk_0x0: [Option<bool>; 64],
}
impl Default for ContextregisterStructDebug {
    fn default() -> Self {
        Self {
            chunk_0x0: [None; 64],
        }
    }
}
impl ContextregisterStructDebug {
    fn read_bits(
        &self,
        addr: <Self as MemoryRead>::AddressType,
        buf: &mut [u8],
        mask: &[u8],
    ) -> Result<(), MemoryReadError<<Self as MemoryRead>::AddressType>> {
        assert_eq!(buf.len(), mask.len());
        let buf_len =
            <<Self as MemoryRead>::AddressType>::try_from(buf.len()).unwrap();
        let addr_end = addr + ((buf_len + 7) / 8);
        match (addr, addr_end) {
            (0..=7, 0..=8) => {
                let byte_offset = usize::try_from(addr - 0).unwrap();
                for ((buf_byte, mask_byte), byte) in
                    buf.iter_mut().zip(mask.iter()).zip(byte_offset..)
                {
                    for bit in (0..8)
                        .into_iter()
                        .filter(|bit| ((*mask_byte >> bit) & 1) != 0)
                    {
                        *buf_byte |= (self.chunk_0x0[(byte * 8) + bit].unwrap()
                            as u8)
                            << bit;
                    }
                }
            }
            (addr_start, addr_end) => {
                return Err(MemoryReadError::UnableToReadMemory(
                    addr_start, addr_end,
                ))
            }
        }
        Ok(())
    }
    fn write_bits(
        &mut self,
        addr: <Self as MemoryRead>::AddressType,
        buf: &[u8],
        mask: &[u8],
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        assert_eq!(buf.len(), mask.len());
        let buf_len =
            <<Self as MemoryRead>::AddressType>::try_from(buf.len()).unwrap();
        let addr_end = addr + ((buf_len + 7) / 8);
        match (addr, addr_end) {
            (0..=7, 0..=8) => {
                let byte_offset = usize::try_from(addr - 0).unwrap();
                for ((buf_byte, mask_byte), byte) in
                    buf.iter().zip(mask.iter()).zip(byte_offset..)
                {
                    for bit in (0..8)
                        .into_iter()
                        .filter(|bit| ((*mask_byte >> bit) & 1) != 0)
                    {
                        self.chunk_0x0[(byte * 8) + bit] =
                            Some(*buf_byte & (1 << bit) != 0);
                    }
                }
            }
            (addr_start, addr_end) => {
                return Err(MemoryWriteError::UnableToWriteMemory(
                    addr_start, addr_end,
                ))
            }
        }
        Ok(())
    }
}
impl ContextregisterTrait for ContextregisterStructDebug {}
impl MemoryRead for ContextregisterStructDebug {
    type AddressType = u32;
    fn read(
        &self,
        addr: <Self as MemoryRead>::AddressType,
        buf: &mut [u8],
    ) -> Result<(), MemoryReadError<<Self as MemoryRead>::AddressType>> {
        let mut inner_buf = vec![0xFF; buf.len()];
        self.read_bits(addr, buf, &mut inner_buf)
    }
    fn read_u8<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u8, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u8>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u8>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u8>::from_be_bytes(data)
        } else {
            <u8>::from_le_bytes(data)
        };
        let value_mask = <u8>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
    fn read_u16<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u16, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u16>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u16>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u16>::from_be_bytes(data)
        } else {
            <u16>::from_le_bytes(data)
        };
        let value_mask = <u16>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
    fn read_u32<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u32, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u32>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u32>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u32>::from_be_bytes(data)
        } else {
            <u32>::from_le_bytes(data)
        };
        let value_mask = <u32>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
    fn read_u64<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u64, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u64>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u64>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u64>::from_be_bytes(data)
        } else {
            <u64>::from_le_bytes(data)
        };
        let value_mask = <u64>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
    fn read_u128<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u128, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u128>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u128>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u128>::from_be_bytes(data)
        } else {
            <u128>::from_le_bytes(data)
        };
        let value_mask = <u128>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
}
impl MemoryWrite for ContextregisterStructDebug {
    fn write(
        &mut self,
        addr: <Self as MemoryRead>::AddressType,
        buf: &[u8],
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        let mut inner_buf = vec![0xFF; buf.len()];
        self.write_bits(addr, buf, &inner_buf)
    }
    fn write_u8<const BIG_ENDIAN: bool>(
        &mut self,
        value: u8,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u8>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u8>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
    fn write_u16<const BIG_ENDIAN: bool>(
        &mut self,
        value: u16,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u16>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u16>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
    fn write_u32<const BIG_ENDIAN: bool>(
        &mut self,
        value: u32,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u32>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u32>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
    fn write_u64<const BIG_ENDIAN: bool>(
        &mut self,
        value: u64,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u64>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u64>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
    fn write_u128<const BIG_ENDIAN: bool>(
        &mut self,
        value: u128,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u128>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u128>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
}
#[derive(Debug, Clone, Copy, Default)]
pub struct SpacesStruct {
    pub register: ContextregisterStructDebug,
}
impl ContextTrait for SpacesStruct {
    type Typeregister = ContextregisterStructDebug;
    fn register(&self) -> &Self::Typeregister {
        &self.register
    }
    fn register_mut(&mut self) -> &mut Self::Typeregister {
        &mut self.register
    }
}
fn meaning_number<T>(hex: bool, num: T) -> DisplayElement
where
    i128: TryFrom<T>,
    <i128 as TryFrom<T>>::Error: core::fmt::Debug,
{
    DisplayElement::Number(hex, i128::try_from(num).unwrap())
}
fn meaning_0_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_0_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_0_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r0,
        1 => Register::r1,
        2 => Register::r2,
        3 => Register::r3,
        4 => Register::r4,
        5 => Register::r5,
        6 => Register::r6,
        7 => Register::r7,
        8 => Register::r8,
        9 => Register::r9,
        10 => Register::r10,
        11 => Register::r11,
        12 => Register::r12,
        13 => Register::sp,
        14 => Register::lr,
        15 => Register::pc,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_1_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_1_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_1_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r1,
        2 => Register::r3,
        4 => Register::r5,
        6 => Register::r7,
        8 => Register::r9,
        10 => Register::r11,
        12 => Register::sp,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_2_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_2_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_2_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::cr0,
        1 => Register::cr1,
        2 => Register::cr2,
        3 => Register::cr3,
        4 => Register::cr4,
        5 => Register::cr5,
        6 => Register::cr6,
        7 => Register::cr7,
        8 => Register::cr8,
        9 => Register::cr9,
        10 => Register::cr10,
        11 => Register::cr11,
        12 => Register::cr12,
        13 => Register::cr13,
        14 => Register::cr14,
        15 => Register::cr15,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_6_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_6_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_6_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r0,
        1 => Register::r1,
        2 => Register::r2,
        3 => Register::r3,
        4 => Register::r4,
        5 => Register::r5,
        6 => Register::r6,
        7 => Register::r7,
        8 => Register::r8,
        9 => Register::r9,
        10 => Register::r10,
        11 => Register::r11,
        12 => Register::r12,
        13 => Register::sp,
        14 => Register::lr,
        15 => Register::pc,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_3_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal("p0"),
        1 => DisplayElement::Literal("p1"),
        2 => DisplayElement::Literal("p2"),
        3 => DisplayElement::Literal("p3"),
        4 => DisplayElement::Literal("p4"),
        5 => DisplayElement::Literal("p5"),
        6 => DisplayElement::Literal("p6"),
        7 => DisplayElement::Literal("p7"),
        8 => DisplayElement::Literal("p8"),
        9 => DisplayElement::Literal("p9"),
        10 => DisplayElement::Literal("p10"),
        11 => DisplayElement::Literal("p11"),
        12 => DisplayElement::Literal("p12"),
        13 => DisplayElement::Literal("p13"),
        14 => DisplayElement::Literal("p14"),
        15 => DisplayElement::Literal("p15"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_4_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal("opt0"),
        1 => DisplayElement::Literal("opt1"),
        2 => DisplayElement::Literal("OSHST"),
        3 => DisplayElement::Literal("OSH"),
        4 => DisplayElement::Literal("opt4"),
        5 => DisplayElement::Literal("opt5"),
        6 => DisplayElement::Literal("NSHST"),
        7 => DisplayElement::Literal("NSH"),
        8 => DisplayElement::Literal("opt8"),
        9 => DisplayElement::Literal("opt9"),
        10 => DisplayElement::Literal("ISHST"),
        11 => DisplayElement::Literal("ISH"),
        12 => DisplayElement::Literal("opt12"),
        13 => DisplayElement::Literal("opt13"),
        14 => DisplayElement::Literal("ST"),
        15 => DisplayElement::Literal("SY"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_5_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal("opt0"),
        1 => DisplayElement::Literal("opt1"),
        2 => DisplayElement::Literal("opt2"),
        3 => DisplayElement::Literal("opt3"),
        4 => DisplayElement::Literal("opt4"),
        5 => DisplayElement::Literal("opt5"),
        6 => DisplayElement::Literal("opt6"),
        7 => DisplayElement::Literal("opt7"),
        8 => DisplayElement::Literal("opt8"),
        9 => DisplayElement::Literal("opt9"),
        10 => DisplayElement::Literal("opt10"),
        11 => DisplayElement::Literal("opt11"),
        12 => DisplayElement::Literal("opt12"),
        13 => DisplayElement::Literal("opt13"),
        14 => DisplayElement::Literal("opt14"),
        15 => DisplayElement::Literal("SY"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_pref(u32);
impl TokenField_pref {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_cond(u8);
impl TokenField_cond {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_I25(u8);
impl TokenField_I25 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_P24(u8);
impl TokenField_P24 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_H24(u8);
impl TokenField_H24 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_L24(u8);
impl TokenField_L24 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_U23(u8);
impl TokenField_U23 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_B22(u8);
impl TokenField_B22 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_N22(u8);
impl TokenField_N22 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_S22(u8);
impl TokenField_S22 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op(u8);
impl TokenField_op {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_W21(u8);
impl TokenField_W21 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_S20(u8);
impl TokenField_S20 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_L20(u8);
impl TokenField_L20 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rn(u8);
impl TokenField_Rn {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RnLo(u8);
impl TokenField_RnLo {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_msb(u8);
impl TokenField_msb {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_satimm5(u8);
impl TokenField_satimm5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_satimm4(u8);
impl TokenField_satimm4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_mask(u8);
impl TokenField_mask {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rd(u8);
impl TokenField_Rd {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rd2(u8);
impl TokenField_Rd2 {
    fn execution(&self) -> Register {
        meaning_1_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CRd(u8);
impl TokenField_CRd {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CRn(u8);
impl TokenField_CRn {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CRm(u8);
impl TokenField_CRm {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RdHi(u8);
impl TokenField_RdHi {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RdLo(u8);
impl TokenField_RdLo {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_smRd(u8);
impl TokenField_smRd {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_smRa(u8);
impl TokenField_smRa {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_smRm(u8);
impl TokenField_smRm {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_smRn(u8);
impl TokenField_smRn {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_immed12(u16);
impl TokenField_immed12 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rs(u8);
impl TokenField_Rs {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rotate(u8);
impl TokenField_rotate {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_immedH(u8);
impl TokenField_immedH {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_cpn(u8);
impl TokenField_cpn {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_3_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_opc1(u8);
impl TokenField_opc1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_opcode1(u8);
impl TokenField_opcode1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_opc2(u8);
impl TokenField_opc2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_opcode2(u8);
impl TokenField_opcode2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_opcode3(u8);
impl TokenField_opcode3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_lsb(u8);
impl TokenField_lsb {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sftimm(u8);
impl TokenField_sftimm {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sh(u8);
impl TokenField_sh {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_shft(u8);
impl TokenField_shft {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_immed24(u32);
impl TokenField_immed24 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_addr24(i32);
impl TokenField_addr24 {
    fn execution(&self) -> i32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_offset_12(u16);
impl TokenField_offset_12 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_immed(u8);
impl TokenField_immed {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_srsMode(u8);
impl TokenField_srsMode {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_immedL(u8);
impl TokenField_immedL {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_immed4(u8);
impl TokenField_immed4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_dbOption(u8);
impl TokenField_dbOption {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_4_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_ibOption(u8);
impl TokenField_ibOption {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_5_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rm(u8);
impl TokenField_Rm {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RmHi(u8);
impl TokenField_RmHi {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rm2(u8);
impl TokenField_Rm2 {
    fn execution(&self) -> Register {
        meaning_1_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_x(u8);
impl TokenField_x {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_r(u8);
impl TokenField_r {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_y(u8);
impl TokenField_y {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_D22(u8);
impl TokenField_D22 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_N7(u8);
impl TokenField_N7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_L7(u8);
impl TokenField_L7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Q6(u8);
impl TokenField_Q6 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_M5(u8);
impl TokenField_M5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Qn0(u8);
impl TokenField_Qn0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Qd0(u8);
impl TokenField_Qd0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Qm0(u8);
impl TokenField_Qm0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Qn1(u8);
impl TokenField_Qn1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Qd1(u8);
impl TokenField_Qd1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Qm1(u8);
impl TokenField_Qm1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dn0(u8);
impl TokenField_Dn0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd0(u8);
impl TokenField_Dd0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_1(u8);
impl TokenField_Dd_1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_2(u8);
impl TokenField_Dd_2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_3(u8);
impl TokenField_Dd_3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_4(u8);
impl TokenField_Dd_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_5(u8);
impl TokenField_Dd_5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_6(u8);
impl TokenField_Dd_6 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_7(u8);
impl TokenField_Dd_7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_8(u8);
impl TokenField_Dd_8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_9(u8);
impl TokenField_Dd_9 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_10(u8);
impl TokenField_Dd_10 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_11(u8);
impl TokenField_Dd_11 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_12(u8);
impl TokenField_Dd_12 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_13(u8);
impl TokenField_Dd_13 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_14(u8);
impl TokenField_Dd_14 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_15(u8);
impl TokenField_Dd_15 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd_16(u8);
impl TokenField_Dd_16 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dm0(u8);
impl TokenField_Dm0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dn1(u8);
impl TokenField_Dn1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dd1(u8);
impl TokenField_Dd1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dm1(u8);
impl TokenField_Dm1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dm_3(u8);
impl TokenField_Dm_3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dm_4(u8);
impl TokenField_Dm_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Sn0(u8);
impl TokenField_Sn0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Sd0(u8);
impl TokenField_Sd0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Sm0(u8);
impl TokenField_Sm0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Sm0next(u8);
impl TokenField_Sm0next {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Sn1(u8);
impl TokenField_Sn1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Sd1(u8);
impl TokenField_Sd1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Sm1(u8);
impl TokenField_Sm1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Sm1next(u8);
impl TokenField_Sm1next {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Sm0_3(u8);
impl TokenField_Sm0_3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Sm1_3(u8);
impl TokenField_Sm1_3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_cmode(u8);
impl TokenField_cmode {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit31(u8);
impl TokenField_bit31 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit30(u8);
impl TokenField_bit30 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit29(u8);
impl TokenField_bit29 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit28(u8);
impl TokenField_bit28 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2831(u8);
impl TokenField_c2831 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2627(u8);
impl TokenField_c2627 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2531(u8);
impl TokenField_c2531 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2527(u8);
impl TokenField_c2527 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2525(u8);
impl TokenField_c2525 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2427(u8);
impl TokenField_c2427 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2424(u8);
impl TokenField_c2424 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2331(u16);
impl TokenField_c2331 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2327(u8);
impl TokenField_c2327 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2324(u8);
impl TokenField_c2324 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2323(u8);
impl TokenField_c2323 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2222(u8);
impl TokenField_c2222 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2131(u16);
impl TokenField_c2131 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2127(u8);
impl TokenField_c2127 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2124(u8);
impl TokenField_c2124 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2123(u8);
impl TokenField_c2123 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2122(u8);
impl TokenField_c2122 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2121(u8);
impl TokenField_c2121 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2027(u8);
impl TokenField_c2027 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2024(u8);
impl TokenField_c2024 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2022(u8);
impl TokenField_c2022 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2021(u8);
impl TokenField_c2021 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c2020(u8);
impl TokenField_c2020 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1921(u8);
impl TokenField_c1921 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1919(u8);
impl TokenField_c1919 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1821(u8);
impl TokenField_c1821 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1819(u8);
impl TokenField_c1819 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1818(u8);
impl TokenField_c1818 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1721(u8);
impl TokenField_c1721 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1719(u8);
impl TokenField_c1719 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1718(u8);
impl TokenField_c1718 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1717(u8);
impl TokenField_c1717 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1631(u16);
impl TokenField_c1631 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1627(u16);
impl TokenField_c1627 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1621(u8);
impl TokenField_c1621 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1620(u8);
impl TokenField_c1620 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1619(u8);
impl TokenField_c1619 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1618(u8);
impl TokenField_c1618 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1617(u8);
impl TokenField_c1617 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1616(u8);
impl TokenField_c1616 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1515(u8);
impl TokenField_c1515 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1415(u8);
impl TokenField_c1415 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1414(u8);
impl TokenField_c1414 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1315(u8);
impl TokenField_c1315 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1313(u8);
impl TokenField_c1313 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1215(u8);
impl TokenField_c1215 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1212(u8);
impl TokenField_c1212 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1115(u8);
impl TokenField_c1115 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1111(u8);
impl TokenField_c1111 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1015(u8);
impl TokenField_c1015 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1011(u8);
impl TokenField_c1011 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c1010(u8);
impl TokenField_c1010 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0916(u8);
impl TokenField_c0916 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0915(u8);
impl TokenField_c0915 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0911(u8);
impl TokenField_c0911 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0909(u8);
impl TokenField_c0909 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0815(u8);
impl TokenField_c0815 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0811(u8);
impl TokenField_c0811 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0809(u8);
impl TokenField_c0809 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0808(u8);
impl TokenField_c0808 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0715(u16);
impl TokenField_c0715 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0711(u8);
impl TokenField_c0711 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0709(u8);
impl TokenField_c0709 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0708(u8);
impl TokenField_c0708 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0707(u8);
impl TokenField_c0707 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0615(u16);
impl TokenField_c0615 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0611(u8);
impl TokenField_c0611 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0607(u8);
impl TokenField_c0607 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0606(u8);
impl TokenField_c0606 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0515(u16);
impl TokenField_c0515 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0508(u8);
impl TokenField_c0508 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0507(u8);
impl TokenField_c0507 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0506(u8);
impl TokenField_c0506 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0505(u8);
impl TokenField_c0505 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0431(u32);
impl TokenField_c0431 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0427(u32);
impl TokenField_c0427 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0415(u16);
impl TokenField_c0415 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0411(u8);
impl TokenField_c0411 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0409(u8);
impl TokenField_c0409 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0408(u8);
impl TokenField_c0408 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0407(u8);
impl TokenField_c0407 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0406(u8);
impl TokenField_c0406 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0405(u8);
impl TokenField_c0405 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0404(u8);
impl TokenField_c0404 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0315(u16);
impl TokenField_c0315 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0303(u8);
impl TokenField_c0303 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0215(u16);
impl TokenField_c0215 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0202(u8);
impl TokenField_c0202 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0115(u16);
impl TokenField_c0115 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0101(u8);
impl TokenField_c0101 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0031(u32);
impl TokenField_c0031 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0027(u32);
impl TokenField_c0027 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0014(u16);
impl TokenField_c0014 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0013(u16);
impl TokenField_c0013 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0012(u16);
impl TokenField_c0012 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0011(u16);
impl TokenField_c0011 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0010(u16);
impl TokenField_c0010 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0009(u16);
impl TokenField_c0009 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0008(u16);
impl TokenField_c0008 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0007(u8);
impl TokenField_c0007 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0006(u8);
impl TokenField_c0006 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0005(u8);
impl TokenField_c0005 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0004(u8);
impl TokenField_c0004 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0003(u8);
impl TokenField_c0003 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0002(u8);
impl TokenField_c0002 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0001(u8);
impl TokenField_c0001 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c0000(u8);
impl TokenField_c0000 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_D22(u8);
impl TokenField_thv_D22 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_N7(u8);
impl TokenField_thv_N7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_L7(u8);
impl TokenField_thv_L7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Q6(u8);
impl TokenField_thv_Q6 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_M5(u8);
impl TokenField_thv_M5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Qn0(u8);
impl TokenField_thv_Qn0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Qd0(u8);
impl TokenField_thv_Qd0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Qm0(u8);
impl TokenField_thv_Qm0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Qn1(u8);
impl TokenField_thv_Qn1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Qd1(u8);
impl TokenField_thv_Qd1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Qm1(u8);
impl TokenField_thv_Qm1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dn0(u8);
impl TokenField_thv_Dn0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd0(u8);
impl TokenField_thv_Dd0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_1(u8);
impl TokenField_thv_Dd_1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_2(u8);
impl TokenField_thv_Dd_2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_3(u8);
impl TokenField_thv_Dd_3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_4(u8);
impl TokenField_thv_Dd_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_5(u8);
impl TokenField_thv_Dd_5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_6(u8);
impl TokenField_thv_Dd_6 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_7(u8);
impl TokenField_thv_Dd_7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_8(u8);
impl TokenField_thv_Dd_8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_9(u8);
impl TokenField_thv_Dd_9 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_10(u8);
impl TokenField_thv_Dd_10 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_11(u8);
impl TokenField_thv_Dd_11 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_12(u8);
impl TokenField_thv_Dd_12 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_13(u8);
impl TokenField_thv_Dd_13 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_14(u8);
impl TokenField_thv_Dd_14 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_15(u8);
impl TokenField_thv_Dd_15 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd_16(u8);
impl TokenField_thv_Dd_16 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dm0(u8);
impl TokenField_thv_Dm0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dn1(u8);
impl TokenField_thv_Dn1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dd1(u8);
impl TokenField_thv_Dd1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dm1(u8);
impl TokenField_thv_Dm1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dm_3(u8);
impl TokenField_thv_Dm_3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Dm_4(u8);
impl TokenField_thv_Dm_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Sn0(u8);
impl TokenField_thv_Sn0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Sd0(u8);
impl TokenField_thv_Sd0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Sm0(u8);
impl TokenField_thv_Sm0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Sm0next(u8);
impl TokenField_thv_Sm0next {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Sn1(u8);
impl TokenField_thv_Sn1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Sd1(u8);
impl TokenField_thv_Sd1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Sm1(u8);
impl TokenField_thv_Sm1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Sm1next(u8);
impl TokenField_thv_Sm1next {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_cmode(u8);
impl TokenField_thv_cmode {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Sm0_3(u8);
impl TokenField_thv_Sm0_3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Sm1_3(u8);
impl TokenField_thv_Sm1_3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Rd(u8);
impl TokenField_thv_Rd {
    fn execution(&self) -> Register {
        meaning_6_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_6_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Rt(u8);
impl TokenField_thv_Rt {
    fn execution(&self) -> Register {
        meaning_6_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_6_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Rn(u8);
impl TokenField_thv_Rn {
    fn execution(&self) -> Register {
        meaning_6_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_6_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Rm(u8);
impl TokenField_thv_Rm {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_Rt2(u8);
impl TokenField_thv_Rt2 {
    fn execution(&self) -> Register {
        meaning_6_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_6_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_immed(u8);
impl TokenField_thv_immed {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_bit31(u8);
impl TokenField_thv_bit31 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_bit30(u8);
impl TokenField_thv_bit30 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_bit29(u8);
impl TokenField_thv_bit29 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_bit28(u8);
impl TokenField_thv_bit28 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_bit23(u8);
impl TokenField_thv_bit23 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_bit21(u8);
impl TokenField_thv_bit21 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_bit20(u8);
impl TokenField_thv_bit20 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_bit07(u8);
impl TokenField_thv_bit07 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_bit06(u8);
impl TokenField_thv_bit06 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_bit00(u8);
impl TokenField_thv_bit00 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2931(u8);
impl TokenField_thv_c2931 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2831(u8);
impl TokenField_thv_c2831 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2828(u8);
impl TokenField_thv_c2828 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2627(u8);
impl TokenField_thv_c2627 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2531(u8);
impl TokenField_thv_c2531 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2527(u8);
impl TokenField_thv_c2527 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2525(u8);
impl TokenField_thv_c2525 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2427(u8);
impl TokenField_thv_c2427 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2424(u8);
impl TokenField_thv_c2424 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2331(u16);
impl TokenField_thv_c2331 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2327(u8);
impl TokenField_thv_c2327 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2324(u8);
impl TokenField_thv_c2324 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2323(u8);
impl TokenField_thv_c2323 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2222(u8);
impl TokenField_thv_c2222 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2131(u16);
impl TokenField_thv_c2131 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2127(u8);
impl TokenField_thv_c2127 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2124(u8);
impl TokenField_thv_c2124 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2123(u8);
impl TokenField_thv_c2123 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2122(u8);
impl TokenField_thv_c2122 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2121(u8);
impl TokenField_thv_c2121 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2031(u16);
impl TokenField_thv_c2031 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2027(u8);
impl TokenField_thv_c2027 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2024(u8);
impl TokenField_thv_c2024 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2022(u8);
impl TokenField_thv_c2022 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2021(u8);
impl TokenField_thv_c2021 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c2020(u8);
impl TokenField_thv_c2020 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1921(u8);
impl TokenField_thv_c1921 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1919(u8);
impl TokenField_thv_c1919 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1821(u8);
impl TokenField_thv_c1821 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1819(u8);
impl TokenField_thv_c1819 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1818(u8);
impl TokenField_thv_c1818 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1721(u8);
impl TokenField_thv_c1721 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1719(u8);
impl TokenField_thv_c1719 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1718(u8);
impl TokenField_thv_c1718 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1717(u8);
impl TokenField_thv_c1717 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1631(u16);
impl TokenField_thv_c1631 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1627(u16);
impl TokenField_thv_c1627 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1621(u8);
impl TokenField_thv_c1621 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1620(u8);
impl TokenField_thv_c1620 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1619(u8);
impl TokenField_thv_c1619 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1618(u8);
impl TokenField_thv_c1618 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1617(u8);
impl TokenField_thv_c1617 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1616(u8);
impl TokenField_thv_c1616 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1515(u8);
impl TokenField_thv_c1515 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1415(u8);
impl TokenField_thv_c1415 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1414(u8);
impl TokenField_thv_c1414 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1313(u8);
impl TokenField_thv_c1313 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1215(u8);
impl TokenField_thv_c1215 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1212(u8);
impl TokenField_thv_c1212 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1111(u8);
impl TokenField_thv_c1111 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1011(u8);
impl TokenField_thv_c1011 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c1010(u8);
impl TokenField_thv_c1010 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0911(u8);
impl TokenField_thv_c0911 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0909(u8);
impl TokenField_thv_c0909 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0811(u8);
impl TokenField_thv_c0811 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0809(u8);
impl TokenField_thv_c0809 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0808(u8);
impl TokenField_thv_c0808 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0711(u8);
impl TokenField_thv_c0711 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0709(u8);
impl TokenField_thv_c0709 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0708(u8);
impl TokenField_thv_c0708 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0707(u8);
impl TokenField_thv_c0707 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0611(u8);
impl TokenField_thv_c0611 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0607(u8);
impl TokenField_thv_c0607 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0606(u8);
impl TokenField_thv_c0606 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0508(u8);
impl TokenField_thv_c0508 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0507(u8);
impl TokenField_thv_c0507 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0506(u8);
impl TokenField_thv_c0506 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0505(u8);
impl TokenField_thv_c0505 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0431(u32);
impl TokenField_thv_c0431 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0427(u32);
impl TokenField_thv_c0427 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0411(u8);
impl TokenField_thv_c0411 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0409(u8);
impl TokenField_thv_c0409 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0407(u8);
impl TokenField_thv_c0407 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0406(u8);
impl TokenField_thv_c0406 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0405(u8);
impl TokenField_thv_c0405 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0404(u8);
impl TokenField_thv_c0404 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0303(u8);
impl TokenField_thv_c0303 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0215(u16);
impl TokenField_thv_c0215 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0202(u8);
impl TokenField_thv_c0202 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0101(u8);
impl TokenField_thv_c0101 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0104(u8);
impl TokenField_thv_c0104 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0031(u32);
impl TokenField_thv_c0031 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0027(u32);
impl TokenField_thv_c0027 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0015(u16);
impl TokenField_thv_c0015 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0011(u16);
impl TokenField_thv_c0011 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0010(u16);
impl TokenField_thv_c0010 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0008(u16);
impl TokenField_thv_c0008 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0007(u8);
impl TokenField_thv_c0007 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0006(u8);
impl TokenField_thv_c0006 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0004(u8);
impl TokenField_thv_c0004 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0003(u8);
impl TokenField_thv_c0003 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0001(u8);
impl TokenField_thv_c0001 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_c0000(u8);
impl TokenField_thv_c0000 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_thv_option(u8);
impl TokenField_thv_option {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
struct TokenParser<const LEN: usize>([u8; LEN]);
impl<const LEN: usize> MemoryRead for TokenParser<LEN> {
    type AddressType = usize;
    fn read(
        &self,
        addr: Self::AddressType,
        buf: &mut [u8],
    ) -> Result<(), MemoryReadError<Self::AddressType>> {
        let end = addr + buf.len();
        self.0
            .get(addr..end)
            .map(|src| buf.copy_from_slice(src))
            .ok_or(MemoryReadError::UnableToReadMemory(addr, end))
    }
}
impl<const LEN: usize> TokenParser<LEN> {
    fn new(data: &[u8]) -> Option<Self> {
        let token_slice: &[u8] = data.get(..LEN)?;
        let token_data = <[u8; LEN]>::try_from(token_slice).unwrap();
        Some(Self(token_data))
    }
    fn TokenFieldpref(&self) -> TokenField_pref {
        let inner_value = self.read_u32::<false>(0, 0, 32).unwrap();
        TokenField_pref(u32::try_from(inner_value).unwrap())
    }
    fn TokenFieldcond(&self) -> TokenField_cond {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_cond(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldI25(&self) -> TokenField_I25 {
        let inner_value = self.read_u8::<false>(3, 1, 1).unwrap();
        TokenField_I25(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldP24(&self) -> TokenField_P24 {
        let inner_value = self.read_u8::<false>(3, 0, 1).unwrap();
        TokenField_P24(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldH24(&self) -> TokenField_H24 {
        let inner_value = self.read_u8::<false>(3, 0, 1).unwrap();
        TokenField_H24(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldL24(&self) -> TokenField_L24 {
        let inner_value = self.read_u8::<false>(3, 0, 1).unwrap();
        TokenField_L24(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldU23(&self) -> TokenField_U23 {
        let inner_value = self.read_u8::<false>(2, 7, 1).unwrap();
        TokenField_U23(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldB22(&self) -> TokenField_B22 {
        let inner_value = self.read_u8::<false>(2, 6, 1).unwrap();
        TokenField_B22(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldN22(&self) -> TokenField_N22 {
        let inner_value = self.read_u8::<false>(2, 6, 1).unwrap();
        TokenField_N22(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldS22(&self) -> TokenField_S22 {
        let inner_value = self.read_u8::<false>(2, 6, 1).unwrap();
        TokenField_S22(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldop(&self) -> TokenField_op {
        let inner_value = self.read_u16::<false>(2, 5, 4).unwrap();
        TokenField_op(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldW21(&self) -> TokenField_W21 {
        let inner_value = self.read_u8::<false>(2, 5, 1).unwrap();
        TokenField_W21(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldS20(&self) -> TokenField_S20 {
        let inner_value = self.read_u8::<false>(2, 4, 1).unwrap();
        TokenField_S20(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldL20(&self) -> TokenField_L20 {
        let inner_value = self.read_u8::<false>(2, 4, 1).unwrap();
        TokenField_L20(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRn(&self) -> TokenField_Rn {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_Rn(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRnLo(&self) -> TokenField_RnLo {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_RnLo(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldmsb(&self) -> TokenField_msb {
        let inner_value = self.read_u8::<false>(2, 0, 5).unwrap();
        TokenField_msb(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsatimm5(&self) -> TokenField_satimm5 {
        let inner_value = self.read_u8::<false>(2, 0, 5).unwrap();
        TokenField_satimm5(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsatimm4(&self) -> TokenField_satimm4 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_satimm4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldmask(&self) -> TokenField_mask {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_mask(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRd(&self) -> TokenField_Rd {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Rd(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRd2(&self) -> TokenField_Rd2 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Rd2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldCRd(&self) -> TokenField_CRd {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_CRd(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldCRn(&self) -> TokenField_CRn {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_CRn(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldCRm(&self) -> TokenField_CRm {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_CRm(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRdHi(&self) -> TokenField_RdHi {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_RdHi(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRdLo(&self) -> TokenField_RdLo {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_RdLo(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsmRd(&self) -> TokenField_smRd {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_smRd(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsmRa(&self) -> TokenField_smRa {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_smRa(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsmRm(&self) -> TokenField_smRm {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_smRm(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsmRn(&self) -> TokenField_smRn {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_smRn(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimmed12(&self) -> TokenField_immed12 {
        let inner_value = self.read_u16::<false>(1, 0, 12).unwrap();
        TokenField_immed12(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldRs(&self) -> TokenField_Rs {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_Rs(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldrotate(&self) -> TokenField_rotate {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_rotate(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimmedH(&self) -> TokenField_immedH {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_immedH(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldcpn(&self) -> TokenField_cpn {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_cpn(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldopc1(&self) -> TokenField_opc1 {
        let inner_value = self.read_u8::<false>(2, 5, 3).unwrap();
        TokenField_opc1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldopcode1(&self) -> TokenField_opcode1 {
        let inner_value = self.read_u8::<false>(2, 4, 4).unwrap();
        TokenField_opcode1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldopc2(&self) -> TokenField_opc2 {
        let inner_value = self.read_u8::<false>(0, 5, 3).unwrap();
        TokenField_opc2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldopcode2(&self) -> TokenField_opcode2 {
        let inner_value = self.read_u8::<false>(0, 5, 3).unwrap();
        TokenField_opcode2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldopcode3(&self) -> TokenField_opcode3 {
        let inner_value = self.read_u8::<false>(0, 4, 4).unwrap();
        TokenField_opcode3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldlsb(&self) -> TokenField_lsb {
        let inner_value = self.read_u16::<false>(0, 7, 5).unwrap();
        TokenField_lsb(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsftimm(&self) -> TokenField_sftimm {
        let inner_value = self.read_u16::<false>(0, 7, 5).unwrap();
        TokenField_sftimm(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsh(&self) -> TokenField_sh {
        let inner_value = self.read_u8::<false>(0, 6, 1).unwrap();
        TokenField_sh(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldshft(&self) -> TokenField_shft {
        let inner_value = self.read_u8::<false>(0, 5, 2).unwrap();
        TokenField_shft(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimmed24(&self) -> TokenField_immed24 {
        let inner_value = self.read_u32::<false>(0, 0, 24).unwrap();
        TokenField_immed24(u32::try_from(inner_value).unwrap())
    }
    fn TokenFieldaddr24(&self) -> TokenField_addr24 {
        let inner_value = self.read_i32::<false>(0, 0, 24).unwrap();
        TokenField_addr24(i32::try_from(inner_value).unwrap())
    }
    fn TokenFieldoffset_12(&self) -> TokenField_offset_12 {
        let inner_value = self.read_u16::<false>(0, 0, 12).unwrap();
        TokenField_offset_12(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldimmed(&self) -> TokenField_immed {
        let inner_value = self.read_u8::<false>(0, 0, 8).unwrap();
        TokenField_immed(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsrsMode(&self) -> TokenField_srsMode {
        let inner_value = self.read_u8::<false>(0, 0, 5).unwrap();
        TokenField_srsMode(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimmedL(&self) -> TokenField_immedL {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_immedL(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimmed4(&self) -> TokenField_immed4 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_immed4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFielddbOption(&self) -> TokenField_dbOption {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_dbOption(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldibOption(&self) -> TokenField_ibOption {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_ibOption(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRm(&self) -> TokenField_Rm {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Rm(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRmHi(&self) -> TokenField_RmHi {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_RmHi(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldRm2(&self) -> TokenField_Rm2 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Rm2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldx(&self) -> TokenField_x {
        let inner_value = self.read_u8::<false>(0, 5, 1).unwrap();
        TokenField_x(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldr(&self) -> TokenField_r {
        let inner_value = self.read_u8::<false>(0, 5, 1).unwrap();
        TokenField_r(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldy(&self) -> TokenField_y {
        let inner_value = self.read_u8::<false>(0, 6, 1).unwrap();
        TokenField_y(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldD22(&self) -> TokenField_D22 {
        let inner_value = self.read_u8::<false>(2, 6, 1).unwrap();
        TokenField_D22(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldN7(&self) -> TokenField_N7 {
        let inner_value = self.read_u8::<false>(0, 7, 1).unwrap();
        TokenField_N7(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldL7(&self) -> TokenField_L7 {
        let inner_value = self.read_u8::<false>(0, 7, 1).unwrap();
        TokenField_L7(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldQ6(&self) -> TokenField_Q6 {
        let inner_value = self.read_u8::<false>(0, 6, 1).unwrap();
        TokenField_Q6(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldM5(&self) -> TokenField_M5 {
        let inner_value = self.read_u8::<false>(0, 5, 1).unwrap();
        TokenField_M5(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldQn0(&self) -> TokenField_Qn0 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_Qn0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldQd0(&self) -> TokenField_Qd0 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Qd0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldQm0(&self) -> TokenField_Qm0 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Qm0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldQn1(&self) -> TokenField_Qn1 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_Qn1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldQd1(&self) -> TokenField_Qd1 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Qd1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldQm1(&self) -> TokenField_Qm1 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Qm1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDn0(&self) -> TokenField_Dn0 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_Dn0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd0(&self) -> TokenField_Dd0 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_1(&self) -> TokenField_Dd_1 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_2(&self) -> TokenField_Dd_2 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_3(&self) -> TokenField_Dd_3 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_4(&self) -> TokenField_Dd_4 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_5(&self) -> TokenField_Dd_5 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_5(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_6(&self) -> TokenField_Dd_6 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_6(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_7(&self) -> TokenField_Dd_7 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_7(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_8(&self) -> TokenField_Dd_8 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_8(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_9(&self) -> TokenField_Dd_9 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_9(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_10(&self) -> TokenField_Dd_10 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_10(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_11(&self) -> TokenField_Dd_11 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_11(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_12(&self) -> TokenField_Dd_12 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_12(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_13(&self) -> TokenField_Dd_13 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_13(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_14(&self) -> TokenField_Dd_14 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_14(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_15(&self) -> TokenField_Dd_15 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_15(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd_16(&self) -> TokenField_Dd_16 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd_16(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDm0(&self) -> TokenField_Dm0 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Dm0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDn1(&self) -> TokenField_Dn1 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_Dn1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDd1(&self) -> TokenField_Dd1 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Dd1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDm1(&self) -> TokenField_Dm1 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Dm1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDm_3(&self) -> TokenField_Dm_3 {
        let inner_value = self.read_u8::<false>(0, 0, 3).unwrap();
        TokenField_Dm_3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldDm_4(&self) -> TokenField_Dm_4 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Dm_4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldSn0(&self) -> TokenField_Sn0 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_Sn0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldSd0(&self) -> TokenField_Sd0 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Sd0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldSm0(&self) -> TokenField_Sm0 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Sm0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldSm0next(&self) -> TokenField_Sm0next {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Sm0next(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldSn1(&self) -> TokenField_Sn1 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_Sn1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldSd1(&self) -> TokenField_Sd1 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_Sd1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldSm1(&self) -> TokenField_Sm1 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Sm1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldSm1next(&self) -> TokenField_Sm1next {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_Sm1next(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldSm0_3(&self) -> TokenField_Sm0_3 {
        let inner_value = self.read_u8::<false>(0, 0, 3).unwrap();
        TokenField_Sm0_3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldSm1_3(&self) -> TokenField_Sm1_3 {
        let inner_value = self.read_u8::<false>(0, 0, 3).unwrap();
        TokenField_Sm1_3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldcmode(&self) -> TokenField_cmode {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_cmode(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbit31(&self) -> TokenField_bit31 {
        let inner_value = self.read_u8::<false>(3, 7, 1).unwrap();
        TokenField_bit31(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbit30(&self) -> TokenField_bit30 {
        let inner_value = self.read_u8::<false>(3, 6, 1).unwrap();
        TokenField_bit30(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbit29(&self) -> TokenField_bit29 {
        let inner_value = self.read_u8::<false>(3, 5, 1).unwrap();
        TokenField_bit29(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbit28(&self) -> TokenField_bit28 {
        let inner_value = self.read_u8::<false>(3, 4, 1).unwrap();
        TokenField_bit28(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2831(&self) -> TokenField_c2831 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_c2831(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2627(&self) -> TokenField_c2627 {
        let inner_value = self.read_u8::<false>(3, 2, 2).unwrap();
        TokenField_c2627(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2531(&self) -> TokenField_c2531 {
        let inner_value = self.read_u8::<false>(3, 1, 7).unwrap();
        TokenField_c2531(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2527(&self) -> TokenField_c2527 {
        let inner_value = self.read_u8::<false>(3, 1, 3).unwrap();
        TokenField_c2527(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2525(&self) -> TokenField_c2525 {
        let inner_value = self.read_u8::<false>(3, 1, 1).unwrap();
        TokenField_c2525(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2427(&self) -> TokenField_c2427 {
        let inner_value = self.read_u8::<false>(3, 0, 4).unwrap();
        TokenField_c2427(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2424(&self) -> TokenField_c2424 {
        let inner_value = self.read_u8::<false>(3, 0, 1).unwrap();
        TokenField_c2424(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2331(&self) -> TokenField_c2331 {
        let inner_value = self.read_u16::<false>(2, 7, 9).unwrap();
        TokenField_c2331(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2327(&self) -> TokenField_c2327 {
        let inner_value = self.read_u16::<false>(2, 7, 5).unwrap();
        TokenField_c2327(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2324(&self) -> TokenField_c2324 {
        let inner_value = self.read_u16::<false>(2, 7, 2).unwrap();
        TokenField_c2324(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2323(&self) -> TokenField_c2323 {
        let inner_value = self.read_u8::<false>(2, 7, 1).unwrap();
        TokenField_c2323(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2222(&self) -> TokenField_c2222 {
        let inner_value = self.read_u8::<false>(2, 6, 1).unwrap();
        TokenField_c2222(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2131(&self) -> TokenField_c2131 {
        let inner_value = self.read_u16::<false>(2, 5, 11).unwrap();
        TokenField_c2131(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2127(&self) -> TokenField_c2127 {
        let inner_value = self.read_u16::<false>(2, 5, 7).unwrap();
        TokenField_c2127(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2124(&self) -> TokenField_c2124 {
        let inner_value = self.read_u16::<false>(2, 5, 4).unwrap();
        TokenField_c2124(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2123(&self) -> TokenField_c2123 {
        let inner_value = self.read_u8::<false>(2, 5, 3).unwrap();
        TokenField_c2123(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2122(&self) -> TokenField_c2122 {
        let inner_value = self.read_u8::<false>(2, 5, 2).unwrap();
        TokenField_c2122(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2121(&self) -> TokenField_c2121 {
        let inner_value = self.read_u8::<false>(2, 5, 1).unwrap();
        TokenField_c2121(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2027(&self) -> TokenField_c2027 {
        let inner_value = self.read_u16::<false>(2, 4, 8).unwrap();
        TokenField_c2027(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2024(&self) -> TokenField_c2024 {
        let inner_value = self.read_u16::<false>(2, 4, 5).unwrap();
        TokenField_c2024(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2022(&self) -> TokenField_c2022 {
        let inner_value = self.read_u8::<false>(2, 4, 3).unwrap();
        TokenField_c2022(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2021(&self) -> TokenField_c2021 {
        let inner_value = self.read_u8::<false>(2, 4, 2).unwrap();
        TokenField_c2021(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc2020(&self) -> TokenField_c2020 {
        let inner_value = self.read_u8::<false>(2, 4, 1).unwrap();
        TokenField_c2020(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1921(&self) -> TokenField_c1921 {
        let inner_value = self.read_u8::<false>(2, 3, 3).unwrap();
        TokenField_c1921(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1919(&self) -> TokenField_c1919 {
        let inner_value = self.read_u8::<false>(2, 3, 1).unwrap();
        TokenField_c1919(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1821(&self) -> TokenField_c1821 {
        let inner_value = self.read_u8::<false>(2, 2, 4).unwrap();
        TokenField_c1821(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1819(&self) -> TokenField_c1819 {
        let inner_value = self.read_u8::<false>(2, 2, 2).unwrap();
        TokenField_c1819(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1818(&self) -> TokenField_c1818 {
        let inner_value = self.read_u8::<false>(2, 2, 1).unwrap();
        TokenField_c1818(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1721(&self) -> TokenField_c1721 {
        let inner_value = self.read_u8::<false>(2, 1, 5).unwrap();
        TokenField_c1721(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1719(&self) -> TokenField_c1719 {
        let inner_value = self.read_u8::<false>(2, 1, 3).unwrap();
        TokenField_c1719(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1718(&self) -> TokenField_c1718 {
        let inner_value = self.read_u8::<false>(2, 1, 2).unwrap();
        TokenField_c1718(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1717(&self) -> TokenField_c1717 {
        let inner_value = self.read_u8::<false>(2, 1, 1).unwrap();
        TokenField_c1717(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1631(&self) -> TokenField_c1631 {
        let inner_value = self.read_u16::<false>(2, 0, 16).unwrap();
        TokenField_c1631(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1627(&self) -> TokenField_c1627 {
        let inner_value = self.read_u16::<false>(2, 0, 12).unwrap();
        TokenField_c1627(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1621(&self) -> TokenField_c1621 {
        let inner_value = self.read_u8::<false>(2, 0, 6).unwrap();
        TokenField_c1621(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1620(&self) -> TokenField_c1620 {
        let inner_value = self.read_u8::<false>(2, 0, 5).unwrap();
        TokenField_c1620(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1619(&self) -> TokenField_c1619 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_c1619(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1618(&self) -> TokenField_c1618 {
        let inner_value = self.read_u8::<false>(2, 0, 3).unwrap();
        TokenField_c1618(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1617(&self) -> TokenField_c1617 {
        let inner_value = self.read_u8::<false>(2, 0, 2).unwrap();
        TokenField_c1617(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1616(&self) -> TokenField_c1616 {
        let inner_value = self.read_u8::<false>(2, 0, 1).unwrap();
        TokenField_c1616(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1515(&self) -> TokenField_c1515 {
        let inner_value = self.read_u8::<false>(1, 7, 1).unwrap();
        TokenField_c1515(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1415(&self) -> TokenField_c1415 {
        let inner_value = self.read_u8::<false>(1, 6, 2).unwrap();
        TokenField_c1415(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1414(&self) -> TokenField_c1414 {
        let inner_value = self.read_u8::<false>(1, 6, 1).unwrap();
        TokenField_c1414(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1315(&self) -> TokenField_c1315 {
        let inner_value = self.read_u8::<false>(1, 5, 3).unwrap();
        TokenField_c1315(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1313(&self) -> TokenField_c1313 {
        let inner_value = self.read_u8::<false>(1, 5, 1).unwrap();
        TokenField_c1313(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1215(&self) -> TokenField_c1215 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_c1215(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1212(&self) -> TokenField_c1212 {
        let inner_value = self.read_u8::<false>(1, 4, 1).unwrap();
        TokenField_c1212(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1115(&self) -> TokenField_c1115 {
        let inner_value = self.read_u8::<false>(1, 3, 5).unwrap();
        TokenField_c1115(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1111(&self) -> TokenField_c1111 {
        let inner_value = self.read_u8::<false>(1, 3, 1).unwrap();
        TokenField_c1111(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1015(&self) -> TokenField_c1015 {
        let inner_value = self.read_u8::<false>(1, 2, 6).unwrap();
        TokenField_c1015(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1011(&self) -> TokenField_c1011 {
        let inner_value = self.read_u8::<false>(1, 2, 2).unwrap();
        TokenField_c1011(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc1010(&self) -> TokenField_c1010 {
        let inner_value = self.read_u8::<false>(1, 2, 1).unwrap();
        TokenField_c1010(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0916(&self) -> TokenField_c0916 {
        let inner_value = self.read_u16::<false>(1, 1, 8).unwrap();
        TokenField_c0916(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0915(&self) -> TokenField_c0915 {
        let inner_value = self.read_u8::<false>(1, 1, 7).unwrap();
        TokenField_c0915(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0911(&self) -> TokenField_c0911 {
        let inner_value = self.read_u8::<false>(1, 1, 3).unwrap();
        TokenField_c0911(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0909(&self) -> TokenField_c0909 {
        let inner_value = self.read_u8::<false>(1, 1, 1).unwrap();
        TokenField_c0909(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0815(&self) -> TokenField_c0815 {
        let inner_value = self.read_u8::<false>(1, 0, 8).unwrap();
        TokenField_c0815(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0811(&self) -> TokenField_c0811 {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_c0811(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0809(&self) -> TokenField_c0809 {
        let inner_value = self.read_u8::<false>(1, 0, 2).unwrap();
        TokenField_c0809(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0808(&self) -> TokenField_c0808 {
        let inner_value = self.read_u8::<false>(1, 0, 1).unwrap();
        TokenField_c0808(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0715(&self) -> TokenField_c0715 {
        let inner_value = self.read_u16::<false>(0, 7, 9).unwrap();
        TokenField_c0715(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0711(&self) -> TokenField_c0711 {
        let inner_value = self.read_u16::<false>(0, 7, 5).unwrap();
        TokenField_c0711(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0709(&self) -> TokenField_c0709 {
        let inner_value = self.read_u16::<false>(0, 7, 3).unwrap();
        TokenField_c0709(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0708(&self) -> TokenField_c0708 {
        let inner_value = self.read_u16::<false>(0, 7, 2).unwrap();
        TokenField_c0708(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0707(&self) -> TokenField_c0707 {
        let inner_value = self.read_u8::<false>(0, 7, 1).unwrap();
        TokenField_c0707(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0615(&self) -> TokenField_c0615 {
        let inner_value = self.read_u16::<false>(0, 6, 10).unwrap();
        TokenField_c0615(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0611(&self) -> TokenField_c0611 {
        let inner_value = self.read_u16::<false>(0, 6, 6).unwrap();
        TokenField_c0611(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0607(&self) -> TokenField_c0607 {
        let inner_value = self.read_u8::<false>(0, 6, 2).unwrap();
        TokenField_c0607(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0606(&self) -> TokenField_c0606 {
        let inner_value = self.read_u8::<false>(0, 6, 1).unwrap();
        TokenField_c0606(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0515(&self) -> TokenField_c0515 {
        let inner_value = self.read_u16::<false>(0, 5, 11).unwrap();
        TokenField_c0515(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0508(&self) -> TokenField_c0508 {
        let inner_value = self.read_u16::<false>(0, 5, 4).unwrap();
        TokenField_c0508(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0507(&self) -> TokenField_c0507 {
        let inner_value = self.read_u8::<false>(0, 5, 3).unwrap();
        TokenField_c0507(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0506(&self) -> TokenField_c0506 {
        let inner_value = self.read_u8::<false>(0, 5, 2).unwrap();
        TokenField_c0506(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0505(&self) -> TokenField_c0505 {
        let inner_value = self.read_u8::<false>(0, 5, 1).unwrap();
        TokenField_c0505(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0431(&self) -> TokenField_c0431 {
        let inner_value = self.read_u32::<false>(0, 4, 28).unwrap();
        TokenField_c0431(u32::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0427(&self) -> TokenField_c0427 {
        let inner_value = self.read_u32::<false>(0, 4, 24).unwrap();
        TokenField_c0427(u32::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0415(&self) -> TokenField_c0415 {
        let inner_value = self.read_u16::<false>(0, 4, 12).unwrap();
        TokenField_c0415(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0411(&self) -> TokenField_c0411 {
        let inner_value = self.read_u16::<false>(0, 4, 8).unwrap();
        TokenField_c0411(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0409(&self) -> TokenField_c0409 {
        let inner_value = self.read_u16::<false>(0, 4, 6).unwrap();
        TokenField_c0409(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0408(&self) -> TokenField_c0408 {
        let inner_value = self.read_u16::<false>(0, 4, 5).unwrap();
        TokenField_c0408(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0407(&self) -> TokenField_c0407 {
        let inner_value = self.read_u8::<false>(0, 4, 4).unwrap();
        TokenField_c0407(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0406(&self) -> TokenField_c0406 {
        let inner_value = self.read_u8::<false>(0, 4, 3).unwrap();
        TokenField_c0406(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0405(&self) -> TokenField_c0405 {
        let inner_value = self.read_u8::<false>(0, 4, 2).unwrap();
        TokenField_c0405(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0404(&self) -> TokenField_c0404 {
        let inner_value = self.read_u8::<false>(0, 4, 1).unwrap();
        TokenField_c0404(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0315(&self) -> TokenField_c0315 {
        let inner_value = self.read_u16::<false>(0, 3, 13).unwrap();
        TokenField_c0315(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0303(&self) -> TokenField_c0303 {
        let inner_value = self.read_u8::<false>(0, 3, 1).unwrap();
        TokenField_c0303(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0215(&self) -> TokenField_c0215 {
        let inner_value = self.read_u16::<false>(0, 2, 14).unwrap();
        TokenField_c0215(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0202(&self) -> TokenField_c0202 {
        let inner_value = self.read_u8::<false>(0, 2, 1).unwrap();
        TokenField_c0202(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0115(&self) -> TokenField_c0115 {
        let inner_value = self.read_u16::<false>(0, 1, 15).unwrap();
        TokenField_c0115(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0101(&self) -> TokenField_c0101 {
        let inner_value = self.read_u8::<false>(0, 1, 1).unwrap();
        TokenField_c0101(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0031(&self) -> TokenField_c0031 {
        let inner_value = self.read_u32::<false>(0, 0, 32).unwrap();
        TokenField_c0031(u32::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0027(&self) -> TokenField_c0027 {
        let inner_value = self.read_u32::<false>(0, 0, 28).unwrap();
        TokenField_c0027(u32::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0014(&self) -> TokenField_c0014 {
        let inner_value = self.read_u16::<false>(0, 0, 15).unwrap();
        TokenField_c0014(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0013(&self) -> TokenField_c0013 {
        let inner_value = self.read_u16::<false>(0, 0, 14).unwrap();
        TokenField_c0013(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0012(&self) -> TokenField_c0012 {
        let inner_value = self.read_u16::<false>(0, 0, 13).unwrap();
        TokenField_c0012(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0011(&self) -> TokenField_c0011 {
        let inner_value = self.read_u16::<false>(0, 0, 12).unwrap();
        TokenField_c0011(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0010(&self) -> TokenField_c0010 {
        let inner_value = self.read_u16::<false>(0, 0, 11).unwrap();
        TokenField_c0010(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0009(&self) -> TokenField_c0009 {
        let inner_value = self.read_u16::<false>(0, 0, 10).unwrap();
        TokenField_c0009(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0008(&self) -> TokenField_c0008 {
        let inner_value = self.read_u16::<false>(0, 0, 9).unwrap();
        TokenField_c0008(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0007(&self) -> TokenField_c0007 {
        let inner_value = self.read_u8::<false>(0, 0, 8).unwrap();
        TokenField_c0007(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0006(&self) -> TokenField_c0006 {
        let inner_value = self.read_u8::<false>(0, 0, 7).unwrap();
        TokenField_c0006(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0005(&self) -> TokenField_c0005 {
        let inner_value = self.read_u8::<false>(0, 0, 6).unwrap();
        TokenField_c0005(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0004(&self) -> TokenField_c0004 {
        let inner_value = self.read_u8::<false>(0, 0, 5).unwrap();
        TokenField_c0004(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0003(&self) -> TokenField_c0003 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_c0003(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0002(&self) -> TokenField_c0002 {
        let inner_value = self.read_u8::<false>(0, 0, 3).unwrap();
        TokenField_c0002(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0001(&self) -> TokenField_c0001 {
        let inner_value = self.read_u8::<false>(0, 0, 2).unwrap();
        TokenField_c0001(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldc0000(&self) -> TokenField_c0000 {
        let inner_value = self.read_u8::<false>(0, 0, 1).unwrap();
        TokenField_c0000(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_D22(&self) -> TokenField_thv_D22 {
        let inner_value = self.read_u8::<false>(0, 6, 1).unwrap();
        TokenField_thv_D22(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_N7(&self) -> TokenField_thv_N7 {
        let inner_value = self.read_u8::<false>(2, 7, 1).unwrap();
        TokenField_thv_N7(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_L7(&self) -> TokenField_thv_L7 {
        let inner_value = self.read_u8::<false>(2, 7, 1).unwrap();
        TokenField_thv_L7(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Q6(&self) -> TokenField_thv_Q6 {
        let inner_value = self.read_u8::<false>(2, 6, 1).unwrap();
        TokenField_thv_Q6(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_M5(&self) -> TokenField_thv_M5 {
        let inner_value = self.read_u8::<false>(2, 5, 1).unwrap();
        TokenField_thv_M5(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Qn0(&self) -> TokenField_thv_Qn0 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_thv_Qn0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Qd0(&self) -> TokenField_thv_Qd0 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Qd0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Qm0(&self) -> TokenField_thv_Qm0 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_Qm0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Qn1(&self) -> TokenField_thv_Qn1 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_thv_Qn1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Qd1(&self) -> TokenField_thv_Qd1 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Qd1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Qm1(&self) -> TokenField_thv_Qm1 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_Qm1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dn0(&self) -> TokenField_thv_Dn0 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_thv_Dn0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd0(&self) -> TokenField_thv_Dd0 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_1(&self) -> TokenField_thv_Dd_1 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_2(&self) -> TokenField_thv_Dd_2 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_3(&self) -> TokenField_thv_Dd_3 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_4(&self) -> TokenField_thv_Dd_4 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_5(&self) -> TokenField_thv_Dd_5 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_5(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_6(&self) -> TokenField_thv_Dd_6 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_6(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_7(&self) -> TokenField_thv_Dd_7 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_7(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_8(&self) -> TokenField_thv_Dd_8 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_8(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_9(&self) -> TokenField_thv_Dd_9 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_9(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_10(&self) -> TokenField_thv_Dd_10 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_10(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_11(&self) -> TokenField_thv_Dd_11 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_11(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_12(&self) -> TokenField_thv_Dd_12 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_12(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_13(&self) -> TokenField_thv_Dd_13 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_13(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_14(&self) -> TokenField_thv_Dd_14 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_14(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_15(&self) -> TokenField_thv_Dd_15 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_15(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd_16(&self) -> TokenField_thv_Dd_16 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd_16(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dm0(&self) -> TokenField_thv_Dm0 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_Dm0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dn1(&self) -> TokenField_thv_Dn1 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_thv_Dn1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dd1(&self) -> TokenField_thv_Dd1 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Dd1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dm1(&self) -> TokenField_thv_Dm1 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_Dm1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dm_3(&self) -> TokenField_thv_Dm_3 {
        let inner_value = self.read_u8::<false>(2, 0, 3).unwrap();
        TokenField_thv_Dm_3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Dm_4(&self) -> TokenField_thv_Dm_4 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_Dm_4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Sn0(&self) -> TokenField_thv_Sn0 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_thv_Sn0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Sd0(&self) -> TokenField_thv_Sd0 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Sd0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Sm0(&self) -> TokenField_thv_Sm0 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_Sm0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Sm0next(&self) -> TokenField_thv_Sm0next {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_Sm0next(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Sn1(&self) -> TokenField_thv_Sn1 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_thv_Sn1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Sd1(&self) -> TokenField_thv_Sd1 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Sd1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Sm1(&self) -> TokenField_thv_Sm1 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_Sm1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Sm1next(&self) -> TokenField_thv_Sm1next {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_Sm1next(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_cmode(&self) -> TokenField_thv_cmode {
        let inner_value = self.read_u8::<false>(3, 0, 4).unwrap();
        TokenField_thv_cmode(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Sm0_3(&self) -> TokenField_thv_Sm0_3 {
        let inner_value = self.read_u8::<false>(2, 0, 3).unwrap();
        TokenField_thv_Sm0_3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Sm1_3(&self) -> TokenField_thv_Sm1_3 {
        let inner_value = self.read_u8::<false>(2, 0, 3).unwrap();
        TokenField_thv_Sm1_3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Rd(&self) -> TokenField_thv_Rd {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Rd(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Rt(&self) -> TokenField_thv_Rt {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_Rt(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Rn(&self) -> TokenField_thv_Rn {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_thv_Rn(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Rm(&self) -> TokenField_thv_Rm {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_Rm(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_Rt2(&self) -> TokenField_thv_Rt2 {
        let inner_value = self.read_u8::<false>(3, 0, 4).unwrap();
        TokenField_thv_Rt2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_immed(&self) -> TokenField_thv_immed {
        let inner_value = self.read_u8::<false>(2, 0, 8).unwrap();
        TokenField_thv_immed(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_bit31(&self) -> TokenField_thv_bit31 {
        let inner_value = self.read_u8::<false>(1, 7, 1).unwrap();
        TokenField_thv_bit31(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_bit30(&self) -> TokenField_thv_bit30 {
        let inner_value = self.read_u8::<false>(1, 6, 1).unwrap();
        TokenField_thv_bit30(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_bit29(&self) -> TokenField_thv_bit29 {
        let inner_value = self.read_u8::<false>(1, 5, 1).unwrap();
        TokenField_thv_bit29(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_bit28(&self) -> TokenField_thv_bit28 {
        let inner_value = self.read_u8::<false>(1, 4, 1).unwrap();
        TokenField_thv_bit28(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_bit23(&self) -> TokenField_thv_bit23 {
        let inner_value = self.read_u8::<false>(0, 7, 1).unwrap();
        TokenField_thv_bit23(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_bit21(&self) -> TokenField_thv_bit21 {
        let inner_value = self.read_u8::<false>(0, 5, 1).unwrap();
        TokenField_thv_bit21(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_bit20(&self) -> TokenField_thv_bit20 {
        let inner_value = self.read_u8::<false>(0, 4, 1).unwrap();
        TokenField_thv_bit20(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_bit07(&self) -> TokenField_thv_bit07 {
        let inner_value = self.read_u8::<false>(2, 7, 1).unwrap();
        TokenField_thv_bit07(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_bit06(&self) -> TokenField_thv_bit06 {
        let inner_value = self.read_u8::<false>(2, 6, 1).unwrap();
        TokenField_thv_bit06(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_bit00(&self) -> TokenField_thv_bit00 {
        let inner_value = self.read_u8::<false>(2, 0, 1).unwrap();
        TokenField_thv_bit00(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2931(&self) -> TokenField_thv_c2931 {
        let inner_value = self.read_u8::<false>(1, 5, 3).unwrap();
        TokenField_thv_c2931(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2831(&self) -> TokenField_thv_c2831 {
        let inner_value = self.read_u8::<false>(1, 4, 4).unwrap();
        TokenField_thv_c2831(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2828(&self) -> TokenField_thv_c2828 {
        let inner_value = self.read_u8::<false>(1, 4, 1).unwrap();
        TokenField_thv_c2828(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2627(&self) -> TokenField_thv_c2627 {
        let inner_value = self.read_u8::<false>(1, 2, 2).unwrap();
        TokenField_thv_c2627(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2531(&self) -> TokenField_thv_c2531 {
        let inner_value = self.read_u8::<false>(1, 1, 7).unwrap();
        TokenField_thv_c2531(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2527(&self) -> TokenField_thv_c2527 {
        let inner_value = self.read_u8::<false>(1, 1, 3).unwrap();
        TokenField_thv_c2527(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2525(&self) -> TokenField_thv_c2525 {
        let inner_value = self.read_u8::<false>(1, 1, 1).unwrap();
        TokenField_thv_c2525(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2427(&self) -> TokenField_thv_c2427 {
        let inner_value = self.read_u8::<false>(1, 0, 4).unwrap();
        TokenField_thv_c2427(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2424(&self) -> TokenField_thv_c2424 {
        let inner_value = self.read_u8::<false>(1, 0, 1).unwrap();
        TokenField_thv_c2424(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2331(&self) -> TokenField_thv_c2331 {
        let inner_value = self.read_u16::<false>(0, 7, 9).unwrap();
        TokenField_thv_c2331(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2327(&self) -> TokenField_thv_c2327 {
        let inner_value = self.read_u16::<false>(0, 7, 5).unwrap();
        TokenField_thv_c2327(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2324(&self) -> TokenField_thv_c2324 {
        let inner_value = self.read_u16::<false>(0, 7, 2).unwrap();
        TokenField_thv_c2324(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2323(&self) -> TokenField_thv_c2323 {
        let inner_value = self.read_u8::<false>(0, 7, 1).unwrap();
        TokenField_thv_c2323(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2222(&self) -> TokenField_thv_c2222 {
        let inner_value = self.read_u8::<false>(0, 6, 1).unwrap();
        TokenField_thv_c2222(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2131(&self) -> TokenField_thv_c2131 {
        let inner_value = self.read_u16::<false>(0, 5, 11).unwrap();
        TokenField_thv_c2131(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2127(&self) -> TokenField_thv_c2127 {
        let inner_value = self.read_u16::<false>(0, 5, 7).unwrap();
        TokenField_thv_c2127(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2124(&self) -> TokenField_thv_c2124 {
        let inner_value = self.read_u16::<false>(0, 5, 4).unwrap();
        TokenField_thv_c2124(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2123(&self) -> TokenField_thv_c2123 {
        let inner_value = self.read_u8::<false>(0, 5, 3).unwrap();
        TokenField_thv_c2123(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2122(&self) -> TokenField_thv_c2122 {
        let inner_value = self.read_u8::<false>(0, 5, 2).unwrap();
        TokenField_thv_c2122(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2121(&self) -> TokenField_thv_c2121 {
        let inner_value = self.read_u8::<false>(0, 5, 1).unwrap();
        TokenField_thv_c2121(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2031(&self) -> TokenField_thv_c2031 {
        let inner_value = self.read_u16::<false>(0, 4, 12).unwrap();
        TokenField_thv_c2031(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2027(&self) -> TokenField_thv_c2027 {
        let inner_value = self.read_u16::<false>(0, 4, 8).unwrap();
        TokenField_thv_c2027(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2024(&self) -> TokenField_thv_c2024 {
        let inner_value = self.read_u16::<false>(0, 4, 5).unwrap();
        TokenField_thv_c2024(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2022(&self) -> TokenField_thv_c2022 {
        let inner_value = self.read_u8::<false>(0, 4, 3).unwrap();
        TokenField_thv_c2022(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2021(&self) -> TokenField_thv_c2021 {
        let inner_value = self.read_u8::<false>(0, 4, 2).unwrap();
        TokenField_thv_c2021(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c2020(&self) -> TokenField_thv_c2020 {
        let inner_value = self.read_u8::<false>(0, 4, 1).unwrap();
        TokenField_thv_c2020(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1921(&self) -> TokenField_thv_c1921 {
        let inner_value = self.read_u8::<false>(0, 3, 3).unwrap();
        TokenField_thv_c1921(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1919(&self) -> TokenField_thv_c1919 {
        let inner_value = self.read_u8::<false>(0, 3, 1).unwrap();
        TokenField_thv_c1919(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1821(&self) -> TokenField_thv_c1821 {
        let inner_value = self.read_u8::<false>(0, 2, 4).unwrap();
        TokenField_thv_c1821(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1819(&self) -> TokenField_thv_c1819 {
        let inner_value = self.read_u8::<false>(0, 2, 2).unwrap();
        TokenField_thv_c1819(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1818(&self) -> TokenField_thv_c1818 {
        let inner_value = self.read_u8::<false>(0, 2, 1).unwrap();
        TokenField_thv_c1818(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1721(&self) -> TokenField_thv_c1721 {
        let inner_value = self.read_u8::<false>(0, 1, 5).unwrap();
        TokenField_thv_c1721(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1719(&self) -> TokenField_thv_c1719 {
        let inner_value = self.read_u8::<false>(0, 1, 3).unwrap();
        TokenField_thv_c1719(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1718(&self) -> TokenField_thv_c1718 {
        let inner_value = self.read_u8::<false>(0, 1, 2).unwrap();
        TokenField_thv_c1718(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1717(&self) -> TokenField_thv_c1717 {
        let inner_value = self.read_u8::<false>(0, 1, 1).unwrap();
        TokenField_thv_c1717(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1631(&self) -> TokenField_thv_c1631 {
        let inner_value = self.read_u16::<false>(0, 0, 16).unwrap();
        TokenField_thv_c1631(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1627(&self) -> TokenField_thv_c1627 {
        let inner_value = self.read_u16::<false>(0, 0, 12).unwrap();
        TokenField_thv_c1627(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1621(&self) -> TokenField_thv_c1621 {
        let inner_value = self.read_u8::<false>(0, 0, 6).unwrap();
        TokenField_thv_c1621(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1620(&self) -> TokenField_thv_c1620 {
        let inner_value = self.read_u8::<false>(0, 0, 5).unwrap();
        TokenField_thv_c1620(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1619(&self) -> TokenField_thv_c1619 {
        let inner_value = self.read_u8::<false>(0, 0, 4).unwrap();
        TokenField_thv_c1619(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1618(&self) -> TokenField_thv_c1618 {
        let inner_value = self.read_u8::<false>(0, 0, 3).unwrap();
        TokenField_thv_c1618(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1617(&self) -> TokenField_thv_c1617 {
        let inner_value = self.read_u8::<false>(0, 0, 2).unwrap();
        TokenField_thv_c1617(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1616(&self) -> TokenField_thv_c1616 {
        let inner_value = self.read_u8::<false>(0, 0, 1).unwrap();
        TokenField_thv_c1616(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1515(&self) -> TokenField_thv_c1515 {
        let inner_value = self.read_u8::<false>(3, 7, 1).unwrap();
        TokenField_thv_c1515(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1415(&self) -> TokenField_thv_c1415 {
        let inner_value = self.read_u8::<false>(3, 6, 2).unwrap();
        TokenField_thv_c1415(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1414(&self) -> TokenField_thv_c1414 {
        let inner_value = self.read_u8::<false>(3, 6, 1).unwrap();
        TokenField_thv_c1414(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1313(&self) -> TokenField_thv_c1313 {
        let inner_value = self.read_u8::<false>(3, 5, 1).unwrap();
        TokenField_thv_c1313(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1215(&self) -> TokenField_thv_c1215 {
        let inner_value = self.read_u8::<false>(3, 4, 4).unwrap();
        TokenField_thv_c1215(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1212(&self) -> TokenField_thv_c1212 {
        let inner_value = self.read_u8::<false>(3, 4, 1).unwrap();
        TokenField_thv_c1212(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1111(&self) -> TokenField_thv_c1111 {
        let inner_value = self.read_u8::<false>(3, 3, 1).unwrap();
        TokenField_thv_c1111(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1011(&self) -> TokenField_thv_c1011 {
        let inner_value = self.read_u8::<false>(3, 2, 2).unwrap();
        TokenField_thv_c1011(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c1010(&self) -> TokenField_thv_c1010 {
        let inner_value = self.read_u8::<false>(3, 2, 1).unwrap();
        TokenField_thv_c1010(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0911(&self) -> TokenField_thv_c0911 {
        let inner_value = self.read_u8::<false>(3, 1, 3).unwrap();
        TokenField_thv_c0911(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0909(&self) -> TokenField_thv_c0909 {
        let inner_value = self.read_u8::<false>(3, 1, 1).unwrap();
        TokenField_thv_c0909(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0811(&self) -> TokenField_thv_c0811 {
        let inner_value = self.read_u8::<false>(3, 0, 4).unwrap();
        TokenField_thv_c0811(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0809(&self) -> TokenField_thv_c0809 {
        let inner_value = self.read_u8::<false>(3, 0, 2).unwrap();
        TokenField_thv_c0809(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0808(&self) -> TokenField_thv_c0808 {
        let inner_value = self.read_u8::<false>(3, 0, 1).unwrap();
        TokenField_thv_c0808(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0711(&self) -> TokenField_thv_c0711 {
        let inner_value = self.read_u16::<false>(2, 7, 5).unwrap();
        TokenField_thv_c0711(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0709(&self) -> TokenField_thv_c0709 {
        let inner_value = self.read_u16::<false>(2, 7, 3).unwrap();
        TokenField_thv_c0709(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0708(&self) -> TokenField_thv_c0708 {
        let inner_value = self.read_u16::<false>(2, 7, 2).unwrap();
        TokenField_thv_c0708(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0707(&self) -> TokenField_thv_c0707 {
        let inner_value = self.read_u8::<false>(2, 7, 1).unwrap();
        TokenField_thv_c0707(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0611(&self) -> TokenField_thv_c0611 {
        let inner_value = self.read_u16::<false>(2, 6, 6).unwrap();
        TokenField_thv_c0611(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0607(&self) -> TokenField_thv_c0607 {
        let inner_value = self.read_u8::<false>(2, 6, 2).unwrap();
        TokenField_thv_c0607(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0606(&self) -> TokenField_thv_c0606 {
        let inner_value = self.read_u8::<false>(2, 6, 1).unwrap();
        TokenField_thv_c0606(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0508(&self) -> TokenField_thv_c0508 {
        let inner_value = self.read_u16::<false>(2, 5, 4).unwrap();
        TokenField_thv_c0508(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0507(&self) -> TokenField_thv_c0507 {
        let inner_value = self.read_u8::<false>(2, 5, 3).unwrap();
        TokenField_thv_c0507(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0506(&self) -> TokenField_thv_c0506 {
        let inner_value = self.read_u8::<false>(2, 5, 2).unwrap();
        TokenField_thv_c0506(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0505(&self) -> TokenField_thv_c0505 {
        let inner_value = self.read_u8::<false>(2, 5, 1).unwrap();
        TokenField_thv_c0505(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0431(&self) -> TokenField_thv_c0431 {
        let inner_value = self.read_u32::<false>(0, 4, 28).unwrap();
        TokenField_thv_c0431(u32::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0427(&self) -> TokenField_thv_c0427 {
        let inner_value = self.read_u32::<false>(0, 4, 24).unwrap();
        TokenField_thv_c0427(u32::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0411(&self) -> TokenField_thv_c0411 {
        let inner_value = self.read_u16::<false>(2, 4, 8).unwrap();
        TokenField_thv_c0411(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0409(&self) -> TokenField_thv_c0409 {
        let inner_value = self.read_u16::<false>(2, 4, 6).unwrap();
        TokenField_thv_c0409(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0407(&self) -> TokenField_thv_c0407 {
        let inner_value = self.read_u8::<false>(2, 4, 4).unwrap();
        TokenField_thv_c0407(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0406(&self) -> TokenField_thv_c0406 {
        let inner_value = self.read_u8::<false>(2, 4, 3).unwrap();
        TokenField_thv_c0406(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0405(&self) -> TokenField_thv_c0405 {
        let inner_value = self.read_u8::<false>(2, 4, 2).unwrap();
        TokenField_thv_c0405(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0404(&self) -> TokenField_thv_c0404 {
        let inner_value = self.read_u8::<false>(2, 4, 1).unwrap();
        TokenField_thv_c0404(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0303(&self) -> TokenField_thv_c0303 {
        let inner_value = self.read_u8::<false>(2, 3, 1).unwrap();
        TokenField_thv_c0303(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0215(&self) -> TokenField_thv_c0215 {
        let inner_value = self.read_u16::<false>(2, 2, 14).unwrap();
        TokenField_thv_c0215(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0202(&self) -> TokenField_thv_c0202 {
        let inner_value = self.read_u8::<false>(2, 2, 1).unwrap();
        TokenField_thv_c0202(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0101(&self) -> TokenField_thv_c0101 {
        let inner_value = self.read_u8::<false>(2, 1, 1).unwrap();
        TokenField_thv_c0101(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0104(&self) -> TokenField_thv_c0104 {
        let inner_value = self.read_u8::<false>(2, 1, 4).unwrap();
        TokenField_thv_c0104(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0031(&self) -> TokenField_thv_c0031 {
        let inner_value = self.read_u32::<false>(0, 0, 32).unwrap();
        TokenField_thv_c0031(u32::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0027(&self) -> TokenField_thv_c0027 {
        let inner_value = self.read_u32::<false>(0, 0, 28).unwrap();
        TokenField_thv_c0027(u32::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0015(&self) -> TokenField_thv_c0015 {
        let inner_value = self.read_u16::<false>(2, 0, 16).unwrap();
        TokenField_thv_c0015(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0011(&self) -> TokenField_thv_c0011 {
        let inner_value = self.read_u16::<false>(2, 0, 12).unwrap();
        TokenField_thv_c0011(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0010(&self) -> TokenField_thv_c0010 {
        let inner_value = self.read_u16::<false>(2, 0, 11).unwrap();
        TokenField_thv_c0010(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0008(&self) -> TokenField_thv_c0008 {
        let inner_value = self.read_u16::<false>(2, 0, 9).unwrap();
        TokenField_thv_c0008(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0007(&self) -> TokenField_thv_c0007 {
        let inner_value = self.read_u8::<false>(2, 0, 8).unwrap();
        TokenField_thv_c0007(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0006(&self) -> TokenField_thv_c0006 {
        let inner_value = self.read_u8::<false>(2, 0, 7).unwrap();
        TokenField_thv_c0006(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0004(&self) -> TokenField_thv_c0004 {
        let inner_value = self.read_u8::<false>(2, 0, 5).unwrap();
        TokenField_thv_c0004(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0003(&self) -> TokenField_thv_c0003 {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_c0003(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0001(&self) -> TokenField_thv_c0001 {
        let inner_value = self.read_u8::<false>(2, 0, 2).unwrap();
        TokenField_thv_c0001(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_c0000(&self) -> TokenField_thv_c0000 {
        let inner_value = self.read_u8::<false>(2, 0, 1).unwrap();
        TokenField_thv_c0000(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldthv_option(&self) -> TokenField_thv_option {
        let inner_value = self.read_u8::<false>(2, 0, 4).unwrap();
        TokenField_thv_option(u8::try_from(inner_value).unwrap())
    }
}
#[derive(Clone, Copy, Debug)]
pub enum Register {
    r0,
    r1,
    r2,
    r3,
    r4,
    r5,
    r6,
    r7,
    r8,
    r9,
    r10,
    r11,
    r12,
    sp,
    lr,
    pc,
    NG,
    ZR,
    CY,
    OV,
    tmpNG,
    tmpZR,
    tmpCY,
    tmpOV,
    shift_carry,
    TB,
    Q,
    GE1,
    GE2,
    GE3,
    GE4,
    cpsr,
    spsr,
    mult_addr,
    r14_svc,
    r13_svc,
    spsr_svc,
    mult_dat8,
    mult_dat16,
    fpsr,
    ISAModeSwitch,
    fp0,
    fp1,
    fp2,
    fp3,
    fp4,
    fp5,
    fp6,
    fp7,
    cr0,
    cr1,
    cr2,
    cr3,
    cr4,
    cr5,
    cr6,
    cr7,
    cr8,
    cr9,
    cr10,
    cr11,
    cr12,
    cr13,
    cr14,
    cr15,
    contextreg,
}
impl core::fmt::Display for Register {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::r0 => write!(f, "r0"),
            Self::r1 => write!(f, "r1"),
            Self::r2 => write!(f, "r2"),
            Self::r3 => write!(f, "r3"),
            Self::r4 => write!(f, "r4"),
            Self::r5 => write!(f, "r5"),
            Self::r6 => write!(f, "r6"),
            Self::r7 => write!(f, "r7"),
            Self::r8 => write!(f, "r8"),
            Self::r9 => write!(f, "r9"),
            Self::r10 => write!(f, "r10"),
            Self::r11 => write!(f, "r11"),
            Self::r12 => write!(f, "r12"),
            Self::sp => write!(f, "sp"),
            Self::lr => write!(f, "lr"),
            Self::pc => write!(f, "pc"),
            Self::NG => write!(f, "NG"),
            Self::ZR => write!(f, "ZR"),
            Self::CY => write!(f, "CY"),
            Self::OV => write!(f, "OV"),
            Self::tmpNG => write!(f, "tmpNG"),
            Self::tmpZR => write!(f, "tmpZR"),
            Self::tmpCY => write!(f, "tmpCY"),
            Self::tmpOV => write!(f, "tmpOV"),
            Self::shift_carry => write!(f, "shift_carry"),
            Self::TB => write!(f, "TB"),
            Self::Q => write!(f, "Q"),
            Self::GE1 => write!(f, "GE1"),
            Self::GE2 => write!(f, "GE2"),
            Self::GE3 => write!(f, "GE3"),
            Self::GE4 => write!(f, "GE4"),
            Self::cpsr => write!(f, "cpsr"),
            Self::spsr => write!(f, "spsr"),
            Self::mult_addr => write!(f, "mult_addr"),
            Self::r14_svc => write!(f, "r14_svc"),
            Self::r13_svc => write!(f, "r13_svc"),
            Self::spsr_svc => write!(f, "spsr_svc"),
            Self::mult_dat8 => write!(f, "mult_dat8"),
            Self::mult_dat16 => write!(f, "mult_dat16"),
            Self::fpsr => write!(f, "fpsr"),
            Self::ISAModeSwitch => write!(f, "ISAModeSwitch"),
            Self::fp0 => write!(f, "fp0"),
            Self::fp1 => write!(f, "fp1"),
            Self::fp2 => write!(f, "fp2"),
            Self::fp3 => write!(f, "fp3"),
            Self::fp4 => write!(f, "fp4"),
            Self::fp5 => write!(f, "fp5"),
            Self::fp6 => write!(f, "fp6"),
            Self::fp7 => write!(f, "fp7"),
            Self::cr0 => write!(f, "cr0"),
            Self::cr1 => write!(f, "cr1"),
            Self::cr2 => write!(f, "cr2"),
            Self::cr3 => write!(f, "cr3"),
            Self::cr4 => write!(f, "cr4"),
            Self::cr5 => write!(f, "cr5"),
            Self::cr6 => write!(f, "cr6"),
            Self::cr7 => write!(f, "cr7"),
            Self::cr8 => write!(f, "cr8"),
            Self::cr9 => write!(f, "cr9"),
            Self::cr10 => write!(f, "cr10"),
            Self::cr11 => write!(f, "cr11"),
            Self::cr12 => write!(f, "cr12"),
            Self::cr13 => write!(f, "cr13"),
            Self::cr14 => write!(f, "cr14"),
            Self::cr15 => write!(f, "cr15"),
            Self::contextreg => write!(f, "contextreg"),
        }
    }
}
#[derive(Clone, Copy, Debug)]
pub enum DisplayElement {
    Literal(&'static str),
    Register(Register),
    Number(bool, i128),
}
impl core::fmt::Display for DisplayElement {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Literal(lit) => lit.fmt(f),
            Self::Register(reg) => reg.fmt(f),
            Self::Number(hex, value) => match (*hex, value.is_negative()) {
                (true, true) => write!(f, "-0x{:x}", value.abs()),
                (true, false) => write!(f, "0x{:x}", value),
                (false, _) => value.fmt(f),
            },
        }
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2269:1, end:2269:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar0 {
    Addr24: TableAddr24,
}
impl bl_instructionVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("bl"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldL24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldimmed24().disassembly() != 16777215i128 {
            return None;
        }
        let Addr24 = if let Some((len, table)) = TableAddr24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3494:1, end:3494:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar1 {}
impl mov_instructionVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_LRset(
            Some(inst_next),
            context.register().read_LRset_disassembly().unwrap(),
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mov"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::lr),
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::pc),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc0031().disassembly() != 3785416719i128 {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_LRset_disassembly(tmp)
            .unwrap();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3563:1, end:3563:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar2 {
    rm: Tablerm,
}
impl mov_instructionVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_LRset(
            Some(inst_next),
            context.register().read_LRset_disassembly().unwrap(),
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("mov"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::lr),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS20().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRm2().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldsftimm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0406().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 14i128 {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_LRset_disassembly(tmp)
            .unwrap();
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2276:1, end:2276:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar3 {
    COND: TableCOND,
    Addr24: TableAddr24,
}
impl bl_instructionVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bl")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldL24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldimmed24().disassembly() != 16777215i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Addr24 = if let Some((len, table)) = TableAddr24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3569:1, end:3569:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar4 {
    COND: TableCOND,
}
impl mov_instructionVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::lr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS20().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldsftimm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0406().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRm().disassembly() != 14i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4160:1, end:4160:2))"]
#[derive(Clone, Debug)]
struct msr_instructionVar5 {
    COND: TableCOND,
    cpsrmask: Tablecpsrmask,
    rm: Tablerm,
}
impl msr_instructionVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("msr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cpsrmask.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 18i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let cpsrmask = if let Some((len, table)) = Tablecpsrmask::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, cpsrmask, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4182:1, end:4182:2))"]
#[derive(Clone, Debug)]
struct msr_instructionVar6 {
    COND: TableCOND,
    spsrmask: Tablespsrmask,
    rm: Tablerm,
}
impl msr_instructionVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("msr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.spsrmask.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 22i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let spsrmask = if let Some((len, table)) = Tablespsrmask::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, spsrmask, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4152:1, end:4152:2))"]
#[derive(Clone, Debug)]
struct msr_instructionVar7 {
    COND: TableCOND,
    cpsrmask: Tablecpsrmask,
    shift1: Tableshift1,
}
impl msr_instructionVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("msr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cpsrmask.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 50i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let cpsrmask = if let Some((len, table)) = Tablecpsrmask::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                cpsrmask,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4174:1, end:4174:2))"]
#[derive(Clone, Debug)]
struct msr_instructionVar8 {
    COND: TableCOND,
    spsrmask: Tablespsrmask,
    shift1: Tableshift1,
}
impl msr_instructionVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("msr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.spsrmask.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 54i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let spsrmask = if let Some((len, table)) = Tablespsrmask::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                spsrmask,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2492:1, end:2492:2))"]
#[derive(Clone, Debug)]
struct cmn_instructionVar9 {
    COND: TableCOND,
    rn: Tablern,
    shift1: Tableshift1,
}
impl cmn_instructionVar9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmn")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 23i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2503:1, end:2503:2))"]
#[derive(Clone, Debug)]
struct cmn_instructionVar10 {
    COND: TableCOND,
    rn: Tablern,
    shift2: Tableshift2,
}
impl cmn_instructionVar10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmn")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 23i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2514:1, end:2514:2))"]
#[derive(Clone, Debug)]
struct cmn_instructionVar11 {
    COND: TableCOND,
    rn: Tablern,
    shift3: Tableshift3,
}
impl cmn_instructionVar11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmn")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 23i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2525:1, end:2525:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar12 {
    COND: TableCOND,
    rn: Tablern,
    shift1: Tableshift1,
}
impl cmp_instructionVar12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmp")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 21i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2536:1, end:2536:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar13 {
    COND: TableCOND,
    rn: Tablern,
    shift2: Tableshift2,
}
impl cmp_instructionVar13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmp")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 21i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2547:1, end:2547:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar14 {
    COND: TableCOND,
    rn: Tablern,
    shift3: Tableshift3,
}
impl cmp_instructionVar14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmp")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 21i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5624:1, end:5624:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar15 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl sub_instructionVar15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldRn().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldI25().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldimmed().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldrotate().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3512:1, end:3512:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar16 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift1: Tableshift1,
}
impl mov_instructionVar16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3525:1, end:3525:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar17 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift2: Tableshift2,
}
impl mov_instructionVar17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3537:1, end:3537:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar18 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift2: Tableshift2,
}
impl mov_instructionVar18 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_LRset_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3550:1, end:3550:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar19 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift3: Tableshift3,
}
impl mov_instructionVar19 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4189:1, end:4189:2))"]
#[derive(Clone, Debug)]
struct mul_instructionVar20 {
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
    rn: Tablern,
    rs: Tablers,
    rm: Tablerm,
}
impl mul_instructionVar20 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mul")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.rs.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 9i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) = TableSBIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_ZN,
                rn,
                rs,
                rm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4229:1, end:4229:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar21 {
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
    shift1: Tableshift1,
}
impl mvn_instructionVar21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mvn")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) = TableSBIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_ZN,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4240:1, end:4240:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar22 {
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
    shift2: Tableshift2,
}
impl mvn_instructionVar22 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mvn")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) = TableSBIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_ZN,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4251:1, end:4251:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar23 {
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
    shift3: Tableshift3,
}
impl mvn_instructionVar23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mvn")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) = TableSBIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_ZN,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5758:1, end:5758:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar24 {
    COND: TableCOND,
    rn: Tablern,
    shift1: Tableshift1,
}
impl teq_instructionVar24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("teq")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 19i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5769:1, end:5769:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar25 {
    COND: TableCOND,
    rn: Tablern,
    shift2: Tableshift2,
}
impl teq_instructionVar25 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("teq")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 19i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5780:1, end:5780:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar26 {
    COND: TableCOND,
    rn: Tablern,
    shift3: Tableshift3,
}
impl teq_instructionVar26 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("teq")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 19i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5791:1, end:5791:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar27 {
    COND: TableCOND,
    rn: Tablern,
    shift1: Tableshift1,
}
impl teq_instructionVar27 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("teq")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("p"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 19i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5802:1, end:5802:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar28 {
    COND: TableCOND,
    rn: Tablern,
    shift2: Tableshift2,
}
impl teq_instructionVar28 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("teq")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("p"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 19i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5813:1, end:5813:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar29 {
    COND: TableCOND,
    rn: Tablern,
    shift3: Tableshift3,
}
impl teq_instructionVar29 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("teq")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("p"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 19i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5825:1, end:5825:2))"]
#[derive(Clone, Debug)]
struct tst_instructionVar30 {
    COND: TableCOND,
    rn: Tablern,
    shift1: Tableshift1,
}
impl tst_instructionVar30 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("tst")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 17i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5836:1, end:5836:2))"]
#[derive(Clone, Debug)]
struct tst_instructionVar31 {
    COND: TableCOND,
    rn: Tablern,
    shift2: Tableshift2,
}
impl tst_instructionVar31 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("tst")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 17i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5847:1, end:5847:2))"]
#[derive(Clone, Debug)]
struct tst_instructionVar32 {
    COND: TableCOND,
    rn: Tablern,
    shift3: Tableshift3,
}
impl tst_instructionVar32 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("tst")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2024().disassembly() != 17i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1945:1, end:1945:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar33 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl adc_instructionVar33 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1958:1, end:1958:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar34 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl adc_instructionVar34 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1971:1, end:1971:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar35 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl adc_instructionVar35 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2048:1, end:2048:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar36 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl add_instructionVar36 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2061:1, end:2061:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar37 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl add_instructionVar37 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2074:1, end:2074:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar38 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl add_instructionVar38 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2120:1, end:2120:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar39 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl and_instructionVar39 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("and")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2133:1, end:2133:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar40 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl and_instructionVar40 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("and")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2146:1, end:2146:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar41 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl and_instructionVar41 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("and")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2229:1, end:2229:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar42 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl bic_instructionVar42 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bic")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2242:1, end:2242:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar43 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl bic_instructionVar43 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bic")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2255:1, end:2255:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar44 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl bic_instructionVar44 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bic")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2644:1, end:2644:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar45 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl eor_instructionVar45 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eor")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2657:1, end:2657:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar46 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl eor_instructionVar46 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eor")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2670:1, end:2670:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar47 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl eor_instructionVar47 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eor")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2936:1, end:2936:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar48 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar48 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2945:1, end:2945:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar49 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar49 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2954:1, end:2954:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar50 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar50 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2963:1, end:2963:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar51 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar51 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2972:1, end:2972:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar52 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar52 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2981:1, end:2981:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar53 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar53 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2990:1, end:2990:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar54 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar54 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2999:1, end:2999:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar55 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar55 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3008:1, end:3008:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar56 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar56 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3017:1, end:3017:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar57 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar57 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3026:1, end:3026:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar58 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar58 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3035:1, end:3035:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar59 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar59 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3044:1, end:3044:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar60 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar60 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3053:1, end:3053:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar61 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar61 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3062:1, end:3062:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar62 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar62 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3071:1, end:3071:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar63 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar63 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3080:1, end:3080:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar64 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar64 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3089:1, end:3089:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar65 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar65 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3098:1, end:3098:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar66 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar66 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3107:1, end:3107:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar67 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar67 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3116:1, end:3116:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar68 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar68 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3125:1, end:3125:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar69 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar69 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3134:1, end:3134:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar70 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar70 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3143:1, end:3143:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar71 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar71 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3152:1, end:3152:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar72 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar72 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3161:1, end:3161:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar73 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar73 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3170:1, end:3170:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar74 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar74 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3179:1, end:3179:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar75 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar75 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3188:1, end:3188:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar76 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar76 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3197:1, end:3197:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar77 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar77 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3206:1, end:3206:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar78 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar78 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3215:1, end:3215:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar79 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar79 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3224:1, end:3224:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar80 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar80 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3233:1, end:3233:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar81 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar81 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3242:1, end:3242:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar82 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar82 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3251:1, end:3251:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar83 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar83 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3260:1, end:3260:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar84 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar84 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3269:1, end:3269:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar85 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar85 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3278:1, end:3278:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar86 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar86 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3287:1, end:3287:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar87 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar87 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3296:1, end:3296:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar88 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar88 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3607:1, end:3607:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar89 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar89 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3617:1, end:3617:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar90 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar90 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3627:1, end:3627:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar91 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar91 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3637:1, end:3637:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar92 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar92 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3647:1, end:3647:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar93 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar93 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3657:1, end:3657:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar94 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar94 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3667:1, end:3667:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar95 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar95 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3677:1, end:3677:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar96 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar96 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3687:1, end:3687:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar97 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar97 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3697:1, end:3697:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar98 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar98 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3707:1, end:3707:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar99 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar99 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3717:1, end:3717:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar100 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar100 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3727:1, end:3727:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar101 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar101 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3737:1, end:3737:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar102 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar102 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3747:1, end:3747:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar103 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar103 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3757:1, end:3757:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar104 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar104 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3767:1, end:3767:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar105 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar105 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3777:1, end:3777:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar106 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar106 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3787:1, end:3787:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar107 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar107 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3797:1, end:3797:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar108 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar108 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3807:1, end:3807:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar109 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar109 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3817:1, end:3817:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar110 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar110 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3827:1, end:3827:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar111 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar111 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3837:1, end:3837:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar112 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar112 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3847:1, end:3847:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar113 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar113 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3857:1, end:3857:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar114 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar114 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3867:1, end:3867:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar115 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar115 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3877:1, end:3877:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar116 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar116 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3887:1, end:3887:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar117 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar117 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3897:1, end:3897:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar118 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar118 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3907:1, end:3907:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar119 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar119 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3917:1, end:3917:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar120 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar120 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3927:1, end:3927:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar121 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar121 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3937:1, end:3937:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar122 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar122 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3947:1, end:3947:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar123 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar123 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 8i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3957:1, end:3957:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar124 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar124 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3967:1, end:3967:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar125 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar125 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3977:1, end:3977:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar126 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar126 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3987:1, end:3987:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar127 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar127 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3997:1, end:3997:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar128 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar128 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4007:1, end:4007:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar129 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar129 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc2().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4139:1, end:4139:2))"]
#[derive(Clone, Debug)]
struct mrs_instructionVar130 {
    Rd: TokenField_Rd,
    COND: TableCOND,
}
impl mrs_instructionVar130 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrs")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::cpsr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 16i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldoffset_12().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4146:1, end:4146:2))"]
#[derive(Clone, Debug)]
struct mrs_instructionVar131 {
    Rd: TokenField_Rd,
    COND: TableCOND,
}
impl mrs_instructionVar131 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrs")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::spsr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 20i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldoffset_12().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3305:1, end:3305:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar132 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar132 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3315:1, end:3315:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar133 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar133 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3325:1, end:3325:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar134 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar134 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3335:1, end:3335:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar135 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar135 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3345:1, end:3345:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar136 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar136 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3355:1, end:3355:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar137 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar137 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3365:1, end:3365:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar138 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar138 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3375:1, end:3375:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar139 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar139 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4017:1, end:4017:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar140 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar140 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4028:1, end:4028:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar141 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar141 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4039:1, end:4039:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar142 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar142 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4050:1, end:4050:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar143 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar143 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4061:1, end:4061:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar144 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar144 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4072:1, end:4072:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar145 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar145 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4083:1, end:4083:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar146 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar146 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4094:1, end:4094:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar147 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar147 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldCRm().disassembly() != 10i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3385:1, end:3385:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar148 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar148 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CRm = token_parser.TokenFieldCRm();
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5687:1, end:5687:2))"]
#[derive(Clone, Debug)]
struct swp_instructionVar149 {
    Rd: TokenField_Rd,
    Rm: TokenField_Rm,
    Rn: TokenField_Rn,
    COND: TableCOND,
}
impl swp_instructionVar149 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("swp")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.Rm.display(),
            DisplayElement::Literal(","),
            self.Rn.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 16i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 9i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn = token_parser.TokenFieldRn();
        let Rd = token_parser.TokenFieldRd();
        let Rm = token_parser.TokenFieldRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rn, Rd, Rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5695:1, end:5695:2))"]
#[derive(Clone, Debug)]
struct swpb_instructionVar150 {
    Rd: TokenField_Rd,
    Rm: TokenField_Rm,
    Rn: TokenField_Rn,
    COND: TableCOND,
}
impl swpb_instructionVar150 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("swpb")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.Rm.display(),
            DisplayElement::Literal(","),
            self.Rn.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2027().disassembly() != 20i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 9i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn = token_parser.TokenFieldRn();
        let Rd = token_parser.TokenFieldRd();
        let Rm = token_parser.TokenFieldRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rn, Rd, Rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3457:1, end:3457:2))"]
#[derive(Clone, Debug)]
struct mla_instructionVar151 {
    Rn: TokenField_Rn,
    Rm: TokenField_Rm,
    Rs: TokenField_Rs,
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
}
impl mla_instructionVar151 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mla")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            self.Rn.display(),
            DisplayElement::Literal(","),
            self.Rm.display(),
            DisplayElement::Literal(","),
            self.Rs.display(),
            DisplayElement::Literal(","),
            self.Rd.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 9i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) = TableSBIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn = token_parser.TokenFieldRn();
        let Rd = token_parser.TokenFieldRd();
        let Rs = token_parser.TokenFieldRs();
        let Rm = token_parser.TokenFieldRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_ZN,
                Rn,
                Rd,
                Rs,
                Rm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4105:1, end:4105:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar152 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar152 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldopc1().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CRm = token_parser.TokenFieldCRm();
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3474:1, end:3474:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar153 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift1: Tableshift1,
}
impl mov_instructionVar153 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3484:1, end:3484:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar154 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift2: Tableshift2,
}
impl mov_instructionVar154 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3502:1, end:3502:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar155 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift3: Tableshift3,
}
impl mov_instructionVar155 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 13i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4199:1, end:4199:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar156 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift1: Tableshift1,
}
impl mvn_instructionVar156 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mvn")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4209:1, end:4209:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar157 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift2: Tableshift2,
}
impl mvn_instructionVar157 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mvn")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4219:1, end:4219:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar158 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift3: Tableshift3,
}
impl mvn_instructionVar158 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mvn")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4302:1, end:4302:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar159 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl orr_instructionVar159 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("orr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4315:1, end:4315:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar160 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl orr_instructionVar160 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("orr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4328:1, end:4328:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar161 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl orr_instructionVar161 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("orr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4644:1, end:4644:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar162 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl rsb_instructionVar162 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsb")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4657:1, end:4657:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar163 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl rsb_instructionVar163 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsb")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4670:1, end:4670:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar164 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl rsb_instructionVar164 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsb")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4716:1, end:4716:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar165 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl rsc_instructionVar165 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4729:1, end:4729:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar166 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl rsc_instructionVar166 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4742:1, end:4742:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar167 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl rsc_instructionVar167 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4848:1, end:4848:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar168 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl sbc_instructionVar168 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sbc")];
        display.extend_from_slice(&extend);
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4861:1, end:4861:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar169 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl sbc_instructionVar169 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sbc")];
        display.extend_from_slice(&extend);
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4874:1, end:4874:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar170 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl sbc_instructionVar170 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sbc")];
        display.extend_from_slice(&extend);
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5073:1, end:5073:2))"]
#[derive(Clone, Debug)]
struct smlal_instructionVar171 {
    RdLo: TokenField_RdLo,
    RdHi: TokenField_RdHi,
    smRn: TokenField_smRn,
    smRm: TokenField_smRm,
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
}
impl smlal_instructionVar171 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smlal")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            self.RdLo.display(),
            DisplayElement::Literal(","),
            self.RdHi.display(),
            DisplayElement::Literal(","),
            self.smRn.display(),
            DisplayElement::Literal(","),
            self.smRm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 9i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) = TableSBIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RdLo = token_parser.TokenFieldRdLo();
        let RdHi = token_parser.TokenFieldRdHi();
        let smRn = token_parser.TokenFieldsmRn();
        let smRm = token_parser.TokenFieldsmRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_ZN,
                RdLo,
                RdHi,
                smRn,
                smRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5294:1, end:5294:2))"]
#[derive(Clone, Debug)]
struct smull_instructionVar172 {
    RdLo: TokenField_RdLo,
    RdHi: TokenField_RdHi,
    smRn: TokenField_smRn,
    smRm: TokenField_smRm,
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
}
impl smull_instructionVar172 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smull")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            self.RdLo.display(),
            DisplayElement::Literal(","),
            self.RdHi.display(),
            DisplayElement::Literal(","),
            self.smRn.display(),
            DisplayElement::Literal(","),
            self.smRm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 9i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) = TableSBIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RdHi = token_parser.TokenFieldRdHi();
        let RdLo = token_parser.TokenFieldRdLo();
        let smRn = token_parser.TokenFieldsmRn();
        let smRm = token_parser.TokenFieldsmRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_ZN,
                RdHi,
                RdLo,
                smRn,
                smRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5609:1, end:5609:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar173 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl sub_instructionVar173 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5638:1, end:5638:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar174 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl sub_instructionVar174 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5653:1, end:5653:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar175 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl sub_instructionVar175 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:6080:1, end:6080:2))"]
#[derive(Clone, Debug)]
struct umlal_instructionVar176 {
    Rd: TokenField_Rd,
    Rn: TokenField_Rn,
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
    rs: Tablers,
    rm: Tablerm,
}
impl umlal_instructionVar176 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("umlal")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.Rn.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.rs.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 9i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) = TableSBIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn = token_parser.TokenFieldRn();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_ZN,
                rs,
                rm,
                Rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:6095:1, end:6095:2))"]
#[derive(Clone, Debug)]
struct umull_instructionVar177 {
    Rd: TokenField_Rd,
    Rn: TokenField_Rn,
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
    rs: Tablers,
    rm: Tablerm,
}
impl umull_instructionVar177 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("umull")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_ZN.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.Rn.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.rs.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 9i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) = TableSBIT_ZN::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rn = token_parser.TokenFieldRn();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_ZN,
                rs,
                rm,
                Rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1912:1, end:1912:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar178 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl adc_instructionVar178 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1923:1, end:1923:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar179 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl adc_instructionVar179 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1934:1, end:1934:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar180 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl adc_instructionVar180 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2006:1, end:2006:2))"]
#[derive(Clone, Debug)]
struct adr_instructionVar181 {
    COND: TableCOND,
    ArmPCRelImmed12: TableArmPCRelImmed12,
}
impl adr_instructionVar181 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ArmPCRelImmed12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldRn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c74 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldc2024().disassembly() == 8i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldc2024().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c74(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let ArmPCRelImmed12 = if let Some((len, table)) =
            TableArmPCRelImmed12::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                ArmPCRelImmed12,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2000:1, end:2000:2))"]
#[derive(Clone, Debug)]
struct adr_instructionVar182 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    ArmPCRelImmed12: TableArmPCRelImmed12,
}
impl adr_instructionVar182 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ArmPCRelImmed12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldRn().disassembly() != 15i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c73 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldc2024().disassembly() == 8i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldc2024().disassembly() == 4i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c73(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let ArmPCRelImmed12 = if let Some((len, table)) =
            TableArmPCRelImmed12::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                ArmPCRelImmed12,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2015:1, end:2015:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar183 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl add_instructionVar183 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2026:1, end:2026:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar184 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl add_instructionVar184 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2037:1, end:2037:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar185 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl add_instructionVar185 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2087:1, end:2087:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar186 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl and_instructionVar186 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("and")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2098:1, end:2098:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar187 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl and_instructionVar187 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("and")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2109:1, end:2109:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar188 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl and_instructionVar188 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("and")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2161:1, end:2161:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar189 {
    Addr24: TableAddr24,
}
impl b_instructionVar189 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("b"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldL24().disassembly() != 0i128 {
            return None;
        }
        let Addr24 = if let Some((len, table)) = TableAddr24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2284:1, end:2284:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar190 {
    Addr24: TableAddr24,
}
impl bl_instructionVar190 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("bl"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldcond().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldL24().disassembly() != 1i128 {
            return None;
        }
        let Addr24 = if let Some((len, table)) = TableAddr24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3395:1, end:3395:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar191 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar191 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CRm = token_parser.TokenFieldCRm();
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        let opc1 = token_parser.TokenFieldopc1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4116:1, end:4116:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar192 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar192 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldcpn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldCRn().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) = TablemcrOperands::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CRm = token_parser.TokenFieldCRm();
        let opc2 = token_parser.TokenFieldopc2();
        let Rd = token_parser.TokenFieldRd();
        let opc1 = token_parser.TokenFieldopc1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3407:1, end:3407:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar193 {
    cpn: TokenField_cpn,
    opc1: TokenField_opc1,
    Rd: TokenField_Rd,
    CRn: TokenField_CRn,
    CRm: TokenField_CRm,
    opc2: TokenField_opc2,
    COND: TableCOND,
}
impl mcr_instructionVar193 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 12usize] = [
            DisplayElement::Literal(" "),
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.opc1.display(),
            DisplayElement::Literal(","),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.CRn.display(),
            DisplayElement::Literal(","),
            self.CRm.display(),
            DisplayElement::Literal(","),
            self.opc2.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc1 = token_parser.TokenFieldopc1();
        let CRn = token_parser.TokenFieldCRn();
        let Rd = token_parser.TokenFieldRd();
        let cpn = token_parser.TokenFieldcpn();
        let opc2 = token_parser.TokenFieldopc2();
        let CRm = token_parser.TokenFieldCRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                opc1,
                CRn,
                Rd,
                cpn,
                opc2,
                CRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4129:1, end:4129:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar194 {
    cpn: TokenField_cpn,
    opc1: TokenField_opc1,
    Rd: TokenField_Rd,
    CRn: TokenField_CRn,
    CRm: TokenField_CRm,
    opc2: TokenField_opc2,
    COND: TableCOND,
}
impl mrc_instructionVar194 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 12usize] = [
            DisplayElement::Literal(" "),
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.opc1.display(),
            DisplayElement::Literal(","),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.CRn.display(),
            DisplayElement::Literal(","),
            self.CRm.display(),
            DisplayElement::Literal(","),
            self.opc2.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc2020().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opc1 = token_parser.TokenFieldopc1();
        let CRn = token_parser.TokenFieldCRn();
        let Rd = token_parser.TokenFieldRd();
        let cpn = token_parser.TokenFieldcpn();
        let opc2 = token_parser.TokenFieldopc2();
        let CRm = token_parser.TokenFieldCRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                opc1,
                CRn,
                Rd,
                cpn,
                opc2,
                CRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2464:1, end:2464:2))"]
#[derive(Clone, Debug)]
struct cdp_instructionVar195 {
    cpn: TokenField_cpn,
    opcode1: TokenField_opcode1,
    CRd: TokenField_CRd,
    CRn: TokenField_CRn,
    CRm: TokenField_CRm,
    opcode2: TokenField_opcode2,
    COND: TableCOND,
}
impl cdp_instructionVar195 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cdp")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 12usize] = [
            DisplayElement::Literal(" "),
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.opcode1.display(),
            DisplayElement::Literal(","),
            self.CRd.display(),
            DisplayElement::Literal(","),
            self.CRn.display(),
            DisplayElement::Literal(","),
            self.CRm.display(),
            DisplayElement::Literal(","),
            self.opcode2.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let opcode1 = token_parser.TokenFieldopcode1();
        let CRn = token_parser.TokenFieldCRn();
        let CRd = token_parser.TokenFieldCRd();
        let cpn = token_parser.TokenFieldcpn();
        let opcode2 = token_parser.TokenFieldopcode2();
        let CRm = token_parser.TokenFieldCRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                opcode1,
                CRn,
                CRd,
                cpn,
                opcode2,
                CRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2166:1, end:2166:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar196 {
    cc: Tablecc,
    Addr24: TableAddr24,
}
impl b_instructionVar196 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.cc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldL24().disassembly() != 0i128 {
            return None;
        }
        let cc = if let Some((len, table)) =
            Tablecc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Addr24 = if let Some((len, table)) = TableAddr24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cc, Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2196:1, end:2196:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar197 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl bic_instructionVar197 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bic")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2207:1, end:2207:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar198 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl bic_instructionVar198 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bic")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2218:1, end:2218:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar199 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl bic_instructionVar199 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bic")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 14i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2290:1, end:2290:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar200 {
    COND: TableCOND,
    Addr24: TableAddr24,
}
impl bl_instructionVar200 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bl")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_CALLoverride_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldL24().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Addr24 = if let Some((len, table)) = TableAddr24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2298:1, end:2298:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar201 {
    COND: TableCOND,
    Addr24: TableAddr24,
}
impl bl_instructionVar201 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bl")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_CALLoverride_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldL24().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Addr24 = if let Some((len, table)) = TableAddr24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2611:1, end:2611:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar202 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl eor_instructionVar202 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eor")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2622:1, end:2622:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar203 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl eor_instructionVar203 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eor")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2633:1, end:2633:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar204 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl eor_instructionVar204 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eor")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2710:1, end:2710:2))"]
#[derive(Clone, Debug)]
struct ldc_instructionVar205 {
    cpn: TokenField_cpn,
    CRd: TokenField_CRd,
    COND: TableCOND,
    addrmode5: Tableaddrmode5,
}
impl ldc_instructionVar205 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.CRd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldN22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addrmode5 = if let Some((len, table)) = Tableaddrmode5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let cpn = token_parser.TokenFieldcpn();
        let CRd = token_parser.TokenFieldCRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2718:1, end:2718:2))"]
#[derive(Clone, Debug)]
struct ldcl_instructionVar206 {
    cpn: TokenField_cpn,
    CRd: TokenField_CRd,
    COND: TableCOND,
    addrmode5: Tableaddrmode5,
}
impl ldcl_instructionVar206 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldcl")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.CRd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldN22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addrmode5 = if let Some((len, table)) = Tableaddrmode5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let cpn = token_parser.TokenFieldcpn();
        let CRd = token_parser.TokenFieldCRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2726:1, end:2726:2))"]
#[derive(Clone, Debug)]
struct ldm_instructionVar207 {
    COND: TableCOND,
    mdir: Tablemdir,
    reglist: Tablereglist,
}
impl ldm_instructionVar207 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldm")];
        display.extend_from_slice(&extend);
        self.mdir.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.reglist.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1515().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mdir = if let Some((len, table)) =
            Tablemdir::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let reglist = if let Some((len, table)) = Tablereglist::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                mdir,
                reglist,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2732:1, end:2732:2))"]
#[derive(Clone, Debug)]
struct ldm_instructionVar208 {
    COND: TableCOND,
    mdir: Tablemdir,
    reglist: Tablereglist,
}
impl ldm_instructionVar208 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldm")];
        display.extend_from_slice(&extend);
        self.mdir.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.reglist.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1515().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mdir = if let Some((len, table)) =
            Tablemdir::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let reglist = if let Some((len, table)) = Tablereglist::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                mdir,
                reglist,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2771:1, end:2771:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar209 {
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldr_instructionVar209 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_LRset(
            Some(inst_next),
            context.register().read_LRset_disassembly().unwrap(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_LRset_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        let tmp = 0i128;
        context_instance
            .register_mut()
            .write_LRset_disassembly(tmp)
            .unwrap();
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c124 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c124 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c124(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c124(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, addrmode2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2793:1, end:2793:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar210 {
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldr_instructionVar210 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c114 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c114 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c114(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c114(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, addrmode2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2759:1, end:2759:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar211 {
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldr_instructionVar211 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_LRset(
            Some(inst_next),
            context.register().read_LRset_disassembly().unwrap(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_LRset_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        let tmp = 0i128;
        context_instance
            .register_mut()
            .write_LRset_disassembly(tmp)
            .unwrap();
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c116 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c116 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c116(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c116(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, addrmode2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2784:1, end:2784:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar212 {
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldr_instructionVar212 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldRd().disassembly() != 15i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c106 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c106 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c106(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c106(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, addrmode2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2809:1, end:2809:2))"]
#[derive(Clone, Debug)]
struct ldrbt_instructionVar213 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldrbt_instructionVar213 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrbt")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c107 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c107 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c107(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c107(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2913:1, end:2913:2))"]
#[derive(Clone, Debug)]
struct ldrt_instructionVar214 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldrt_instructionVar214 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrt")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c106 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c106 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c106(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c106(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5423:1, end:5423:2))"]
#[derive(Clone, Debug)]
struct stc_instructionVar215 {
    cpn: TokenField_cpn,
    CRd: TokenField_CRd,
    COND: TableCOND,
    addrmode5: Tableaddrmode5,
}
impl stc_instructionVar215 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("stc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.CRd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldN22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addrmode5 = if let Some((len, table)) = Tableaddrmode5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let cpn = token_parser.TokenFieldcpn();
        let CRd = token_parser.TokenFieldCRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5431:1, end:5431:2))"]
#[derive(Clone, Debug)]
struct stcl_instructionVar216 {
    cpn: TokenField_cpn,
    CRd: TokenField_CRd,
    COND: TableCOND,
    addrmode5: Tableaddrmode5,
}
impl stcl_instructionVar216 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("stcl")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.CRd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldN22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addrmode5 = if let Some((len, table)) = Tableaddrmode5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let cpn = token_parser.TokenFieldcpn();
        let CRd = token_parser.TokenFieldCRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5469:1, end:5469:2))"]
#[derive(Clone, Debug)]
struct strbt_instructionVar217 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl strbt_instructionVar217 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("strbt")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c107 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c107 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c107(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c107(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5569:1, end:5569:2))"]
#[derive(Clone, Debug)]
struct strt_instructionVar218 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl strt_instructionVar218 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("strt")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c106 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c106 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c106(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c106(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2751:1, end:2751:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar219 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldr_instructionVar219 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c90 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c90(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c90(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2802:1, end:2802:2))"]
#[derive(Clone, Debug)]
struct ldrb_instructionVar220 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldrb_instructionVar220 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrb")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c90 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c90(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c90(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2861:1, end:2861:2))"]
#[derive(Clone, Debug)]
struct ldrh_instructionVar221 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode3: Tableaddrmode3,
}
impl ldrh_instructionVar221 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrh")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 11i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addrmode3 = if let Some((len, table)) = Tableaddrmode3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2878:1, end:2878:2))"]
#[derive(Clone, Debug)]
struct ldrsb_instructionVar222 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode3: Tableaddrmode3,
}
impl ldrsb_instructionVar222 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrsb")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 13i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addrmode3 = if let Some((len, table)) = Tableaddrmode3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2895:1, end:2895:2))"]
#[derive(Clone, Debug)]
struct ldrsh_instructionVar223 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode3: Tableaddrmode3,
}
impl ldrsh_instructionVar223 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrsh")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 15i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addrmode3 = if let Some((len, table)) = Tableaddrmode3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4269:1, end:4269:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar224 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl orr_instructionVar224 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("orr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4280:1, end:4280:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar225 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl orr_instructionVar225 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("orr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4291:1, end:4291:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar226 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl orr_instructionVar226 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("orr")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 12i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4611:1, end:4611:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar227 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl rsb_instructionVar227 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsb")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4622:1, end:4622:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar228 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl rsb_instructionVar228 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsb")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4633:1, end:4633:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar229 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl rsb_instructionVar229 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsb")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4683:1, end:4683:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar230 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl rsc_instructionVar230 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4694:1, end:4694:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar231 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl rsc_instructionVar231 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4705:1, end:4705:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar232 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl rsc_instructionVar232 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsc")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4815:1, end:4815:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar233 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl sbc_instructionVar233 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sbc")];
        display.extend_from_slice(&extend);
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4826:1, end:4826:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar234 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl sbc_instructionVar234 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sbc")];
        display.extend_from_slice(&extend);
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4837:1, end:4837:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar235 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl sbc_instructionVar235 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sbc")];
        display.extend_from_slice(&extend);
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 6i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5477:1, end:5477:2))"]
#[derive(Clone, Debug)]
struct strh_instructionVar236 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode3: Tableaddrmode3,
}
impl strh_instructionVar236 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("strh")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 11i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addrmode3 = if let Some((len, table)) = Tableaddrmode3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5439:1, end:5439:2))"]
#[derive(Clone, Debug)]
struct stm_instructionVar237 {
    COND: TableCOND,
    mdir: Tablemdir,
    reglist: Tablereglist,
}
impl stm_instructionVar237 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("stm")];
        display.extend_from_slice(&extend);
        self.mdir.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.reglist.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2527().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mdir = if let Some((len, table)) =
            Tablemdir::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let reglist = if let Some((len, table)) = Tablereglist::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                mdir,
                reglist,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5454:1, end:5454:2))"]
#[derive(Clone, Debug)]
struct str_instructionVar238 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl str_instructionVar238 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("str")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c90 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c90(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c90(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5461:1, end:5461:2))"]
#[derive(Clone, Debug)]
struct strb_instructionVar239 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl strb_instructionVar239 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("strb")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldB22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldI25().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let mut sub_pattern_c90 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 4u64 as u32;
                        let token_parser = <TokenParser<4usize>>::new(tokens)?;
                        if token_parser.TokenFieldI25().disassembly() != 1i128 {
                            return None;
                        }
                        if token_parser.TokenFieldc0404().disassembly() != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c90(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c90(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) = Tableaddrmode2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5576:1, end:5576:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar240 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl sub_instructionVar240 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) = Tableshift1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5587:1, end:5587:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar241 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl sub_instructionVar241 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) = Tableshift2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5598:1, end:5598:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar242 {
    Rd: TokenField_Rd,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl sub_instructionVar242 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SBIT_CZNO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.Rd.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2124().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc2627().disassembly() != 0i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) = TableSBIT_CZNO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) = Tableshift3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5668:1, end:5668:2))"]
#[derive(Clone, Debug)]
struct swi_instructionVar243 {
    immed24: TokenField_immed24,
    COND: TableCOND,
}
impl swi_instructionVar243 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("swi")];
        display.extend_from_slice(&extend);
        self.COND.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(" "), self.immed24.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_ARMcond_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldc2427().disassembly() != 15i128 {
            return None;
        }
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immed24 = token_parser.TokenFieldimmed24();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, immed24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1526:1, end:1526:2))"]
#[derive(Clone, Debug)]
struct instructionVar244 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar244 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_ARMcondCk_disassembly(tmp)
            .unwrap();
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_ARMcond_disassembly(tmp)
            .unwrap();
        let mut sub_pattern_c43 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldbit31().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldbit30().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldbit29().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldbit28().disassembly() == 0i128 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c43(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1527:1, end:1527:2))"]
#[derive(Clone, Debug)]
struct instructionVar245 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar245 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_ARMcondCk_disassembly(tmp)
            .unwrap();
        let tmp = 0i128;
        context_instance
            .register_mut()
            .write_ARMcond_disassembly(tmp)
            .unwrap();
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[derive(Clone, Debug)]
enum Tableinstruction {
    Var0(bl_instructionVar0),
    Var1(mov_instructionVar1),
    Var2(mov_instructionVar2),
    Var3(bl_instructionVar3),
    Var4(mov_instructionVar4),
    Var5(msr_instructionVar5),
    Var6(msr_instructionVar6),
    Var7(msr_instructionVar7),
    Var8(msr_instructionVar8),
    Var9(cmn_instructionVar9),
    Var10(cmn_instructionVar10),
    Var11(cmn_instructionVar11),
    Var12(cmp_instructionVar12),
    Var13(cmp_instructionVar13),
    Var14(cmp_instructionVar14),
    Var15(sub_instructionVar15),
    Var16(mov_instructionVar16),
    Var17(mov_instructionVar17),
    Var18(mov_instructionVar18),
    Var19(mov_instructionVar19),
    Var20(mul_instructionVar20),
    Var21(mvn_instructionVar21),
    Var22(mvn_instructionVar22),
    Var23(mvn_instructionVar23),
    Var24(teq_instructionVar24),
    Var25(teq_instructionVar25),
    Var26(teq_instructionVar26),
    Var27(teq_instructionVar27),
    Var28(teq_instructionVar28),
    Var29(teq_instructionVar29),
    Var30(tst_instructionVar30),
    Var31(tst_instructionVar31),
    Var32(tst_instructionVar32),
    Var33(adc_instructionVar33),
    Var34(adc_instructionVar34),
    Var35(adc_instructionVar35),
    Var36(add_instructionVar36),
    Var37(add_instructionVar37),
    Var38(add_instructionVar38),
    Var39(and_instructionVar39),
    Var40(and_instructionVar40),
    Var41(and_instructionVar41),
    Var42(bic_instructionVar42),
    Var43(bic_instructionVar43),
    Var44(bic_instructionVar44),
    Var45(eor_instructionVar45),
    Var46(eor_instructionVar46),
    Var47(eor_instructionVar47),
    Var48(mcr_instructionVar48),
    Var49(mcr_instructionVar49),
    Var50(mcr_instructionVar50),
    Var51(mcr_instructionVar51),
    Var52(mcr_instructionVar52),
    Var53(mcr_instructionVar53),
    Var54(mcr_instructionVar54),
    Var55(mcr_instructionVar55),
    Var56(mcr_instructionVar56),
    Var57(mcr_instructionVar57),
    Var58(mcr_instructionVar58),
    Var59(mcr_instructionVar59),
    Var60(mcr_instructionVar60),
    Var61(mcr_instructionVar61),
    Var62(mcr_instructionVar62),
    Var63(mcr_instructionVar63),
    Var64(mcr_instructionVar64),
    Var65(mcr_instructionVar65),
    Var66(mcr_instructionVar66),
    Var67(mcr_instructionVar67),
    Var68(mcr_instructionVar68),
    Var69(mcr_instructionVar69),
    Var70(mcr_instructionVar70),
    Var71(mcr_instructionVar71),
    Var72(mcr_instructionVar72),
    Var73(mcr_instructionVar73),
    Var74(mcr_instructionVar74),
    Var75(mcr_instructionVar75),
    Var76(mcr_instructionVar76),
    Var77(mcr_instructionVar77),
    Var78(mcr_instructionVar78),
    Var79(mcr_instructionVar79),
    Var80(mcr_instructionVar80),
    Var81(mcr_instructionVar81),
    Var82(mcr_instructionVar82),
    Var83(mcr_instructionVar83),
    Var84(mcr_instructionVar84),
    Var85(mcr_instructionVar85),
    Var86(mcr_instructionVar86),
    Var87(mcr_instructionVar87),
    Var88(mcr_instructionVar88),
    Var89(mrc_instructionVar89),
    Var90(mrc_instructionVar90),
    Var91(mrc_instructionVar91),
    Var92(mrc_instructionVar92),
    Var93(mrc_instructionVar93),
    Var94(mrc_instructionVar94),
    Var95(mrc_instructionVar95),
    Var96(mrc_instructionVar96),
    Var97(mrc_instructionVar97),
    Var98(mrc_instructionVar98),
    Var99(mrc_instructionVar99),
    Var100(mrc_instructionVar100),
    Var101(mrc_instructionVar101),
    Var102(mrc_instructionVar102),
    Var103(mrc_instructionVar103),
    Var104(mrc_instructionVar104),
    Var105(mrc_instructionVar105),
    Var106(mrc_instructionVar106),
    Var107(mrc_instructionVar107),
    Var108(mrc_instructionVar108),
    Var109(mrc_instructionVar109),
    Var110(mrc_instructionVar110),
    Var111(mrc_instructionVar111),
    Var112(mrc_instructionVar112),
    Var113(mrc_instructionVar113),
    Var114(mrc_instructionVar114),
    Var115(mrc_instructionVar115),
    Var116(mrc_instructionVar116),
    Var117(mrc_instructionVar117),
    Var118(mrc_instructionVar118),
    Var119(mrc_instructionVar119),
    Var120(mrc_instructionVar120),
    Var121(mrc_instructionVar121),
    Var122(mrc_instructionVar122),
    Var123(mrc_instructionVar123),
    Var124(mrc_instructionVar124),
    Var125(mrc_instructionVar125),
    Var126(mrc_instructionVar126),
    Var127(mrc_instructionVar127),
    Var128(mrc_instructionVar128),
    Var129(mrc_instructionVar129),
    Var130(mrs_instructionVar130),
    Var131(mrs_instructionVar131),
    Var132(mcr_instructionVar132),
    Var133(mcr_instructionVar133),
    Var134(mcr_instructionVar134),
    Var135(mcr_instructionVar135),
    Var136(mcr_instructionVar136),
    Var137(mcr_instructionVar137),
    Var138(mcr_instructionVar138),
    Var139(mcr_instructionVar139),
    Var140(mrc_instructionVar140),
    Var141(mrc_instructionVar141),
    Var142(mrc_instructionVar142),
    Var143(mrc_instructionVar143),
    Var144(mrc_instructionVar144),
    Var145(mrc_instructionVar145),
    Var146(mrc_instructionVar146),
    Var147(mrc_instructionVar147),
    Var148(mcr_instructionVar148),
    Var149(swp_instructionVar149),
    Var150(swpb_instructionVar150),
    Var151(mla_instructionVar151),
    Var152(mrc_instructionVar152),
    Var153(mov_instructionVar153),
    Var154(mov_instructionVar154),
    Var155(mov_instructionVar155),
    Var156(mvn_instructionVar156),
    Var157(mvn_instructionVar157),
    Var158(mvn_instructionVar158),
    Var159(orr_instructionVar159),
    Var160(orr_instructionVar160),
    Var161(orr_instructionVar161),
    Var162(rsb_instructionVar162),
    Var163(rsb_instructionVar163),
    Var164(rsb_instructionVar164),
    Var165(rsc_instructionVar165),
    Var166(rsc_instructionVar166),
    Var167(rsc_instructionVar167),
    Var168(sbc_instructionVar168),
    Var169(sbc_instructionVar169),
    Var170(sbc_instructionVar170),
    Var171(smlal_instructionVar171),
    Var172(smull_instructionVar172),
    Var173(sub_instructionVar173),
    Var174(sub_instructionVar174),
    Var175(sub_instructionVar175),
    Var176(umlal_instructionVar176),
    Var177(umull_instructionVar177),
    Var178(adc_instructionVar178),
    Var179(adc_instructionVar179),
    Var180(adc_instructionVar180),
    Var181(adr_instructionVar181),
    Var182(adr_instructionVar182),
    Var183(add_instructionVar183),
    Var184(add_instructionVar184),
    Var185(add_instructionVar185),
    Var186(and_instructionVar186),
    Var187(and_instructionVar187),
    Var188(and_instructionVar188),
    Var189(b_instructionVar189),
    Var190(bl_instructionVar190),
    Var191(mcr_instructionVar191),
    Var192(mrc_instructionVar192),
    Var193(mcr_instructionVar193),
    Var194(mrc_instructionVar194),
    Var195(cdp_instructionVar195),
    Var196(b_instructionVar196),
    Var197(bic_instructionVar197),
    Var198(bic_instructionVar198),
    Var199(bic_instructionVar199),
    Var200(bl_instructionVar200),
    Var201(bl_instructionVar201),
    Var202(eor_instructionVar202),
    Var203(eor_instructionVar203),
    Var204(eor_instructionVar204),
    Var205(ldc_instructionVar205),
    Var206(ldcl_instructionVar206),
    Var207(ldm_instructionVar207),
    Var208(ldm_instructionVar208),
    Var209(ldr_instructionVar209),
    Var210(ldr_instructionVar210),
    Var211(ldr_instructionVar211),
    Var212(ldr_instructionVar212),
    Var213(ldrbt_instructionVar213),
    Var214(ldrt_instructionVar214),
    Var215(stc_instructionVar215),
    Var216(stcl_instructionVar216),
    Var217(strbt_instructionVar217),
    Var218(strt_instructionVar218),
    Var219(ldr_instructionVar219),
    Var220(ldrb_instructionVar220),
    Var221(ldrh_instructionVar221),
    Var222(ldrsb_instructionVar222),
    Var223(ldrsh_instructionVar223),
    Var224(orr_instructionVar224),
    Var225(orr_instructionVar225),
    Var226(orr_instructionVar226),
    Var227(rsb_instructionVar227),
    Var228(rsb_instructionVar228),
    Var229(rsb_instructionVar229),
    Var230(rsc_instructionVar230),
    Var231(rsc_instructionVar231),
    Var232(rsc_instructionVar232),
    Var233(sbc_instructionVar233),
    Var234(sbc_instructionVar234),
    Var235(sbc_instructionVar235),
    Var236(strh_instructionVar236),
    Var237(stm_instructionVar237),
    Var238(str_instructionVar238),
    Var239(strb_instructionVar239),
    Var240(sub_instructionVar240),
    Var241(sub_instructionVar241),
    Var242(sub_instructionVar242),
    Var243(swi_instructionVar243),
    Var244(instructionVar244),
    Var245(instructionVar245),
}
impl Tableinstruction {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var18(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var19(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var20(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var21(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var22(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var23(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var24(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var25(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var26(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var27(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var28(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var29(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var30(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var31(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var32(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var33(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var34(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var35(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var36(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var37(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var38(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var39(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var40(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var41(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var42(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var43(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var44(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var45(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var46(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var47(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var48(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var49(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var50(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var51(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var52(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var53(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var54(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var55(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var56(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var57(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var58(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var59(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var60(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var61(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var62(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var63(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var64(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var65(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var66(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var67(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var68(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var69(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var70(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var71(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var72(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var73(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var74(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var75(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var76(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var77(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var78(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var79(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var80(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var81(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var82(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var83(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var84(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var85(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var86(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var87(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var88(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var89(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var90(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var91(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var92(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var93(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var94(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var95(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var96(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var97(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var98(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var99(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var100(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var101(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var102(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var103(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var104(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var105(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var106(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var107(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var108(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var109(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var110(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var111(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var112(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var113(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var114(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var115(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var116(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var117(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var118(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var119(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var120(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var121(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var122(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var123(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var124(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var125(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var126(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var127(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var128(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var129(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var130(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var131(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var132(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var133(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var134(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var135(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var136(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var137(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var138(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var139(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var140(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var141(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var142(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var143(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var144(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var145(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var146(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var147(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var148(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var149(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var150(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var151(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var152(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var153(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var154(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var155(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var156(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var157(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var158(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var159(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var160(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var161(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var162(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var163(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var164(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var165(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var166(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var167(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var168(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var169(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var170(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var171(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var172(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var173(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var174(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var175(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var176(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var177(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var178(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var179(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var180(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var181(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var182(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var183(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var184(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var185(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var186(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var187(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var188(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var189(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var190(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var191(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var192(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var193(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var194(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var195(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var196(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var197(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var198(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var199(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var200(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var201(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var202(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var203(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var204(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var205(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var206(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var207(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var208(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var209(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var210(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var211(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var212(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var213(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var214(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var215(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var216(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var217(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var218(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var219(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var220(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var221(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var222(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var223(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var224(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var225(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var226(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var227(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var228(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var229(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var230(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var231(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var232(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var233(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var234(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var235(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var236(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var237(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var238(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var239(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var240(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var241(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var242(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var243(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var244(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var245(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = bl_instructionVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = bl_instructionVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = msr_instructionVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = msr_instructionVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = msr_instructionVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) = msr_instructionVar8::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) = cmn_instructionVar9::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) = cmn_instructionVar10::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) = cmn_instructionVar11::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) = cmp_instructionVar12::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) = cmp_instructionVar13::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) = cmp_instructionVar14::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) = sub_instructionVar15::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar16::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var16(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar17::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var17(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar18::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var18(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar19::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var19(parsed)));
        }
        if let Some((inst_len, parsed)) = mul_instructionVar20::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var20(parsed)));
        }
        if let Some((inst_len, parsed)) = mvn_instructionVar21::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var21(parsed)));
        }
        if let Some((inst_len, parsed)) = mvn_instructionVar22::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var22(parsed)));
        }
        if let Some((inst_len, parsed)) = mvn_instructionVar23::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var23(parsed)));
        }
        if let Some((inst_len, parsed)) = teq_instructionVar24::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var24(parsed)));
        }
        if let Some((inst_len, parsed)) = teq_instructionVar25::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var25(parsed)));
        }
        if let Some((inst_len, parsed)) = teq_instructionVar26::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var26(parsed)));
        }
        if let Some((inst_len, parsed)) = teq_instructionVar27::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var27(parsed)));
        }
        if let Some((inst_len, parsed)) = teq_instructionVar28::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var28(parsed)));
        }
        if let Some((inst_len, parsed)) = teq_instructionVar29::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var29(parsed)));
        }
        if let Some((inst_len, parsed)) = tst_instructionVar30::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var30(parsed)));
        }
        if let Some((inst_len, parsed)) = tst_instructionVar31::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var31(parsed)));
        }
        if let Some((inst_len, parsed)) = tst_instructionVar32::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var32(parsed)));
        }
        if let Some((inst_len, parsed)) = adc_instructionVar33::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var33(parsed)));
        }
        if let Some((inst_len, parsed)) = adc_instructionVar34::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var34(parsed)));
        }
        if let Some((inst_len, parsed)) = adc_instructionVar35::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var35(parsed)));
        }
        if let Some((inst_len, parsed)) = add_instructionVar36::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var36(parsed)));
        }
        if let Some((inst_len, parsed)) = add_instructionVar37::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var37(parsed)));
        }
        if let Some((inst_len, parsed)) = add_instructionVar38::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var38(parsed)));
        }
        if let Some((inst_len, parsed)) = and_instructionVar39::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var39(parsed)));
        }
        if let Some((inst_len, parsed)) = and_instructionVar40::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var40(parsed)));
        }
        if let Some((inst_len, parsed)) = and_instructionVar41::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var41(parsed)));
        }
        if let Some((inst_len, parsed)) = bic_instructionVar42::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var42(parsed)));
        }
        if let Some((inst_len, parsed)) = bic_instructionVar43::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var43(parsed)));
        }
        if let Some((inst_len, parsed)) = bic_instructionVar44::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var44(parsed)));
        }
        if let Some((inst_len, parsed)) = eor_instructionVar45::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var45(parsed)));
        }
        if let Some((inst_len, parsed)) = eor_instructionVar46::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var46(parsed)));
        }
        if let Some((inst_len, parsed)) = eor_instructionVar47::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var47(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar48::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var48(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar49::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var49(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar50::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var50(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar51::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var51(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar52::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var52(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar53::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var53(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar54::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var54(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar55::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var55(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar56::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var56(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar57::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var57(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar58::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var58(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar59::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var59(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar60::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var60(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar61::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var61(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar62::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var62(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar63::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var63(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar64::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var64(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar65::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var65(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar66::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var66(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar67::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var67(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar68::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var68(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar69::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var69(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar70::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var70(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar71::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var71(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar72::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var72(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar73::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var73(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar74::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var74(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar75::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var75(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar76::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var76(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar77::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var77(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar78::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var78(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar79::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var79(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar80::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var80(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar81::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var81(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar82::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var82(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar83::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var83(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar84::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var84(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar85::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var85(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar86::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var86(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar87::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var87(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar88::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var88(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar89::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var89(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar90::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var90(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar91::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var91(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar92::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var92(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar93::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var93(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar94::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var94(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar95::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var95(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar96::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var96(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar97::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var97(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar98::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var98(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar99::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var99(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar100::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var100(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar101::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var101(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar102::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var102(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar103::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var103(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar104::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var104(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar105::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var105(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar106::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var106(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar107::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var107(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar108::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var108(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar109::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var109(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar110::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var110(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar111::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var111(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar112::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var112(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar113::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var113(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar114::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var114(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar115::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var115(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar116::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var116(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar117::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var117(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar118::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var118(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar119::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var119(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar120::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var120(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar121::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var121(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar122::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var122(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar123::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var123(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar124::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var124(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar125::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var125(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar126::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var126(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar127::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var127(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar128::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var128(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar129::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var129(parsed)));
        }
        if let Some((inst_len, parsed)) = mrs_instructionVar130::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var130(parsed)));
        }
        if let Some((inst_len, parsed)) = mrs_instructionVar131::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var131(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar132::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var132(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar133::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var133(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar134::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var134(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar135::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var135(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar136::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var136(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar137::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var137(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar138::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var138(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar139::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var139(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar140::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var140(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar141::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var141(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar142::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var142(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar143::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var143(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar144::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var144(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar145::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var145(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar146::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var146(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar147::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var147(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar148::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var148(parsed)));
        }
        if let Some((inst_len, parsed)) = swp_instructionVar149::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var149(parsed)));
        }
        if let Some((inst_len, parsed)) = swpb_instructionVar150::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var150(parsed)));
        }
        if let Some((inst_len, parsed)) = mla_instructionVar151::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var151(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar152::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var152(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar153::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var153(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar154::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var154(parsed)));
        }
        if let Some((inst_len, parsed)) = mov_instructionVar155::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var155(parsed)));
        }
        if let Some((inst_len, parsed)) = mvn_instructionVar156::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var156(parsed)));
        }
        if let Some((inst_len, parsed)) = mvn_instructionVar157::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var157(parsed)));
        }
        if let Some((inst_len, parsed)) = mvn_instructionVar158::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var158(parsed)));
        }
        if let Some((inst_len, parsed)) = orr_instructionVar159::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var159(parsed)));
        }
        if let Some((inst_len, parsed)) = orr_instructionVar160::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var160(parsed)));
        }
        if let Some((inst_len, parsed)) = orr_instructionVar161::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var161(parsed)));
        }
        if let Some((inst_len, parsed)) = rsb_instructionVar162::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var162(parsed)));
        }
        if let Some((inst_len, parsed)) = rsb_instructionVar163::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var163(parsed)));
        }
        if let Some((inst_len, parsed)) = rsb_instructionVar164::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var164(parsed)));
        }
        if let Some((inst_len, parsed)) = rsc_instructionVar165::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var165(parsed)));
        }
        if let Some((inst_len, parsed)) = rsc_instructionVar166::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var166(parsed)));
        }
        if let Some((inst_len, parsed)) = rsc_instructionVar167::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var167(parsed)));
        }
        if let Some((inst_len, parsed)) = sbc_instructionVar168::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var168(parsed)));
        }
        if let Some((inst_len, parsed)) = sbc_instructionVar169::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var169(parsed)));
        }
        if let Some((inst_len, parsed)) = sbc_instructionVar170::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var170(parsed)));
        }
        if let Some((inst_len, parsed)) = smlal_instructionVar171::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var171(parsed)));
        }
        if let Some((inst_len, parsed)) = smull_instructionVar172::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var172(parsed)));
        }
        if let Some((inst_len, parsed)) = sub_instructionVar173::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var173(parsed)));
        }
        if let Some((inst_len, parsed)) = sub_instructionVar174::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var174(parsed)));
        }
        if let Some((inst_len, parsed)) = sub_instructionVar175::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var175(parsed)));
        }
        if let Some((inst_len, parsed)) = umlal_instructionVar176::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var176(parsed)));
        }
        if let Some((inst_len, parsed)) = umull_instructionVar177::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var177(parsed)));
        }
        if let Some((inst_len, parsed)) = adc_instructionVar178::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var178(parsed)));
        }
        if let Some((inst_len, parsed)) = adc_instructionVar179::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var179(parsed)));
        }
        if let Some((inst_len, parsed)) = adc_instructionVar180::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var180(parsed)));
        }
        if let Some((inst_len, parsed)) = adr_instructionVar181::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var181(parsed)));
        }
        if let Some((inst_len, parsed)) = adr_instructionVar182::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var182(parsed)));
        }
        if let Some((inst_len, parsed)) = add_instructionVar183::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var183(parsed)));
        }
        if let Some((inst_len, parsed)) = add_instructionVar184::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var184(parsed)));
        }
        if let Some((inst_len, parsed)) = add_instructionVar185::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var185(parsed)));
        }
        if let Some((inst_len, parsed)) = and_instructionVar186::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var186(parsed)));
        }
        if let Some((inst_len, parsed)) = and_instructionVar187::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var187(parsed)));
        }
        if let Some((inst_len, parsed)) = and_instructionVar188::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var188(parsed)));
        }
        if let Some((inst_len, parsed)) = b_instructionVar189::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var189(parsed)));
        }
        if let Some((inst_len, parsed)) = bl_instructionVar190::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var190(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar191::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var191(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar192::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var192(parsed)));
        }
        if let Some((inst_len, parsed)) = mcr_instructionVar193::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var193(parsed)));
        }
        if let Some((inst_len, parsed)) = mrc_instructionVar194::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var194(parsed)));
        }
        if let Some((inst_len, parsed)) = cdp_instructionVar195::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var195(parsed)));
        }
        if let Some((inst_len, parsed)) = b_instructionVar196::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var196(parsed)));
        }
        if let Some((inst_len, parsed)) = bic_instructionVar197::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var197(parsed)));
        }
        if let Some((inst_len, parsed)) = bic_instructionVar198::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var198(parsed)));
        }
        if let Some((inst_len, parsed)) = bic_instructionVar199::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var199(parsed)));
        }
        if let Some((inst_len, parsed)) = bl_instructionVar200::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var200(parsed)));
        }
        if let Some((inst_len, parsed)) = bl_instructionVar201::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var201(parsed)));
        }
        if let Some((inst_len, parsed)) = eor_instructionVar202::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var202(parsed)));
        }
        if let Some((inst_len, parsed)) = eor_instructionVar203::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var203(parsed)));
        }
        if let Some((inst_len, parsed)) = eor_instructionVar204::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var204(parsed)));
        }
        if let Some((inst_len, parsed)) = ldc_instructionVar205::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var205(parsed)));
        }
        if let Some((inst_len, parsed)) = ldcl_instructionVar206::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var206(parsed)));
        }
        if let Some((inst_len, parsed)) = ldm_instructionVar207::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var207(parsed)));
        }
        if let Some((inst_len, parsed)) = ldm_instructionVar208::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var208(parsed)));
        }
        if let Some((inst_len, parsed)) = ldr_instructionVar209::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var209(parsed)));
        }
        if let Some((inst_len, parsed)) = ldr_instructionVar210::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var210(parsed)));
        }
        if let Some((inst_len, parsed)) = ldr_instructionVar211::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var211(parsed)));
        }
        if let Some((inst_len, parsed)) = ldr_instructionVar212::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var212(parsed)));
        }
        if let Some((inst_len, parsed)) = ldrbt_instructionVar213::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var213(parsed)));
        }
        if let Some((inst_len, parsed)) = ldrt_instructionVar214::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var214(parsed)));
        }
        if let Some((inst_len, parsed)) = stc_instructionVar215::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var215(parsed)));
        }
        if let Some((inst_len, parsed)) = stcl_instructionVar216::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var216(parsed)));
        }
        if let Some((inst_len, parsed)) = strbt_instructionVar217::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var217(parsed)));
        }
        if let Some((inst_len, parsed)) = strt_instructionVar218::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var218(parsed)));
        }
        if let Some((inst_len, parsed)) = ldr_instructionVar219::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var219(parsed)));
        }
        if let Some((inst_len, parsed)) = ldrb_instructionVar220::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var220(parsed)));
        }
        if let Some((inst_len, parsed)) = ldrh_instructionVar221::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var221(parsed)));
        }
        if let Some((inst_len, parsed)) = ldrsb_instructionVar222::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var222(parsed)));
        }
        if let Some((inst_len, parsed)) = ldrsh_instructionVar223::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var223(parsed)));
        }
        if let Some((inst_len, parsed)) = orr_instructionVar224::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var224(parsed)));
        }
        if let Some((inst_len, parsed)) = orr_instructionVar225::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var225(parsed)));
        }
        if let Some((inst_len, parsed)) = orr_instructionVar226::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var226(parsed)));
        }
        if let Some((inst_len, parsed)) = rsb_instructionVar227::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var227(parsed)));
        }
        if let Some((inst_len, parsed)) = rsb_instructionVar228::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var228(parsed)));
        }
        if let Some((inst_len, parsed)) = rsb_instructionVar229::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var229(parsed)));
        }
        if let Some((inst_len, parsed)) = rsc_instructionVar230::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var230(parsed)));
        }
        if let Some((inst_len, parsed)) = rsc_instructionVar231::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var231(parsed)));
        }
        if let Some((inst_len, parsed)) = rsc_instructionVar232::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var232(parsed)));
        }
        if let Some((inst_len, parsed)) = sbc_instructionVar233::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var233(parsed)));
        }
        if let Some((inst_len, parsed)) = sbc_instructionVar234::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var234(parsed)));
        }
        if let Some((inst_len, parsed)) = sbc_instructionVar235::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var235(parsed)));
        }
        if let Some((inst_len, parsed)) = strh_instructionVar236::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var236(parsed)));
        }
        if let Some((inst_len, parsed)) = stm_instructionVar237::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var237(parsed)));
        }
        if let Some((inst_len, parsed)) = str_instructionVar238::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var238(parsed)));
        }
        if let Some((inst_len, parsed)) = strb_instructionVar239::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var239(parsed)));
        }
        if let Some((inst_len, parsed)) = sub_instructionVar240::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var240(parsed)));
        }
        if let Some((inst_len, parsed)) = sub_instructionVar241::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var241(parsed)));
        }
        if let Some((inst_len, parsed)) = sub_instructionVar242::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var242(parsed)));
        }
        if let Some((inst_len, parsed)) = swi_instructionVar243::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var243(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar244::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var244(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar245::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var245(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:626:1, end:626:3))"]
#[derive(Clone, Debug)]
struct rnVar0 {}
impl rnVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1619().disassembly() != 15i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:627:1, end:627:3))"]
#[derive(Clone, Debug)]
struct rnVar1 {
    Rn: TokenField_Rn,
}
impl rnVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.Rn.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let Rn = token_parser.TokenFieldRn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn }))
    }
}
#[derive(Clone, Debug)]
enum Tablern {
    Var0(rnVar0),
    Var1(rnVar1),
}
impl Tablern {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            rnVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            rnVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:629:1, end:629:3))"]
#[derive(Clone, Debug)]
struct rmVar0 {}
impl rmVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldRm().disassembly() != 15i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:630:1, end:630:3))"]
#[derive(Clone, Debug)]
struct rmVar1 {
    Rm: TokenField_Rm,
}
impl rmVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.Rm.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let Rm = token_parser.TokenFieldRm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rm }))
    }
}
#[derive(Clone, Debug)]
enum Tablerm {
    Var0(rmVar0),
    Var1(rmVar1),
}
impl Tablerm {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            rmVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            rmVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:632:1, end:632:3))"]
#[derive(Clone, Debug)]
struct rsVar0 {}
impl rsVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldRs().disassembly() != 15i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:633:1, end:633:3))"]
#[derive(Clone, Debug)]
struct rsVar1 {
    Rs: TokenField_Rs,
}
impl rsVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.Rs.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let Rs = token_parser.TokenFieldRs();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rs }))
    }
}
#[derive(Clone, Debug)]
enum Tablers {
    Var0(rsVar0),
    Var1(rsVar1),
}
impl Tablers {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            rsVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            rsVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:635:1, end:635:3))"]
#[derive(Clone, Debug)]
struct ccVar0 {}
impl ccVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:636:1, end:636:3))"]
#[derive(Clone, Debug)]
struct ccVar1 {}
impl ccVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ne")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:637:1, end:637:3))"]
#[derive(Clone, Debug)]
struct ccVar2 {}
impl ccVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cs")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:638:1, end:638:3))"]
#[derive(Clone, Debug)]
struct ccVar3 {}
impl ccVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cc")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 3i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:639:1, end:639:3))"]
#[derive(Clone, Debug)]
struct ccVar4 {}
impl ccVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mi")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:640:1, end:640:3))"]
#[derive(Clone, Debug)]
struct ccVar5 {}
impl ccVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("pl")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 5i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:641:1, end:641:3))"]
#[derive(Clone, Debug)]
struct ccVar6 {}
impl ccVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("vs")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 6i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:642:1, end:642:3))"]
#[derive(Clone, Debug)]
struct ccVar7 {}
impl ccVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("vc")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 7i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:643:1, end:643:3))"]
#[derive(Clone, Debug)]
struct ccVar8 {}
impl ccVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("hi")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 8i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:644:1, end:644:3))"]
#[derive(Clone, Debug)]
struct ccVar9 {}
impl ccVar9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ls")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 9i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:645:1, end:645:3))"]
#[derive(Clone, Debug)]
struct ccVar10 {}
impl ccVar10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ge")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 10i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:646:1, end:646:3))"]
#[derive(Clone, Debug)]
struct ccVar11 {}
impl ccVar11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 11i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:647:1, end:647:3))"]
#[derive(Clone, Debug)]
struct ccVar12 {}
impl ccVar12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 12i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:648:1, end:648:3))"]
#[derive(Clone, Debug)]
struct ccVar13 {}
impl ccVar13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("le")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 13i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablecc {
    Var0(ccVar0),
    Var1(ccVar1),
    Var2(ccVar2),
    Var3(ccVar3),
    Var4(ccVar4),
    Var5(ccVar5),
    Var6(ccVar6),
    Var7(ccVar7),
    Var8(ccVar8),
    Var9(ccVar9),
    Var10(ccVar10),
    Var11(ccVar11),
    Var12(ccVar12),
    Var13(ccVar13),
}
impl Tablecc {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ccVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar12::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ccVar13::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:651:1, end:651:5))"]
#[derive(Clone, Debug)]
struct CONDVar0 {}
impl CONDVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcond().disassembly() != 14i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:650:1, end:650:5))"]
#[derive(Clone, Debug)]
struct CONDVar1 {
    cc: Tablecc,
}
impl CONDVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.cc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let cc = if let Some((len, table)) =
            Tablecc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cc }))
    }
}
#[derive(Clone, Debug)]
enum TableCOND {
    Var0(CONDVar0),
    Var1(CONDVar1),
}
impl TableCOND {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            CONDVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CONDVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:659:1, end:659:10))"]
#[derive(Clone, Debug)]
struct SBIT_CZNOVar0 {}
impl SBIT_CZNOVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldS20().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:660:1, end:660:10))"]
#[derive(Clone, Debug)]
struct SBIT_CZNOVar1 {}
impl SBIT_CZNOVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("s")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldS20().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSBIT_CZNO {
    Var0(SBIT_CZNOVar0),
    Var1(SBIT_CZNOVar1),
}
impl TableSBIT_CZNO {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            SBIT_CZNOVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SBIT_CZNOVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:661:1, end:661:8))"]
#[derive(Clone, Debug)]
struct SBIT_ZNVar0 {}
impl SBIT_ZNVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldS20().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:662:1, end:662:8))"]
#[derive(Clone, Debug)]
struct SBIT_ZNVar1 {}
impl SBIT_ZNVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("s")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldS20().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSBIT_ZN {
    Var0(SBIT_ZNVar0),
    Var1(SBIT_ZNVar1),
}
impl TableSBIT_ZN {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            SBIT_ZNVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SBIT_ZNVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:664:1, end:664:7))"]
#[derive(Clone, Debug)]
struct Addr24Var0 {
    addr24: TokenField_addr24,
}
impl Addr24Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_next)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(4i128.wrapping_mul(self.addr24.disassembly()));
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let addr24 = token_parser.TokenFieldaddr24();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr24 }))
    }
}
#[derive(Clone, Debug)]
enum TableAddr24 {
    Var0(Addr24Var0),
}
impl TableAddr24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Addr24Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:690:1, end:690:7))"]
#[derive(Clone, Debug)]
struct shift1Var0 {
    immed: TokenField_immed,
    rotate: TokenField_rotate,
}
impl shift1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_value: i128 = 0;
        calc_value = ((u32::try_from(
            32i128.wrapping_sub(self.rotate.disassembly().wrapping_mul(2i128)),
        )
        .ok()
        .map(|shl| self.immed.disassembly().checked_shl(shl))
        .flatten()
        .unwrap_or(0)
            | u32::try_from(self.rotate.disassembly().wrapping_mul(2i128))
                .ok()
                .map(|shr| self.immed.disassembly().checked_shr(shr))
                .flatten()
                .unwrap_or(0))
            & 4294967295i128);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("#"),
            DisplayElement::Number(true, calc_value),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_value: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 1i128 {
            return None;
        }
        calc_value = ((u32::try_from(
            32i128.wrapping_sub(
                token_parser
                    .TokenFieldrotate()
                    .disassembly()
                    .wrapping_mul(2i128),
            ),
        )
        .ok()
        .map(|shl| {
            token_parser
                .TokenFieldimmed()
                .disassembly()
                .checked_shl(shl)
        })
        .flatten()
        .unwrap_or(0)
            | u32::try_from(
                token_parser
                    .TokenFieldrotate()
                    .disassembly()
                    .wrapping_mul(2i128),
            )
            .ok()
            .map(|shr| {
                token_parser
                    .TokenFieldimmed()
                    .disassembly()
                    .checked_shr(shr)
            })
            .flatten()
            .unwrap_or(0))
            & 4294967295i128);
        let immed = token_parser.TokenFieldimmed();
        let rotate = token_parser.TokenFieldrotate();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed, rotate }))
    }
}
#[derive(Clone, Debug)]
enum Tableshift1 {
    Var0(shift1Var0),
}
impl Tableshift1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            shift1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:803:1, end:803:12))"]
#[derive(Clone, Debug)]
struct mcrOperandsVar0 {
    cpn: TokenField_cpn,
    opc1: TokenField_opc1,
    Rd: TokenField_Rd,
    CRn: TokenField_CRn,
    CRm: TokenField_CRm,
    opc2: TokenField_opc2,
}
impl mcrOperandsVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 11usize] = [
            self.cpn.display(),
            DisplayElement::Literal(","),
            self.opc1.display(),
            DisplayElement::Literal(","),
            self.Rd.display(),
            DisplayElement::Literal(","),
            self.CRn.display(),
            DisplayElement::Literal(","),
            self.CRm.display(),
            DisplayElement::Literal(","),
            self.opc2.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let CRm = token_parser.TokenFieldCRm();
        let opc2 = token_parser.TokenFieldopc2();
        let cpn = token_parser.TokenFieldcpn();
        let CRn = token_parser.TokenFieldCRn();
        let opc1 = token_parser.TokenFieldopc1();
        let Rd = token_parser.TokenFieldRd();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CRm,
                opc2,
                cpn,
                CRn,
                opc1,
                Rd,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TablemcrOperands {
    Var0(mcrOperandsVar0),
}
impl TablemcrOperands {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = mcrOperandsVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:809:1, end:809:7))"]
#[derive(Clone, Debug)]
struct shift2Var0 {
    rm: Tablerm,
}
impl shift2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsftimm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0406().disassembly() != 0i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:819:1, end:819:7))"]
#[derive(Clone, Debug)]
struct shift2Var1 {
    rm: Tablerm,
}
impl shift2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("lsr"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#32"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsftimm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0406().disassembly() != 2i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:829:1, end:829:7))"]
#[derive(Clone, Debug)]
struct shift2Var2 {
    rm: Tablerm,
}
impl shift2Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("asr"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#32"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsftimm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0406().disassembly() != 4i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:839:1, end:839:7))"]
#[derive(Clone, Debug)]
struct shift2Var3 {
    rm: Tablerm,
}
impl shift2Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("rrx"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0411().disassembly() != 6i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:814:1, end:814:7))"]
#[derive(Clone, Debug)]
struct shift2Var4 {
    sftimm: TokenField_sftimm,
    rm: Tablerm,
}
impl shift2Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("lsl"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            self.sftimm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0406().disassembly() != 0i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sftimm = token_parser.TokenFieldsftimm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:824:1, end:824:7))"]
#[derive(Clone, Debug)]
struct shift2Var5 {
    sftimm: TokenField_sftimm,
    rm: Tablerm,
}
impl shift2Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("lsr"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            self.sftimm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0406().disassembly() != 2i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sftimm = token_parser.TokenFieldsftimm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:834:1, end:834:7))"]
#[derive(Clone, Debug)]
struct shift2Var6 {
    sftimm: TokenField_sftimm,
    rm: Tablerm,
}
impl shift2Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("asr"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            self.sftimm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0406().disassembly() != 4i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sftimm = token_parser.TokenFieldsftimm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:844:1, end:844:7))"]
#[derive(Clone, Debug)]
struct shift2Var7 {
    sftimm: TokenField_sftimm,
    rm: Tablerm,
}
impl shift2Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("ror"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            self.sftimm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0406().disassembly() != 6i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sftimm = token_parser.TokenFieldsftimm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[derive(Clone, Debug)]
enum Tableshift2 {
    Var0(shift2Var0),
    Var1(shift2Var1),
    Var2(shift2Var2),
    Var3(shift2Var3),
    Var4(shift2Var4),
    Var5(shift2Var5),
    Var6(shift2Var6),
    Var7(shift2Var7),
}
impl Tableshift2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            shift2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            shift2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            shift2Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            shift2Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            shift2Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            shift2Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            shift2Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            shift2Var7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:853:1, end:853:7))"]
#[derive(Clone, Debug)]
struct shift3Var0 {
    rs: Tablers,
    rm: Tablerm,
}
impl shift3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("lsl"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rs.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 1i128 {
            return None;
        }
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:858:1, end:858:7))"]
#[derive(Clone, Debug)]
struct shift3Var1 {
    rs: Tablers,
    rm: Tablerm,
}
impl shift3Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("lsr"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rs.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 3i128 {
            return None;
        }
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:863:1, end:863:7))"]
#[derive(Clone, Debug)]
struct shift3Var2 {
    rs: Tablers,
    rm: Tablerm,
}
impl shift3Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("asr"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rs.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 5i128 {
            return None;
        }
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:868:1, end:868:7))"]
#[derive(Clone, Debug)]
struct shift3Var3 {
    rs: Tablers,
    rm: Tablerm,
}
impl shift3Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("ror"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rs.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0407().disassembly() != 7i128 {
            return None;
        }
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs, rm }))
    }
}
#[derive(Clone, Debug)]
enum Tableshift3 {
    Var0(shift3Var0),
    Var1(shift3Var1),
    Var2(shift3Var2),
    Var3(shift3Var3),
}
impl Tableshift3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            shift3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            shift3Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            shift3Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            shift3Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:940:1, end:940:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar0 {
    rm: Tablerm,
}
impl addr2shiftVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0411().disassembly() != 0i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:943:1, end:943:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar1 {
    rm: Tablerm,
}
impl addr2shiftVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",lsr"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#32"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsftimm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldshft().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:945:1, end:945:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar2 {
    rm: Tablerm,
}
impl addr2shiftVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",asr"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#32"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsftimm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldshft().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:947:1, end:947:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar3 {
    rm: Tablerm,
}
impl addr2shiftVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",rrx")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsftimm().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldshft().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:941:1, end:941:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar4 {
    sftimm: TokenField_sftimm,
    rm: Tablerm,
}
impl addr2shiftVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(",lsl"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            self.sftimm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldshft().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sftimm = token_parser.TokenFieldsftimm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:942:1, end:942:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar5 {
    sftimm: TokenField_sftimm,
    rm: Tablerm,
}
impl addr2shiftVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(",lsr"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            self.sftimm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldshft().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sftimm = token_parser.TokenFieldsftimm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:944:1, end:944:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar6 {
    sftimm: TokenField_sftimm,
    rm: Tablerm,
}
impl addr2shiftVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(",asr"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            self.sftimm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldshft().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sftimm = token_parser.TokenFieldsftimm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:946:1, end:946:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar7 {
    sftimm: TokenField_sftimm,
    rm: Tablerm,
}
impl addr2shiftVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(",ror"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            self.sftimm.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldshft().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sftimm = token_parser.TokenFieldsftimm();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[derive(Clone, Debug)]
enum Tableaddr2shift {
    Var0(addr2shiftVar0),
    Var1(addr2shiftVar1),
    Var2(addr2shiftVar2),
    Var3(addr2shiftVar3),
    Var4(addr2shiftVar4),
    Var5(addr2shiftVar5),
    Var6(addr2shiftVar6),
    Var7(addr2shiftVar7),
}
impl Tableaddr2shift {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = addr2shiftVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = addr2shiftVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = addr2shiftVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = addr2shiftVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = addr2shiftVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = addr2shiftVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = addr2shiftVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = addr2shiftVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:951:1, end:951:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var0 {
    offset_12: TokenField_offset_12,
}
impl addrmode2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(self.offset_12.disassembly());
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            DisplayElement::Number(true, calc_reloff),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 15i128 {
            return None;
        }
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(token_parser.TokenFieldoffset_12().disassembly());
        let offset_12 = token_parser.TokenFieldoffset_12();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:957:1, end:957:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var1 {
    offset_12: TokenField_offset_12,
}
impl addrmode2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128.wrapping_sub(self.offset_12.disassembly()));
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            DisplayElement::Number(true, calc_reloff),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 15i128 {
            return None;
        }
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128.wrapping_sub(
                token_parser.TokenFieldoffset_12().disassembly(),
            ));
        let offset_12 = token_parser.TokenFieldoffset_12();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:963:1, end:963:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var2 {
    offset_12: TokenField_offset_12,
    rn: Tablern,
}
impl addrmode2Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            self.offset_12.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let offset_12 = token_parser.TokenFieldoffset_12();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:964:1, end:964:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var3 {
    offset_12: TokenField_offset_12,
    rn: Tablern,
}
impl addrmode2Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_noff: i128 = 0;
        calc_noff = (-self.offset_12.disassembly());
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_noff),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_noff: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        calc_noff = (-token_parser.TokenFieldoffset_12().disassembly());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let offset_12 = token_parser.TokenFieldoffset_12();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:965:1, end:965:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var4 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.addr2shift.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) = Tableaddr2shift::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:966:1, end:966:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var5 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",-")];
        display.extend_from_slice(&extend);
        self.addr2shift.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) = Tableaddr2shift::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:968:1, end:968:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var6 {
    offset_12: TokenField_offset_12,
    rn: Tablern,
}
impl addrmode2Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            self.offset_12.display(),
            DisplayElement::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let offset_12 = token_parser.TokenFieldoffset_12();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:969:1, end:969:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var7 {
    offset_12: TokenField_offset_12,
    rn: Tablern,
}
impl addrmode2Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_noff: i128 = 0;
        calc_noff = (-self.offset_12.disassembly());
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_noff),
            DisplayElement::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_noff: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        calc_noff = (-token_parser.TokenFieldoffset_12().disassembly());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let offset_12 = token_parser.TokenFieldoffset_12();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:970:1, end:970:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var8 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.addr2shift.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]!")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) = Tableaddr2shift::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:971:1, end:971:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var9 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",-")];
        display.extend_from_slice(&extend);
        self.addr2shift.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]!")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) = Tableaddr2shift::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:973:1, end:973:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var10 {
    offset_12: TokenField_offset_12,
    rn: Tablern,
}
impl addrmode2Var10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("],#"), self.offset_12.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let offset_12 = token_parser.TokenFieldoffset_12();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:974:1, end:974:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var11 {
    offset_12: TokenField_offset_12,
    rn: Tablern,
}
impl addrmode2Var11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_noff: i128 = 0;
        calc_noff = (-self.offset_12.disassembly());
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("],#"),
            DisplayElement::Number(true, calc_noff),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_noff: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        calc_noff = (-token_parser.TokenFieldoffset_12().disassembly());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let offset_12 = token_parser.TokenFieldoffset_12();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:975:1, end:975:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var12 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("],")];
        display.extend_from_slice(&extend);
        self.addr2shift.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) = Tableaddr2shift::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:976:1, end:976:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var13 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("],-")];
        display.extend_from_slice(&extend);
        self.addr2shift.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) = Tableaddr2shift::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:978:1, end:978:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var14 {
    offset_12: TokenField_offset_12,
    rn: Tablern,
}
impl addrmode2Var14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("],#"), self.offset_12.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let offset_12 = token_parser.TokenFieldoffset_12();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:979:1, end:979:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var15 {
    offset_12: TokenField_offset_12,
    rn: Tablern,
}
impl addrmode2Var15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_noff: i128 = 0;
        calc_noff = (-self.offset_12.disassembly());
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("],#"),
            DisplayElement::Number(true, calc_noff),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_noff: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        calc_noff = (-token_parser.TokenFieldoffset_12().disassembly());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let offset_12 = token_parser.TokenFieldoffset_12();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:980:1, end:980:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var16 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("],")];
        display.extend_from_slice(&extend);
        self.addr2shift.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) = Tableaddr2shift::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:981:1, end:981:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var17 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("],-")];
        display.extend_from_slice(&extend);
        self.addr2shift.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldI25().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) = Tableaddr2shift::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[derive(Clone, Debug)]
enum Tableaddrmode2 {
    Var0(addrmode2Var0),
    Var1(addrmode2Var1),
    Var2(addrmode2Var2),
    Var3(addrmode2Var3),
    Var4(addrmode2Var4),
    Var5(addrmode2Var5),
    Var6(addrmode2Var6),
    Var7(addrmode2Var7),
    Var8(addrmode2Var8),
    Var9(addrmode2Var9),
    Var10(addrmode2Var10),
    Var11(addrmode2Var11),
    Var12(addrmode2Var12),
    Var13(addrmode2Var13),
    Var14(addrmode2Var14),
    Var15(addrmode2Var15),
    Var16(addrmode2Var16),
    Var17(addrmode2Var17),
}
impl Tableaddrmode2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            addrmode2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode2Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode2Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode2Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode2Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode2Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode2Var7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode2Var8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode2Var9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode2Var10::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode2Var11::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode2Var12::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode2Var13::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode2Var14::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode2Var15::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode2Var16::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var16(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode2Var17::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var17(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:990:1, end:990:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var0 {
    immedH: TokenField_immedH,
    immedL: TokenField_immedL,
}
impl addrmode3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                (u32::try_from(4i128)
                    .ok()
                    .map(|shl| self.immedH.disassembly().checked_shl(shl))
                    .flatten()
                    .unwrap_or(0)
                    | self.immedL.disassembly()),
            );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            DisplayElement::Number(true, calc_reloff),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2122().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 15i128 {
            return None;
        }
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                (u32::try_from(4i128)
                    .ok()
                    .map(|shl| {
                        token_parser
                            .TokenFieldimmedH()
                            .disassembly()
                            .checked_shl(shl)
                    })
                    .flatten()
                    .unwrap_or(0)
                    | token_parser.TokenFieldimmedL().disassembly()),
            );
        let immedH = token_parser.TokenFieldimmedH();
        let immedL = token_parser.TokenFieldimmedL();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:996:1, end:996:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var1 {
    immedH: TokenField_immedH,
    immedL: TokenField_immedL,
}
impl addrmode3Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start).unwrap().wrapping_add(
            8i128.wrapping_sub(
                (u32::try_from(4i128)
                    .ok()
                    .map(|shl| self.immedH.disassembly().checked_shl(shl))
                    .flatten()
                    .unwrap_or(0)
                    | self.immedL.disassembly()),
            ),
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            DisplayElement::Number(true, calc_reloff),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2122().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldc1619().disassembly() != 15i128 {
            return None;
        }
        calc_reloff = i128::try_from(inst_start).unwrap().wrapping_add(
            8i128.wrapping_sub(
                (u32::try_from(4i128)
                    .ok()
                    .map(|shl| {
                        token_parser
                            .TokenFieldimmedH()
                            .disassembly()
                            .checked_shl(shl)
                    })
                    .flatten()
                    .unwrap_or(0)
                    | token_parser.TokenFieldimmedL().disassembly()),
            ),
        );
        let immedH = token_parser.TokenFieldimmedH();
        let immedL = token_parser.TokenFieldimmedL();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1014:1, end:1014:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var2 {
    rn: Tablern,
    rm: Tablerm,
}
impl addrmode3Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2122().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1019:1, end:1019:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var3 {
    rn: Tablern,
    rm: Tablerm,
}
impl addrmode3Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",-")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2122().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1036:1, end:1036:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var4 {
    rn: Tablern,
    rm: Tablerm,
}
impl addrmode3Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]!")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2122().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1041:1, end:1041:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var5 {
    rn: Tablern,
    rm: Tablerm,
}
impl addrmode3Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",-")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]!")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2122().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1002:1, end:1002:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var6 {
    immedH: TokenField_immedH,
    immedL: TokenField_immedL,
    rn: Tablern,
}
impl addrmode3Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_off8: i128 = 0;
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .map(|shl| self.immedH.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            | self.immedL.disassembly());
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_off8),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2122().disassembly() != 2i128 {
            return None;
        }
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldimmedH()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldimmedL().disassembly());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immedH = token_parser.TokenFieldimmedH();
        let immedL = token_parser.TokenFieldimmedL();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1008:1, end:1008:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var7 {
    immedH: TokenField_immedH,
    immedL: TokenField_immedL,
    rn: Tablern,
}
impl addrmode3Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .map(|shl| self.immedH.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            | self.immedL.disassembly()));
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_noff8),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2122().disassembly() != 2i128 {
            return None;
        }
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldimmedH()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldimmedL().disassembly()));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immedH = token_parser.TokenFieldimmedH();
        let immedL = token_parser.TokenFieldimmedL();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1024:1, end:1024:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var8 {
    immedH: TokenField_immedH,
    immedL: TokenField_immedL,
    rn: Tablern,
}
impl addrmode3Var8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_off8: i128 = 0;
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .map(|shl| self.immedH.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            | self.immedL.disassembly());
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_off8),
            DisplayElement::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2122().disassembly() != 3i128 {
            return None;
        }
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldimmedH()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldimmedL().disassembly());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immedH = token_parser.TokenFieldimmedH();
        let immedL = token_parser.TokenFieldimmedL();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1030:1, end:1030:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var9 {
    immedH: TokenField_immedH,
    immedL: TokenField_immedL,
    rn: Tablern,
}
impl addrmode3Var9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .map(|shl| self.immedH.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            | self.immedL.disassembly()));
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_noff8),
            DisplayElement::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2122().disassembly() != 3i128 {
            return None;
        }
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldimmedH()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldimmedL().disassembly()));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immedH = token_parser.TokenFieldimmedH();
        let immedL = token_parser.TokenFieldimmedL();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1058:1, end:1058:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var10 {
    rn: Tablern,
    rm: Tablerm,
}
impl addrmode3Var10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("],")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2222().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1063:1, end:1063:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var11 {
    rn: Tablern,
    rm: Tablerm,
}
impl addrmode3Var11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("],-")];
        display.extend_from_slice(&extend);
        self.rm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2222().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc0811().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1046:1, end:1046:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var12 {
    immedH: TokenField_immedH,
    immedL: TokenField_immedL,
    rn: Tablern,
}
impl addrmode3Var12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_off8: i128 = 0;
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .map(|shl| self.immedH.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            | self.immedL.disassembly());
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("],#"),
            DisplayElement::Number(true, calc_off8),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc2222().disassembly() != 1i128 {
            return None;
        }
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldimmedH()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldimmedL().disassembly());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immedH = token_parser.TokenFieldimmedH();
        let immedL = token_parser.TokenFieldimmedL();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1052:1, end:1052:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var13 {
    immedH: TokenField_immedH,
    immedL: TokenField_immedL,
    rn: Tablern,
}
impl addrmode3Var13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .map(|shl| self.immedH.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            | self.immedL.disassembly()));
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("],#"),
            DisplayElement::Number(true, calc_noff8),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldc2222().disassembly() != 1i128 {
            return None;
        }
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldimmedH()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldimmedL().disassembly()));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immedH = token_parser.TokenFieldimmedH();
        let immedL = token_parser.TokenFieldimmedL();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[derive(Clone, Debug)]
enum Tableaddrmode3 {
    Var0(addrmode3Var0),
    Var1(addrmode3Var1),
    Var2(addrmode3Var2),
    Var3(addrmode3Var3),
    Var4(addrmode3Var4),
    Var5(addrmode3Var5),
    Var6(addrmode3Var6),
    Var7(addrmode3Var7),
    Var8(addrmode3Var8),
    Var9(addrmode3Var9),
    Var10(addrmode3Var10),
    Var11(addrmode3Var11),
    Var12(addrmode3Var12),
    Var13(addrmode3Var13),
}
impl Tableaddrmode3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            addrmode3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode3Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode3Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode3Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode3Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode3Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode3Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode3Var7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode3Var8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode3Var9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode3Var10::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode3Var11::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode3Var12::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) = addrmode3Var13::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1074:1, end:1074:7))"]
#[derive(Clone, Debug)]
struct linc15Var0 {}
impl linc15Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0000().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1075:1, end:1075:7))"]
#[derive(Clone, Debug)]
struct linc15Var1 {}
impl linc15Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0000().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc15 {
    Var0(linc15Var0),
    Var1(linc15Var1),
}
impl Tablelinc15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc15Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc15Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1077:1, end:1077:7))"]
#[derive(Clone, Debug)]
struct linc14Var0 {}
impl linc14Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0000().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1076:1, end:1076:7))"]
#[derive(Clone, Debug)]
struct linc14Var1 {
    linc15: Tablelinc15,
}
impl linc14Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc15.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 1i128 {
            return None;
        }
        let linc15 = if let Some((len, table)) = Tablelinc15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1078:1, end:1078:7))"]
#[derive(Clone, Debug)]
struct linc14Var2 {
    linc15: Tablelinc15,
}
impl linc14Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc15.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 0i128 {
            return None;
        }
        let linc15 = if let Some((len, table)) = Tablelinc15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc15 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc14 {
    Var0(linc14Var0),
    Var1(linc14Var1),
    Var2(linc14Var2),
}
impl Tablelinc14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc14Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc14Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc14Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1080:1, end:1080:7))"]
#[derive(Clone, Debug)]
struct linc13Var0 {}
impl linc13Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0001().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1079:1, end:1079:7))"]
#[derive(Clone, Debug)]
struct linc13Var1 {
    linc14: Tablelinc14,
}
impl linc13Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 1i128 {
            return None;
        }
        let linc14 = if let Some((len, table)) = Tablelinc14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1081:1, end:1081:7))"]
#[derive(Clone, Debug)]
struct linc13Var2 {
    linc14: Tablelinc14,
}
impl linc13Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 0i128 {
            return None;
        }
        let linc14 = if let Some((len, table)) = Tablelinc14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc14 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc13 {
    Var0(linc13Var0),
    Var1(linc13Var1),
    Var2(linc13Var2),
}
impl Tablelinc13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc13Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc13Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc13Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1083:1, end:1083:7))"]
#[derive(Clone, Debug)]
struct linc12Var0 {}
impl linc12Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0002().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1082:1, end:1082:7))"]
#[derive(Clone, Debug)]
struct linc12Var1 {
    linc13: Tablelinc13,
}
impl linc12Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc13.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 1i128 {
            return None;
        }
        let linc13 = if let Some((len, table)) = Tablelinc13::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1084:1, end:1084:7))"]
#[derive(Clone, Debug)]
struct linc12Var2 {
    linc13: Tablelinc13,
}
impl linc12Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc13.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 0i128 {
            return None;
        }
        let linc13 = if let Some((len, table)) = Tablelinc13::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc13 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc12 {
    Var0(linc12Var0),
    Var1(linc12Var1),
    Var2(linc12Var2),
}
impl Tablelinc12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc12Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc12Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc12Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1086:1, end:1086:7))"]
#[derive(Clone, Debug)]
struct linc11Var0 {}
impl linc11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0003().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1085:1, end:1085:7))"]
#[derive(Clone, Debug)]
struct linc11Var1 {
    linc12: Tablelinc12,
}
impl linc11Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r4),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        let linc12 = if let Some((len, table)) = Tablelinc12::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1087:1, end:1087:7))"]
#[derive(Clone, Debug)]
struct linc11Var2 {
    linc12: Tablelinc12,
}
impl linc11Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let linc12 = if let Some((len, table)) = Tablelinc12::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc12 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc11 {
    Var0(linc11Var0),
    Var1(linc11Var1),
    Var2(linc11Var2),
}
impl Tablelinc11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc11Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc11Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc11Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1089:1, end:1089:7))"]
#[derive(Clone, Debug)]
struct linc10Var0 {}
impl linc10Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0004().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1088:1, end:1088:7))"]
#[derive(Clone, Debug)]
struct linc10Var1 {
    linc11: Tablelinc11,
}
impl linc10Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 1i128 {
            return None;
        }
        let linc11 = if let Some((len, table)) = Tablelinc11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1090:1, end:1090:7))"]
#[derive(Clone, Debug)]
struct linc10Var2 {
    linc11: Tablelinc11,
}
impl linc10Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 0i128 {
            return None;
        }
        let linc11 = if let Some((len, table)) = Tablelinc11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc11 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc10 {
    Var0(linc10Var0),
    Var1(linc10Var1),
    Var2(linc10Var2),
}
impl Tablelinc10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc10Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc10Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc10Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1092:1, end:1092:6))"]
#[derive(Clone, Debug)]
struct linc9Var0 {}
impl linc9Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0005().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1091:1, end:1091:6))"]
#[derive(Clone, Debug)]
struct linc9Var1 {
    linc10: Tablelinc10,
}
impl linc9Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc10.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r6),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 1i128 {
            return None;
        }
        let linc10 = if let Some((len, table)) = Tablelinc10::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1093:1, end:1093:6))"]
#[derive(Clone, Debug)]
struct linc9Var2 {
    linc10: Tablelinc10,
}
impl linc9Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc10.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 0i128 {
            return None;
        }
        let linc10 = if let Some((len, table)) = Tablelinc10::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc10 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc9 {
    Var0(linc9Var0),
    Var1(linc9Var1),
    Var2(linc9Var2),
}
impl Tablelinc9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc9Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc9Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc9Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1095:1, end:1095:6))"]
#[derive(Clone, Debug)]
struct linc8Var0 {}
impl linc8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0006().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1094:1, end:1094:6))"]
#[derive(Clone, Debug)]
struct linc8Var1 {
    linc9: Tablelinc9,
}
impl linc8Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r7),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 1i128 {
            return None;
        }
        let linc9 = if let Some((len, table)) =
            Tablelinc9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1096:1, end:1096:6))"]
#[derive(Clone, Debug)]
struct linc8Var2 {
    linc9: Tablelinc9,
}
impl linc8Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 0i128 {
            return None;
        }
        let linc9 = if let Some((len, table)) =
            Tablelinc9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc9 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc8 {
    Var0(linc8Var0),
    Var1(linc8Var1),
    Var2(linc8Var2),
}
impl Tablelinc8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc8Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc8Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1098:1, end:1098:6))"]
#[derive(Clone, Debug)]
struct linc7Var0 {}
impl linc7Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0007().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1097:1, end:1097:6))"]
#[derive(Clone, Debug)]
struct linc7Var1 {
    linc8: Tablelinc8,
}
impl linc7Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r8),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 1i128 {
            return None;
        }
        let linc8 = if let Some((len, table)) =
            Tablelinc8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1099:1, end:1099:6))"]
#[derive(Clone, Debug)]
struct linc7Var2 {
    linc8: Tablelinc8,
}
impl linc7Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 0i128 {
            return None;
        }
        let linc8 = if let Some((len, table)) =
            Tablelinc8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc7 {
    Var0(linc7Var0),
    Var1(linc7Var1),
    Var2(linc7Var2),
}
impl Tablelinc7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc7Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc7Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc7Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1101:1, end:1101:6))"]
#[derive(Clone, Debug)]
struct linc6Var0 {}
impl linc6Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0008().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1100:1, end:1100:6))"]
#[derive(Clone, Debug)]
struct linc6Var1 {
    linc7: Tablelinc7,
}
impl linc6Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r9),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 1i128 {
            return None;
        }
        let linc7 = if let Some((len, table)) =
            Tablelinc7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1102:1, end:1102:6))"]
#[derive(Clone, Debug)]
struct linc6Var2 {
    linc7: Tablelinc7,
}
impl linc6Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 0i128 {
            return None;
        }
        let linc7 = if let Some((len, table)) =
            Tablelinc7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc6 {
    Var0(linc6Var0),
    Var1(linc6Var1),
    Var2(linc6Var2),
}
impl Tablelinc6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc6Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc6Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc6Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1104:1, end:1104:6))"]
#[derive(Clone, Debug)]
struct linc5Var0 {}
impl linc5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0009().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1103:1, end:1103:6))"]
#[derive(Clone, Debug)]
struct linc5Var1 {
    linc6: Tablelinc6,
}
impl linc5Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r10),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 1i128 {
            return None;
        }
        let linc6 = if let Some((len, table)) =
            Tablelinc6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1105:1, end:1105:6))"]
#[derive(Clone, Debug)]
struct linc5Var2 {
    linc6: Tablelinc6,
}
impl linc5Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 0i128 {
            return None;
        }
        let linc6 = if let Some((len, table)) =
            Tablelinc6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc6 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc5 {
    Var0(linc5Var0),
    Var1(linc5Var1),
    Var2(linc5Var2),
}
impl Tablelinc5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc5Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc5Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1107:1, end:1107:6))"]
#[derive(Clone, Debug)]
struct linc4Var0 {}
impl linc4Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0010().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1106:1, end:1106:6))"]
#[derive(Clone, Debug)]
struct linc4Var1 {
    linc5: Tablelinc5,
}
impl linc4Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r11),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 1i128 {
            return None;
        }
        let linc5 = if let Some((len, table)) =
            Tablelinc5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1108:1, end:1108:6))"]
#[derive(Clone, Debug)]
struct linc4Var2 {
    linc5: Tablelinc5,
}
impl linc4Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 0i128 {
            return None;
        }
        let linc5 = if let Some((len, table)) =
            Tablelinc5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc5 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc4 {
    Var0(linc4Var0),
    Var1(linc4Var1),
    Var2(linc4Var2),
}
impl Tablelinc4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc4Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc4Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc4Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1110:1, end:1110:6))"]
#[derive(Clone, Debug)]
struct linc3Var0 {}
impl linc3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0011().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1109:1, end:1109:6))"]
#[derive(Clone, Debug)]
struct linc3Var1 {
    linc4: Tablelinc4,
}
impl linc3Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r12),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 1i128 {
            return None;
        }
        let linc4 = if let Some((len, table)) =
            Tablelinc4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1111:1, end:1111:6))"]
#[derive(Clone, Debug)]
struct linc3Var2 {
    linc4: Tablelinc4,
}
impl linc3Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 0i128 {
            return None;
        }
        let linc4 = if let Some((len, table)) =
            Tablelinc4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc4 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc3 {
    Var0(linc3Var0),
    Var1(linc3Var1),
    Var2(linc3Var2),
}
impl Tablelinc3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc3Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc3Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1113:1, end:1113:6))"]
#[derive(Clone, Debug)]
struct linc2Var0 {}
impl linc2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0012().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1112:1, end:1112:6))"]
#[derive(Clone, Debug)]
struct linc2Var1 {
    linc3: Tablelinc3,
}
impl linc2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::sp),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 1i128 {
            return None;
        }
        let linc3 = if let Some((len, table)) =
            Tablelinc3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1114:1, end:1114:6))"]
#[derive(Clone, Debug)]
struct linc2Var2 {
    linc3: Tablelinc3,
}
impl linc2Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 0i128 {
            return None;
        }
        let linc3 = if let Some((len, table)) =
            Tablelinc3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc3 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc2 {
    Var0(linc2Var0),
    Var1(linc2Var1),
    Var2(linc2Var2),
}
impl Tablelinc2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc2Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1116:1, end:1116:6))"]
#[derive(Clone, Debug)]
struct linc1Var0 {}
impl linc1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0013().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1115:1, end:1115:6))"]
#[derive(Clone, Debug)]
struct linc1Var1 {
    linc2: Tablelinc2,
}
impl linc1Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::lr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 1i128 {
            return None;
        }
        let linc2 = if let Some((len, table)) =
            Tablelinc2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1117:1, end:1117:6))"]
#[derive(Clone, Debug)]
struct linc1Var2 {
    linc2: Tablelinc2,
}
impl linc1Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 0i128 {
            return None;
        }
        let linc2 = if let Some((len, table)) =
            Tablelinc2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc1 {
    Var0(linc1Var0),
    Var1(linc1Var1),
    Var2(linc1Var2),
}
impl Tablelinc1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc1Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc1Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1119:1, end:1119:6))"]
#[derive(Clone, Debug)]
struct linc0Var0 {}
impl linc0Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1515().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0014().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1118:1, end:1118:6))"]
#[derive(Clone, Debug)]
struct linc0Var1 {
    linc1: Tablelinc1,
}
impl linc0Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::pc),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1515().disassembly() != 1i128 {
            return None;
        }
        let linc1 = if let Some((len, table)) =
            Tablelinc1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1120:1, end:1120:6))"]
#[derive(Clone, Debug)]
struct linc0Var2 {
    linc1: Tablelinc1,
}
impl linc0Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.linc1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1515().disassembly() != 0i128 {
            return None;
        }
        let linc1 = if let Some((len, table)) =
            Tablelinc1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc0 {
    Var0(linc0Var0),
    Var1(linc0Var1),
    Var2(linc0Var2),
}
impl Tablelinc0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            linc0Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc0Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            linc0Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1121:1, end:1121:11))"]
#[derive(Clone, Debug)]
struct ldlist_incVar0 {
    linc0: Tablelinc0,
}
impl ldlist_incVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        self.linc0.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let linc0 = if let Some((len, table)) =
            Tablelinc0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc0 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldlist_inc {
    Var0(ldlist_incVar0),
}
impl Tableldlist_inc {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = ldlist_incVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1124:1, end:1124:7))"]
#[derive(Clone, Debug)]
struct sinc15Var0 {}
impl sinc15Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0000().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1125:1, end:1125:7))"]
#[derive(Clone, Debug)]
struct sinc15Var1 {}
impl sinc15Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0000().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc15 {
    Var0(sinc15Var0),
    Var1(sinc15Var1),
}
impl Tablesinc15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc15Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc15Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1127:1, end:1127:7))"]
#[derive(Clone, Debug)]
struct sinc14Var0 {}
impl sinc14Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0000().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1126:1, end:1126:7))"]
#[derive(Clone, Debug)]
struct sinc14Var1 {
    sinc15: Tablesinc15,
}
impl sinc14Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc15.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 1i128 {
            return None;
        }
        let sinc15 = if let Some((len, table)) = Tablesinc15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1128:1, end:1128:7))"]
#[derive(Clone, Debug)]
struct sinc14Var2 {
    sinc15: Tablesinc15,
}
impl sinc14Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc15.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 0i128 {
            return None;
        }
        let sinc15 = if let Some((len, table)) = Tablesinc15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc15 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc14 {
    Var0(sinc14Var0),
    Var1(sinc14Var1),
    Var2(sinc14Var2),
}
impl Tablesinc14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc14Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc14Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc14Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1130:1, end:1130:7))"]
#[derive(Clone, Debug)]
struct sinc13Var0 {}
impl sinc13Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0001().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1129:1, end:1129:7))"]
#[derive(Clone, Debug)]
struct sinc13Var1 {
    sinc14: Tablesinc14,
}
impl sinc13Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 1i128 {
            return None;
        }
        let sinc14 = if let Some((len, table)) = Tablesinc14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1131:1, end:1131:7))"]
#[derive(Clone, Debug)]
struct sinc13Var2 {
    sinc14: Tablesinc14,
}
impl sinc13Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 0i128 {
            return None;
        }
        let sinc14 = if let Some((len, table)) = Tablesinc14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc14 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc13 {
    Var0(sinc13Var0),
    Var1(sinc13Var1),
    Var2(sinc13Var2),
}
impl Tablesinc13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc13Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc13Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc13Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1133:1, end:1133:7))"]
#[derive(Clone, Debug)]
struct sinc12Var0 {}
impl sinc12Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0002().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1132:1, end:1132:7))"]
#[derive(Clone, Debug)]
struct sinc12Var1 {
    sinc13: Tablesinc13,
}
impl sinc12Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc13.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 1i128 {
            return None;
        }
        let sinc13 = if let Some((len, table)) = Tablesinc13::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1134:1, end:1134:7))"]
#[derive(Clone, Debug)]
struct sinc12Var2 {
    sinc13: Tablesinc13,
}
impl sinc12Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc13.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 0i128 {
            return None;
        }
        let sinc13 = if let Some((len, table)) = Tablesinc13::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc13 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc12 {
    Var0(sinc12Var0),
    Var1(sinc12Var1),
    Var2(sinc12Var2),
}
impl Tablesinc12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc12Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc12Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc12Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1136:1, end:1136:7))"]
#[derive(Clone, Debug)]
struct sinc11Var0 {}
impl sinc11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0003().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1135:1, end:1135:7))"]
#[derive(Clone, Debug)]
struct sinc11Var1 {
    sinc12: Tablesinc12,
}
impl sinc11Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r4),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        let sinc12 = if let Some((len, table)) = Tablesinc12::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1137:1, end:1137:7))"]
#[derive(Clone, Debug)]
struct sinc11Var2 {
    sinc12: Tablesinc12,
}
impl sinc11Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let sinc12 = if let Some((len, table)) = Tablesinc12::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc12 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc11 {
    Var0(sinc11Var0),
    Var1(sinc11Var1),
    Var2(sinc11Var2),
}
impl Tablesinc11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc11Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc11Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc11Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1139:1, end:1139:7))"]
#[derive(Clone, Debug)]
struct sinc10Var0 {}
impl sinc10Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0004().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1138:1, end:1138:7))"]
#[derive(Clone, Debug)]
struct sinc10Var1 {
    sinc11: Tablesinc11,
}
impl sinc10Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 1i128 {
            return None;
        }
        let sinc11 = if let Some((len, table)) = Tablesinc11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1140:1, end:1140:7))"]
#[derive(Clone, Debug)]
struct sinc10Var2 {
    sinc11: Tablesinc11,
}
impl sinc10Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 0i128 {
            return None;
        }
        let sinc11 = if let Some((len, table)) = Tablesinc11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc11 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc10 {
    Var0(sinc10Var0),
    Var1(sinc10Var1),
    Var2(sinc10Var2),
}
impl Tablesinc10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc10Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc10Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc10Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1142:1, end:1142:6))"]
#[derive(Clone, Debug)]
struct sinc9Var0 {}
impl sinc9Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0005().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1141:1, end:1141:6))"]
#[derive(Clone, Debug)]
struct sinc9Var1 {
    sinc10: Tablesinc10,
}
impl sinc9Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc10.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r6),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 1i128 {
            return None;
        }
        let sinc10 = if let Some((len, table)) = Tablesinc10::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1143:1, end:1143:6))"]
#[derive(Clone, Debug)]
struct sinc9Var2 {
    sinc10: Tablesinc10,
}
impl sinc9Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc10.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 0i128 {
            return None;
        }
        let sinc10 = if let Some((len, table)) = Tablesinc10::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc10 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc9 {
    Var0(sinc9Var0),
    Var1(sinc9Var1),
    Var2(sinc9Var2),
}
impl Tablesinc9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc9Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc9Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc9Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1145:1, end:1145:6))"]
#[derive(Clone, Debug)]
struct sinc8Var0 {}
impl sinc8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0006().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1144:1, end:1144:6))"]
#[derive(Clone, Debug)]
struct sinc8Var1 {
    sinc9: Tablesinc9,
}
impl sinc8Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r7),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 1i128 {
            return None;
        }
        let sinc9 = if let Some((len, table)) =
            Tablesinc9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1146:1, end:1146:6))"]
#[derive(Clone, Debug)]
struct sinc8Var2 {
    sinc9: Tablesinc9,
}
impl sinc8Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 0i128 {
            return None;
        }
        let sinc9 = if let Some((len, table)) =
            Tablesinc9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc9 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc8 {
    Var0(sinc8Var0),
    Var1(sinc8Var1),
    Var2(sinc8Var2),
}
impl Tablesinc8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc8Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc8Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1148:1, end:1148:6))"]
#[derive(Clone, Debug)]
struct sinc7Var0 {}
impl sinc7Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0007().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1147:1, end:1147:6))"]
#[derive(Clone, Debug)]
struct sinc7Var1 {
    sinc8: Tablesinc8,
}
impl sinc7Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r8),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 1i128 {
            return None;
        }
        let sinc8 = if let Some((len, table)) =
            Tablesinc8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1149:1, end:1149:6))"]
#[derive(Clone, Debug)]
struct sinc7Var2 {
    sinc8: Tablesinc8,
}
impl sinc7Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 0i128 {
            return None;
        }
        let sinc8 = if let Some((len, table)) =
            Tablesinc8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc7 {
    Var0(sinc7Var0),
    Var1(sinc7Var1),
    Var2(sinc7Var2),
}
impl Tablesinc7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc7Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc7Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc7Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1151:1, end:1151:6))"]
#[derive(Clone, Debug)]
struct sinc6Var0 {}
impl sinc6Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0008().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1150:1, end:1150:6))"]
#[derive(Clone, Debug)]
struct sinc6Var1 {
    sinc7: Tablesinc7,
}
impl sinc6Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r9),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 1i128 {
            return None;
        }
        let sinc7 = if let Some((len, table)) =
            Tablesinc7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1152:1, end:1152:6))"]
#[derive(Clone, Debug)]
struct sinc6Var2 {
    sinc7: Tablesinc7,
}
impl sinc6Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 0i128 {
            return None;
        }
        let sinc7 = if let Some((len, table)) =
            Tablesinc7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc6 {
    Var0(sinc6Var0),
    Var1(sinc6Var1),
    Var2(sinc6Var2),
}
impl Tablesinc6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc6Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc6Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc6Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1154:1, end:1154:6))"]
#[derive(Clone, Debug)]
struct sinc5Var0 {}
impl sinc5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0009().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1153:1, end:1153:6))"]
#[derive(Clone, Debug)]
struct sinc5Var1 {
    sinc6: Tablesinc6,
}
impl sinc5Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r10),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 1i128 {
            return None;
        }
        let sinc6 = if let Some((len, table)) =
            Tablesinc6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1155:1, end:1155:6))"]
#[derive(Clone, Debug)]
struct sinc5Var2 {
    sinc6: Tablesinc6,
}
impl sinc5Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 0i128 {
            return None;
        }
        let sinc6 = if let Some((len, table)) =
            Tablesinc6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc6 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc5 {
    Var0(sinc5Var0),
    Var1(sinc5Var1),
    Var2(sinc5Var2),
}
impl Tablesinc5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc5Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc5Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1157:1, end:1157:6))"]
#[derive(Clone, Debug)]
struct sinc4Var0 {}
impl sinc4Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0010().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1156:1, end:1156:6))"]
#[derive(Clone, Debug)]
struct sinc4Var1 {
    sinc5: Tablesinc5,
}
impl sinc4Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r11),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 1i128 {
            return None;
        }
        let sinc5 = if let Some((len, table)) =
            Tablesinc5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1158:1, end:1158:6))"]
#[derive(Clone, Debug)]
struct sinc4Var2 {
    sinc5: Tablesinc5,
}
impl sinc4Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 0i128 {
            return None;
        }
        let sinc5 = if let Some((len, table)) =
            Tablesinc5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc5 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc4 {
    Var0(sinc4Var0),
    Var1(sinc4Var1),
    Var2(sinc4Var2),
}
impl Tablesinc4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc4Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc4Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc4Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1160:1, end:1160:6))"]
#[derive(Clone, Debug)]
struct sinc3Var0 {}
impl sinc3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0011().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1159:1, end:1159:6))"]
#[derive(Clone, Debug)]
struct sinc3Var1 {
    sinc4: Tablesinc4,
}
impl sinc3Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r12),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 1i128 {
            return None;
        }
        let sinc4 = if let Some((len, table)) =
            Tablesinc4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1161:1, end:1161:6))"]
#[derive(Clone, Debug)]
struct sinc3Var2 {
    sinc4: Tablesinc4,
}
impl sinc3Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 0i128 {
            return None;
        }
        let sinc4 = if let Some((len, table)) =
            Tablesinc4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc4 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc3 {
    Var0(sinc3Var0),
    Var1(sinc3Var1),
    Var2(sinc3Var2),
}
impl Tablesinc3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc3Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc3Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1163:1, end:1163:6))"]
#[derive(Clone, Debug)]
struct sinc2Var0 {}
impl sinc2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0012().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1162:1, end:1162:6))"]
#[derive(Clone, Debug)]
struct sinc2Var1 {
    sinc3: Tablesinc3,
}
impl sinc2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::sp),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 1i128 {
            return None;
        }
        let sinc3 = if let Some((len, table)) =
            Tablesinc3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1164:1, end:1164:6))"]
#[derive(Clone, Debug)]
struct sinc2Var2 {
    sinc3: Tablesinc3,
}
impl sinc2Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 0i128 {
            return None;
        }
        let sinc3 = if let Some((len, table)) =
            Tablesinc3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc3 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc2 {
    Var0(sinc2Var0),
    Var1(sinc2Var1),
    Var2(sinc2Var2),
}
impl Tablesinc2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc2Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1166:1, end:1166:6))"]
#[derive(Clone, Debug)]
struct sinc1Var0 {}
impl sinc1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0013().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1165:1, end:1165:6))"]
#[derive(Clone, Debug)]
struct sinc1Var1 {
    sinc2: Tablesinc2,
}
impl sinc1Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::lr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 1i128 {
            return None;
        }
        let sinc2 = if let Some((len, table)) =
            Tablesinc2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1167:1, end:1167:6))"]
#[derive(Clone, Debug)]
struct sinc1Var2 {
    sinc2: Tablesinc2,
}
impl sinc1Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 0i128 {
            return None;
        }
        let sinc2 = if let Some((len, table)) =
            Tablesinc2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc1 {
    Var0(sinc1Var0),
    Var1(sinc1Var1),
    Var2(sinc1Var2),
}
impl Tablesinc1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc1Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc1Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1169:1, end:1169:6))"]
#[derive(Clone, Debug)]
struct sinc0Var0 {}
impl sinc0Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1515().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0014().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1168:1, end:1168:6))"]
#[derive(Clone, Debug)]
struct sinc0Var1 {
    sinc1: Tablesinc1,
}
impl sinc0Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::pc),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1515().disassembly() != 1i128 {
            return None;
        }
        let sinc1 = if let Some((len, table)) =
            Tablesinc1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1170:1, end:1170:6))"]
#[derive(Clone, Debug)]
struct sinc0Var2 {
    sinc1: Tablesinc1,
}
impl sinc0Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sinc1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1515().disassembly() != 0i128 {
            return None;
        }
        let sinc1 = if let Some((len, table)) =
            Tablesinc1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc0 {
    Var0(sinc0Var0),
    Var1(sinc0Var1),
    Var2(sinc0Var2),
}
impl Tablesinc0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sinc0Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc0Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sinc0Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1171:1, end:1171:11))"]
#[derive(Clone, Debug)]
struct stlist_incVar0 {
    sinc0: Tablesinc0,
}
impl stlist_incVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        self.sinc0.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let sinc0 = if let Some((len, table)) =
            Tablesinc0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc0 }))
    }
}
#[derive(Clone, Debug)]
enum Tablestlist_inc {
    Var0(stlist_incVar0),
}
impl Tablestlist_inc {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = stlist_incVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1175:1, end:1175:7))"]
#[derive(Clone, Debug)]
struct ldec15Var0 {}
impl ldec15Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1515().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1176:1, end:1176:7))"]
#[derive(Clone, Debug)]
struct ldec15Var1 {}
impl ldec15Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1515().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tableldec15 {
    Var0(ldec15Var0),
    Var1(ldec15Var1),
}
impl Tableldec15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec15Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec15Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1178:1, end:1178:7))"]
#[derive(Clone, Debug)]
struct ldec14Var0 {}
impl ldec14Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1515().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1177:1, end:1177:7))"]
#[derive(Clone, Debug)]
struct ldec14Var1 {
    ldec15: Tableldec15,
}
impl ldec14Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::lr),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec15.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 1i128 {
            return None;
        }
        let ldec15 = if let Some((len, table)) = Tableldec15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1179:1, end:1179:7))"]
#[derive(Clone, Debug)]
struct ldec14Var2 {
    ldec15: Tableldec15,
}
impl ldec14Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec15.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 0i128 {
            return None;
        }
        let ldec15 = if let Some((len, table)) = Tableldec15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec15 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec14 {
    Var0(ldec14Var0),
    Var1(ldec14Var1),
    Var2(ldec14Var2),
}
impl Tableldec14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec14Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec14Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec14Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1181:1, end:1181:7))"]
#[derive(Clone, Debug)]
struct ldec13Var0 {}
impl ldec13Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1415().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1180:1, end:1180:7))"]
#[derive(Clone, Debug)]
struct ldec13Var1 {
    ldec14: Tableldec14,
}
impl ldec13Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 1i128 {
            return None;
        }
        let ldec14 = if let Some((len, table)) = Tableldec14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1182:1, end:1182:7))"]
#[derive(Clone, Debug)]
struct ldec13Var2 {
    ldec14: Tableldec14,
}
impl ldec13Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 0i128 {
            return None;
        }
        let ldec14 = if let Some((len, table)) = Tableldec14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec14 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec13 {
    Var0(ldec13Var0),
    Var1(ldec13Var1),
    Var2(ldec13Var2),
}
impl Tableldec13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec13Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec13Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec13Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1184:1, end:1184:7))"]
#[derive(Clone, Debug)]
struct ldec12Var0 {}
impl ldec12Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1315().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1183:1, end:1183:7))"]
#[derive(Clone, Debug)]
struct ldec12Var1 {
    ldec13: Tableldec13,
}
impl ldec12Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r12),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec13.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 1i128 {
            return None;
        }
        let ldec13 = if let Some((len, table)) = Tableldec13::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1185:1, end:1185:7))"]
#[derive(Clone, Debug)]
struct ldec12Var2 {
    ldec13: Tableldec13,
}
impl ldec12Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec13.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 0i128 {
            return None;
        }
        let ldec13 = if let Some((len, table)) = Tableldec13::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec13 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec12 {
    Var0(ldec12Var0),
    Var1(ldec12Var1),
    Var2(ldec12Var2),
}
impl Tableldec12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec12Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec12Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec12Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1187:1, end:1187:7))"]
#[derive(Clone, Debug)]
struct ldec11Var0 {}
impl ldec11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1186:1, end:1186:7))"]
#[derive(Clone, Debug)]
struct ldec11Var1 {
    ldec12: Tableldec12,
}
impl ldec11Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r11),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 1i128 {
            return None;
        }
        let ldec12 = if let Some((len, table)) = Tableldec12::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1188:1, end:1188:7))"]
#[derive(Clone, Debug)]
struct ldec11Var2 {
    ldec12: Tableldec12,
}
impl ldec11Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 0i128 {
            return None;
        }
        let ldec12 = if let Some((len, table)) = Tableldec12::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec12 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec11 {
    Var0(ldec11Var0),
    Var1(ldec11Var1),
    Var2(ldec11Var2),
}
impl Tableldec11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec11Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec11Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec11Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1190:1, end:1190:7))"]
#[derive(Clone, Debug)]
struct ldec10Var0 {}
impl ldec10Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1115().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1189:1, end:1189:7))"]
#[derive(Clone, Debug)]
struct ldec10Var1 {
    ldec11: Tableldec11,
}
impl ldec10Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r10),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 1i128 {
            return None;
        }
        let ldec11 = if let Some((len, table)) = Tableldec11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1191:1, end:1191:7))"]
#[derive(Clone, Debug)]
struct ldec10Var2 {
    ldec11: Tableldec11,
}
impl ldec10Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 0i128 {
            return None;
        }
        let ldec11 = if let Some((len, table)) = Tableldec11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec11 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec10 {
    Var0(ldec10Var0),
    Var1(ldec10Var1),
    Var2(ldec10Var2),
}
impl Tableldec10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec10Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec10Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec10Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1193:1, end:1193:6))"]
#[derive(Clone, Debug)]
struct ldec9Var0 {}
impl ldec9Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1015().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1192:1, end:1192:6))"]
#[derive(Clone, Debug)]
struct ldec9Var1 {
    ldec10: Tableldec10,
}
impl ldec9Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r9),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec10.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 1i128 {
            return None;
        }
        let ldec10 = if let Some((len, table)) = Tableldec10::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1194:1, end:1194:6))"]
#[derive(Clone, Debug)]
struct ldec9Var2 {
    ldec10: Tableldec10,
}
impl ldec9Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec10.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 0i128 {
            return None;
        }
        let ldec10 = if let Some((len, table)) = Tableldec10::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec10 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec9 {
    Var0(ldec9Var0),
    Var1(ldec9Var1),
    Var2(ldec9Var2),
}
impl Tableldec9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec9Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec9Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec9Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1196:1, end:1196:6))"]
#[derive(Clone, Debug)]
struct ldec8Var0 {}
impl ldec8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0915().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1195:1, end:1195:6))"]
#[derive(Clone, Debug)]
struct ldec8Var1 {
    ldec9: Tableldec9,
}
impl ldec8Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r8),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 1i128 {
            return None;
        }
        let ldec9 = if let Some((len, table)) =
            Tableldec9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1197:1, end:1197:6))"]
#[derive(Clone, Debug)]
struct ldec8Var2 {
    ldec9: Tableldec9,
}
impl ldec8Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 0i128 {
            return None;
        }
        let ldec9 = if let Some((len, table)) =
            Tableldec9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec9 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec8 {
    Var0(ldec8Var0),
    Var1(ldec8Var1),
    Var2(ldec8Var2),
}
impl Tableldec8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec8Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec8Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1199:1, end:1199:6))"]
#[derive(Clone, Debug)]
struct ldec7Var0 {}
impl ldec7Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0815().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1198:1, end:1198:6))"]
#[derive(Clone, Debug)]
struct ldec7Var1 {
    ldec8: Tableldec8,
}
impl ldec7Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r7),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 1i128 {
            return None;
        }
        let ldec8 = if let Some((len, table)) =
            Tableldec8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1200:1, end:1200:6))"]
#[derive(Clone, Debug)]
struct ldec7Var2 {
    ldec8: Tableldec8,
}
impl ldec7Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 0i128 {
            return None;
        }
        let ldec8 = if let Some((len, table)) =
            Tableldec8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec8 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec7 {
    Var0(ldec7Var0),
    Var1(ldec7Var1),
    Var2(ldec7Var2),
}
impl Tableldec7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec7Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec7Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec7Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1202:1, end:1202:6))"]
#[derive(Clone, Debug)]
struct ldec6Var0 {}
impl ldec6Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0715().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1201:1, end:1201:6))"]
#[derive(Clone, Debug)]
struct ldec6Var1 {
    ldec7: Tableldec7,
}
impl ldec6Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r6),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 1i128 {
            return None;
        }
        let ldec7 = if let Some((len, table)) =
            Tableldec7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1203:1, end:1203:6))"]
#[derive(Clone, Debug)]
struct ldec6Var2 {
    ldec7: Tableldec7,
}
impl ldec6Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 0i128 {
            return None;
        }
        let ldec7 = if let Some((len, table)) =
            Tableldec7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec7 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec6 {
    Var0(ldec6Var0),
    Var1(ldec6Var1),
    Var2(ldec6Var2),
}
impl Tableldec6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec6Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec6Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec6Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1205:1, end:1205:6))"]
#[derive(Clone, Debug)]
struct ldec5Var0 {}
impl ldec5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0615().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1204:1, end:1204:6))"]
#[derive(Clone, Debug)]
struct ldec5Var1 {
    ldec6: Tableldec6,
}
impl ldec5Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r5),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 1i128 {
            return None;
        }
        let ldec6 = if let Some((len, table)) =
            Tableldec6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1206:1, end:1206:6))"]
#[derive(Clone, Debug)]
struct ldec5Var2 {
    ldec6: Tableldec6,
}
impl ldec5Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 0i128 {
            return None;
        }
        let ldec6 = if let Some((len, table)) =
            Tableldec6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec6 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec5 {
    Var0(ldec5Var0),
    Var1(ldec5Var1),
    Var2(ldec5Var2),
}
impl Tableldec5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec5Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec5Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1208:1, end:1208:6))"]
#[derive(Clone, Debug)]
struct ldec4Var0 {}
impl ldec4Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0515().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1207:1, end:1207:6))"]
#[derive(Clone, Debug)]
struct ldec4Var1 {
    ldec5: Tableldec5,
}
impl ldec4Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r4),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        let ldec5 = if let Some((len, table)) =
            Tableldec5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1209:1, end:1209:6))"]
#[derive(Clone, Debug)]
struct ldec4Var2 {
    ldec5: Tableldec5,
}
impl ldec4Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let ldec5 = if let Some((len, table)) =
            Tableldec5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec5 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec4 {
    Var0(ldec4Var0),
    Var1(ldec4Var1),
    Var2(ldec4Var2),
}
impl Tableldec4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec4Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec4Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec4Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1211:1, end:1211:6))"]
#[derive(Clone, Debug)]
struct ldec3Var0 {}
impl ldec3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0415().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1210:1, end:1210:6))"]
#[derive(Clone, Debug)]
struct ldec3Var1 {
    ldec4: Tableldec4,
}
impl ldec3Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r3),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 1i128 {
            return None;
        }
        let ldec4 = if let Some((len, table)) =
            Tableldec4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1212:1, end:1212:6))"]
#[derive(Clone, Debug)]
struct ldec3Var2 {
    ldec4: Tableldec4,
}
impl ldec3Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 0i128 {
            return None;
        }
        let ldec4 = if let Some((len, table)) =
            Tableldec4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec4 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec3 {
    Var0(ldec3Var0),
    Var1(ldec3Var1),
    Var2(ldec3Var2),
}
impl Tableldec3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec3Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec3Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1214:1, end:1214:6))"]
#[derive(Clone, Debug)]
struct ldec2Var0 {}
impl ldec2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0315().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1213:1, end:1213:6))"]
#[derive(Clone, Debug)]
struct ldec2Var1 {
    ldec3: Tableldec3,
}
impl ldec2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r2),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 1i128 {
            return None;
        }
        let ldec3 = if let Some((len, table)) =
            Tableldec3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1215:1, end:1215:6))"]
#[derive(Clone, Debug)]
struct ldec2Var2 {
    ldec3: Tableldec3,
}
impl ldec2Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 0i128 {
            return None;
        }
        let ldec3 = if let Some((len, table)) =
            Tableldec3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec3 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec2 {
    Var0(ldec2Var0),
    Var1(ldec2Var1),
    Var2(ldec2Var2),
}
impl Tableldec2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec2Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1217:1, end:1217:6))"]
#[derive(Clone, Debug)]
struct ldec1Var0 {}
impl ldec1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0215().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1216:1, end:1216:6))"]
#[derive(Clone, Debug)]
struct ldec1Var1 {
    ldec2: Tableldec2,
}
impl ldec1Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r1),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 1i128 {
            return None;
        }
        let ldec2 = if let Some((len, table)) =
            Tableldec2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1218:1, end:1218:6))"]
#[derive(Clone, Debug)]
struct ldec1Var2 {
    ldec2: Tableldec2,
}
impl ldec1Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 0i128 {
            return None;
        }
        let ldec2 = if let Some((len, table)) =
            Tableldec2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec2 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec1 {
    Var0(ldec1Var0),
    Var1(ldec1Var1),
    Var2(ldec1Var2),
}
impl Tableldec1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec1Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec1Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1220:1, end:1220:6))"]
#[derive(Clone, Debug)]
struct ldec0Var0 {}
impl ldec0Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0000().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0115().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1219:1, end:1219:6))"]
#[derive(Clone, Debug)]
struct ldec0Var1 {
    ldec1: Tableldec1,
}
impl ldec0Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r0),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0000().disassembly() != 1i128 {
            return None;
        }
        let ldec1 = if let Some((len, table)) =
            Tableldec1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1221:1, end:1221:6))"]
#[derive(Clone, Debug)]
struct ldec0Var2 {
    ldec1: Tableldec1,
}
impl ldec0Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.ldec1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0000().disassembly() != 0i128 {
            return None;
        }
        let ldec1 = if let Some((len, table)) =
            Tableldec1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec1 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec0 {
    Var0(ldec0Var0),
    Var1(ldec0Var1),
    Var2(ldec0Var2),
}
impl Tableldec0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ldec0Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec0Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ldec0Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1222:1, end:1222:11))"]
#[derive(Clone, Debug)]
struct ldlist_decVar0 {
    ldec0: Tableldec0,
}
impl ldlist_decVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        self.ldec0.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let ldec0 = if let Some((len, table)) =
            Tableldec0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec0 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldlist_dec {
    Var0(ldlist_decVar0),
}
impl Tableldlist_dec {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = ldlist_decVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1225:1, end:1225:7))"]
#[derive(Clone, Debug)]
struct sdec15Var0 {}
impl sdec15Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1515().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1226:1, end:1226:7))"]
#[derive(Clone, Debug)]
struct sdec15Var1 {}
impl sdec15Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1515().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec15 {
    Var0(sdec15Var0),
    Var1(sdec15Var1),
}
impl Tablesdec15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec15Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec15Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1228:1, end:1228:7))"]
#[derive(Clone, Debug)]
struct sdec14Var0 {}
impl sdec14Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1515().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1227:1, end:1227:7))"]
#[derive(Clone, Debug)]
struct sdec14Var1 {
    sdec15: Tablesdec15,
}
impl sdec14Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::lr),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec15.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 1i128 {
            return None;
        }
        let sdec15 = if let Some((len, table)) = Tablesdec15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1229:1, end:1229:7))"]
#[derive(Clone, Debug)]
struct sdec14Var2 {
    sdec15: Tablesdec15,
}
impl sdec14Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec15.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1414().disassembly() != 0i128 {
            return None;
        }
        let sdec15 = if let Some((len, table)) = Tablesdec15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec15 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec14 {
    Var0(sdec14Var0),
    Var1(sdec14Var1),
    Var2(sdec14Var2),
}
impl Tablesdec14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec14Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec14Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec14Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1231:1, end:1231:7))"]
#[derive(Clone, Debug)]
struct sdec13Var0 {}
impl sdec13Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1415().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1230:1, end:1230:7))"]
#[derive(Clone, Debug)]
struct sdec13Var1 {
    sdec14: Tablesdec14,
}
impl sdec13Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 1i128 {
            return None;
        }
        let sdec14 = if let Some((len, table)) = Tablesdec14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1232:1, end:1232:7))"]
#[derive(Clone, Debug)]
struct sdec13Var2 {
    sdec14: Tablesdec14,
}
impl sdec13Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1313().disassembly() != 0i128 {
            return None;
        }
        let sdec14 = if let Some((len, table)) = Tablesdec14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec14 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec13 {
    Var0(sdec13Var0),
    Var1(sdec13Var1),
    Var2(sdec13Var2),
}
impl Tablesdec13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec13Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec13Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec13Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1234:1, end:1234:7))"]
#[derive(Clone, Debug)]
struct sdec12Var0 {}
impl sdec12Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1315().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1233:1, end:1233:7))"]
#[derive(Clone, Debug)]
struct sdec12Var1 {
    sdec13: Tablesdec13,
}
impl sdec12Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r12),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec13.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 1i128 {
            return None;
        }
        let sdec13 = if let Some((len, table)) = Tablesdec13::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1235:1, end:1235:7))"]
#[derive(Clone, Debug)]
struct sdec12Var2 {
    sdec13: Tablesdec13,
}
impl sdec12Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec13.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1212().disassembly() != 0i128 {
            return None;
        }
        let sdec13 = if let Some((len, table)) = Tablesdec13::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec13 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec12 {
    Var0(sdec12Var0),
    Var1(sdec12Var1),
    Var2(sdec12Var2),
}
impl Tablesdec12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec12Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec12Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec12Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1237:1, end:1237:7))"]
#[derive(Clone, Debug)]
struct sdec11Var0 {}
impl sdec11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1215().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1236:1, end:1236:7))"]
#[derive(Clone, Debug)]
struct sdec11Var1 {
    sdec12: Tablesdec12,
}
impl sdec11Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r11),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 1i128 {
            return None;
        }
        let sdec12 = if let Some((len, table)) = Tablesdec12::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1238:1, end:1238:7))"]
#[derive(Clone, Debug)]
struct sdec11Var2 {
    sdec12: Tablesdec12,
}
impl sdec11Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec12.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1111().disassembly() != 0i128 {
            return None;
        }
        let sdec12 = if let Some((len, table)) = Tablesdec12::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec12 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec11 {
    Var0(sdec11Var0),
    Var1(sdec11Var1),
    Var2(sdec11Var2),
}
impl Tablesdec11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec11Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec11Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec11Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1240:1, end:1240:7))"]
#[derive(Clone, Debug)]
struct sdec10Var0 {}
impl sdec10Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1115().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1239:1, end:1239:7))"]
#[derive(Clone, Debug)]
struct sdec10Var1 {
    sdec11: Tablesdec11,
}
impl sdec10Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r10),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 1i128 {
            return None;
        }
        let sdec11 = if let Some((len, table)) = Tablesdec11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1241:1, end:1241:7))"]
#[derive(Clone, Debug)]
struct sdec10Var2 {
    sdec11: Tablesdec11,
}
impl sdec10Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc1010().disassembly() != 0i128 {
            return None;
        }
        let sdec11 = if let Some((len, table)) = Tablesdec11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec11 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec10 {
    Var0(sdec10Var0),
    Var1(sdec10Var1),
    Var2(sdec10Var2),
}
impl Tablesdec10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec10Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec10Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec10Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1243:1, end:1243:6))"]
#[derive(Clone, Debug)]
struct sdec9Var0 {}
impl sdec9Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc1015().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1242:1, end:1242:6))"]
#[derive(Clone, Debug)]
struct sdec9Var1 {
    sdec10: Tablesdec10,
}
impl sdec9Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r9),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec10.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 1i128 {
            return None;
        }
        let sdec10 = if let Some((len, table)) = Tablesdec10::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1244:1, end:1244:6))"]
#[derive(Clone, Debug)]
struct sdec9Var2 {
    sdec10: Tablesdec10,
}
impl sdec9Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec10.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0909().disassembly() != 0i128 {
            return None;
        }
        let sdec10 = if let Some((len, table)) = Tablesdec10::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec10 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec9 {
    Var0(sdec9Var0),
    Var1(sdec9Var1),
    Var2(sdec9Var2),
}
impl Tablesdec9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec9Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec9Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec9Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1246:1, end:1246:6))"]
#[derive(Clone, Debug)]
struct sdec8Var0 {}
impl sdec8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0915().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1245:1, end:1245:6))"]
#[derive(Clone, Debug)]
struct sdec8Var1 {
    sdec9: Tablesdec9,
}
impl sdec8Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r8),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 1i128 {
            return None;
        }
        let sdec9 = if let Some((len, table)) =
            Tablesdec9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1247:1, end:1247:6))"]
#[derive(Clone, Debug)]
struct sdec8Var2 {
    sdec9: Tablesdec9,
}
impl sdec8Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0808().disassembly() != 0i128 {
            return None;
        }
        let sdec9 = if let Some((len, table)) =
            Tablesdec9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec9 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec8 {
    Var0(sdec8Var0),
    Var1(sdec8Var1),
    Var2(sdec8Var2),
}
impl Tablesdec8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec8Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec8Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1249:1, end:1249:6))"]
#[derive(Clone, Debug)]
struct sdec7Var0 {}
impl sdec7Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0815().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1248:1, end:1248:6))"]
#[derive(Clone, Debug)]
struct sdec7Var1 {
    sdec8: Tablesdec8,
}
impl sdec7Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r7),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 1i128 {
            return None;
        }
        let sdec8 = if let Some((len, table)) =
            Tablesdec8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1250:1, end:1250:6))"]
#[derive(Clone, Debug)]
struct sdec7Var2 {
    sdec8: Tablesdec8,
}
impl sdec7Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0707().disassembly() != 0i128 {
            return None;
        }
        let sdec8 = if let Some((len, table)) =
            Tablesdec8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec7 {
    Var0(sdec7Var0),
    Var1(sdec7Var1),
    Var2(sdec7Var2),
}
impl Tablesdec7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec7Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec7Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec7Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1252:1, end:1252:6))"]
#[derive(Clone, Debug)]
struct sdec6Var0 {}
impl sdec6Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0715().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1251:1, end:1251:6))"]
#[derive(Clone, Debug)]
struct sdec6Var1 {
    sdec7: Tablesdec7,
}
impl sdec6Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r6),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 1i128 {
            return None;
        }
        let sdec7 = if let Some((len, table)) =
            Tablesdec7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1253:1, end:1253:6))"]
#[derive(Clone, Debug)]
struct sdec6Var2 {
    sdec7: Tablesdec7,
}
impl sdec6Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec7.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0606().disassembly() != 0i128 {
            return None;
        }
        let sdec7 = if let Some((len, table)) =
            Tablesdec7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec6 {
    Var0(sdec6Var0),
    Var1(sdec6Var1),
    Var2(sdec6Var2),
}
impl Tablesdec6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec6Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec6Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec6Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1255:1, end:1255:6))"]
#[derive(Clone, Debug)]
struct sdec5Var0 {}
impl sdec5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0615().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1254:1, end:1254:6))"]
#[derive(Clone, Debug)]
struct sdec5Var1 {
    sdec6: Tablesdec6,
}
impl sdec5Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r5),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 1i128 {
            return None;
        }
        let sdec6 = if let Some((len, table)) =
            Tablesdec6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1256:1, end:1256:6))"]
#[derive(Clone, Debug)]
struct sdec5Var2 {
    sdec6: Tablesdec6,
}
impl sdec5Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec6.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0505().disassembly() != 0i128 {
            return None;
        }
        let sdec6 = if let Some((len, table)) =
            Tablesdec6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec6 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec5 {
    Var0(sdec5Var0),
    Var1(sdec5Var1),
    Var2(sdec5Var2),
}
impl Tablesdec5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec5Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec5Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1258:1, end:1258:6))"]
#[derive(Clone, Debug)]
struct sdec4Var0 {}
impl sdec4Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0515().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1257:1, end:1257:6))"]
#[derive(Clone, Debug)]
struct sdec4Var1 {
    sdec5: Tablesdec5,
}
impl sdec4Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r4),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 1i128 {
            return None;
        }
        let sdec5 = if let Some((len, table)) =
            Tablesdec5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1259:1, end:1259:6))"]
#[derive(Clone, Debug)]
struct sdec4Var2 {
    sdec5: Tablesdec5,
}
impl sdec4Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0404().disassembly() != 0i128 {
            return None;
        }
        let sdec5 = if let Some((len, table)) =
            Tablesdec5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec5 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec4 {
    Var0(sdec4Var0),
    Var1(sdec4Var1),
    Var2(sdec4Var2),
}
impl Tablesdec4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec4Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec4Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec4Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1261:1, end:1261:6))"]
#[derive(Clone, Debug)]
struct sdec3Var0 {}
impl sdec3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0415().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1260:1, end:1260:6))"]
#[derive(Clone, Debug)]
struct sdec3Var1 {
    sdec4: Tablesdec4,
}
impl sdec3Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r3),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 1i128 {
            return None;
        }
        let sdec4 = if let Some((len, table)) =
            Tablesdec4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1262:1, end:1262:6))"]
#[derive(Clone, Debug)]
struct sdec3Var2 {
    sdec4: Tablesdec4,
}
impl sdec3Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec4.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0303().disassembly() != 0i128 {
            return None;
        }
        let sdec4 = if let Some((len, table)) =
            Tablesdec4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec4 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec3 {
    Var0(sdec3Var0),
    Var1(sdec3Var1),
    Var2(sdec3Var2),
}
impl Tablesdec3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec3Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec3Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1264:1, end:1264:6))"]
#[derive(Clone, Debug)]
struct sdec2Var0 {}
impl sdec2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0315().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1263:1, end:1263:6))"]
#[derive(Clone, Debug)]
struct sdec2Var1 {
    sdec3: Tablesdec3,
}
impl sdec2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r2),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 1i128 {
            return None;
        }
        let sdec3 = if let Some((len, table)) =
            Tablesdec3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1265:1, end:1265:6))"]
#[derive(Clone, Debug)]
struct sdec2Var2 {
    sdec3: Tablesdec3,
}
impl sdec2Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0202().disassembly() != 0i128 {
            return None;
        }
        let sdec3 = if let Some((len, table)) =
            Tablesdec3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec3 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec2 {
    Var0(sdec2Var0),
    Var1(sdec2Var1),
    Var2(sdec2Var2),
}
impl Tablesdec2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec2Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1267:1, end:1267:6))"]
#[derive(Clone, Debug)]
struct sdec1Var0 {}
impl sdec1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0215().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1266:1, end:1266:6))"]
#[derive(Clone, Debug)]
struct sdec1Var1 {
    sdec2: Tablesdec2,
}
impl sdec1Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r1),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 1i128 {
            return None;
        }
        let sdec2 = if let Some((len, table)) =
            Tablesdec2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1268:1, end:1268:6))"]
#[derive(Clone, Debug)]
struct sdec1Var2 {
    sdec2: Tablesdec2,
}
impl sdec1Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0101().disassembly() != 0i128 {
            return None;
        }
        let sdec2 = if let Some((len, table)) =
            Tablesdec2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec1 {
    Var0(sdec1Var0),
    Var1(sdec1Var1),
    Var2(sdec1Var2),
}
impl Tablesdec1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec1Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec1Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1270:1, end:1270:6))"]
#[derive(Clone, Debug)]
struct sdec0Var0 {}
impl sdec0Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0000().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldc0115().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1269:1, end:1269:6))"]
#[derive(Clone, Debug)]
struct sdec0Var1 {
    sdec1: Tablesdec1,
}
impl sdec0Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r0),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0000().disassembly() != 1i128 {
            return None;
        }
        let sdec1 = if let Some((len, table)) =
            Tablesdec1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1271:1, end:1271:6))"]
#[derive(Clone, Debug)]
struct sdec0Var2 {
    sdec1: Tablesdec1,
}
impl sdec0Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.sdec1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc0000().disassembly() != 0i128 {
            return None;
        }
        let sdec1 = if let Some((len, table)) =
            Tablesdec1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec0 {
    Var0(sdec0Var0),
    Var1(sdec0Var1),
    Var2(sdec0Var2),
}
impl Tablesdec0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sdec0Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec0Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sdec0Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1273:1, end:1273:11))"]
#[derive(Clone, Debug)]
struct stlist_decVar0 {
    sdec0: Tablesdec0,
}
impl stlist_decVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        self.sdec0.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let sdec0 = if let Some((len, table)) =
            Tablesdec0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec0 }))
    }
}
#[derive(Clone, Debug)]
enum Tablestlist_dec {
    Var0(stlist_decVar0),
}
impl Tablestlist_dec {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = stlist_decVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1278:1, end:1278:8))"]
#[derive(Clone, Debug)]
struct reglistVar0 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) = Tableldlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1283:1, end:1283:8))"]
#[derive(Clone, Debug)]
struct reglistVar1 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) = Tableldlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1288:1, end:1288:8))"]
#[derive(Clone, Debug)]
struct reglistVar2 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) = Tableldlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1293:1, end:1293:8))"]
#[derive(Clone, Debug)]
struct reglistVar3 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) = Tableldlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1298:1, end:1298:8))"]
#[derive(Clone, Debug)]
struct reglistVar4 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) = Tableldlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1303:1, end:1303:8))"]
#[derive(Clone, Debug)]
struct reglistVar5 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) = Tableldlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1308:1, end:1308:8))"]
#[derive(Clone, Debug)]
struct reglistVar6 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) = Tableldlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1313:1, end:1313:8))"]
#[derive(Clone, Debug)]
struct reglistVar7 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) = Tableldlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1318:1, end:1318:8))"]
#[derive(Clone, Debug)]
struct reglistVar8 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) = Tableldlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1323:1, end:1323:8))"]
#[derive(Clone, Debug)]
struct reglistVar9 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) = Tableldlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1328:1, end:1328:8))"]
#[derive(Clone, Debug)]
struct reglistVar10 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) = Tableldlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1333:1, end:1333:8))"]
#[derive(Clone, Debug)]
struct reglistVar11 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) = Tableldlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1338:1, end:1338:8))"]
#[derive(Clone, Debug)]
struct reglistVar12 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) = Tableldlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1343:1, end:1343:8))"]
#[derive(Clone, Debug)]
struct reglistVar13 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) = Tableldlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1348:1, end:1348:8))"]
#[derive(Clone, Debug)]
struct reglistVar14 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) = Tableldlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1353:1, end:1353:8))"]
#[derive(Clone, Debug)]
struct reglistVar15 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 1i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) = Tableldlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1358:1, end:1358:8))"]
#[derive(Clone, Debug)]
struct reglistVar16 {
    rn: Tablern,
    stlist_inc: Tablestlist_inc,
}
impl reglistVar16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) = Tablestlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1363:1, end:1363:8))"]
#[derive(Clone, Debug)]
struct reglistVar17 {
    rn: Tablern,
    stlist_inc: Tablestlist_inc,
}
impl reglistVar17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) = Tablestlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1374:1, end:1374:8))"]
#[derive(Clone, Debug)]
struct reglistVar18 {
    rn: Tablern,
    stlist_inc: Tablestlist_inc,
}
impl reglistVar18 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) = Tablestlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1380:1, end:1380:8))"]
#[derive(Clone, Debug)]
struct reglistVar19 {
    rn: Tablern,
    stlist_inc: Tablestlist_inc,
}
impl reglistVar19 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.stlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) = Tablestlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1385:1, end:1385:8))"]
#[derive(Clone, Debug)]
struct reglistVar20 {
    rn: Tablern,
    stlist_inc: Tablestlist_inc,
}
impl reglistVar20 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) = Tablestlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1390:1, end:1390:8))"]
#[derive(Clone, Debug)]
struct reglistVar21 {
    rn: Tablern,
    stlist_inc: Tablestlist_inc,
}
impl reglistVar21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) = Tablestlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1395:1, end:1395:8))"]
#[derive(Clone, Debug)]
struct reglistVar22 {
    rn: Tablern,
    stlist_inc: Tablestlist_inc,
}
impl reglistVar22 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.stlist_inc.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) = Tablestlist_inc::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1400:1, end:1400:8))"]
#[derive(Clone, Debug)]
struct reglistVar23 {
    rn: Tablern,
    stlist_dec: Tablestlist_dec,
}
impl reglistVar23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) = Tablestlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1405:1, end:1405:8))"]
#[derive(Clone, Debug)]
struct reglistVar24 {
    rn: Tablern,
    stlist_dec: Tablestlist_dec,
}
impl reglistVar24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) = Tablestlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1410:1, end:1410:8))"]
#[derive(Clone, Debug)]
struct reglistVar25 {
    rn: Tablern,
    stlist_dec: Tablestlist_dec,
}
impl reglistVar25 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.stlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) = Tablestlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1415:1, end:1415:8))"]
#[derive(Clone, Debug)]
struct reglistVar26 {
    rn: Tablern,
    stlist_dec: Tablestlist_dec,
}
impl reglistVar26 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) = Tablestlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1420:1, end:1420:8))"]
#[derive(Clone, Debug)]
struct reglistVar27 {
    rn: Tablern,
    stlist_dec: Tablestlist_dec,
}
impl reglistVar27 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) = Tablestlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1425:1, end:1425:8))"]
#[derive(Clone, Debug)]
struct reglistVar28 {
    rn: Tablern,
    stlist_dec: Tablestlist_dec,
}
impl reglistVar28 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        self.stlist_dec.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldS22().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldL20().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) = Tablestlist_dec::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_dec }))
    }
}
#[derive(Clone, Debug)]
enum Tablereglist {
    Var0(reglistVar0),
    Var1(reglistVar1),
    Var2(reglistVar2),
    Var3(reglistVar3),
    Var4(reglistVar4),
    Var5(reglistVar5),
    Var6(reglistVar6),
    Var7(reglistVar7),
    Var8(reglistVar8),
    Var9(reglistVar9),
    Var10(reglistVar10),
    Var11(reglistVar11),
    Var12(reglistVar12),
    Var13(reglistVar13),
    Var14(reglistVar14),
    Var15(reglistVar15),
    Var16(reglistVar16),
    Var17(reglistVar17),
    Var18(reglistVar18),
    Var19(reglistVar19),
    Var20(reglistVar20),
    Var21(reglistVar21),
    Var22(reglistVar22),
    Var23(reglistVar23),
    Var24(reglistVar24),
    Var25(reglistVar25),
    Var26(reglistVar26),
    Var27(reglistVar27),
    Var28(reglistVar28),
}
impl Tablereglist {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var18(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var19(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var20(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var21(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var22(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var23(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var24(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var25(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var26(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var27(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var28(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            reglistVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar12::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar13::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar14::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar15::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar16::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var16(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar17::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var17(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar18::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var18(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar19::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var19(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar20::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var20(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar21::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var21(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar22::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var22(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar23::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var23(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar24::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var24(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar25::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var25(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar26::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var26(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar27::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var27(parsed)));
        }
        if let Some((inst_len, parsed)) =
            reglistVar28::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var28(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1431:1, end:1431:5))"]
#[derive(Clone, Debug)]
struct mdirVar0 {}
impl mdirVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ia")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1432:1, end:1432:5))"]
#[derive(Clone, Debug)]
struct mdirVar1 {}
impl mdirVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ib")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1433:1, end:1433:5))"]
#[derive(Clone, Debug)]
struct mdirVar2 {}
impl mdirVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("da")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1434:1, end:1434:5))"]
#[derive(Clone, Debug)]
struct mdirVar3 {}
impl mdirVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("db")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablemdir {
    Var0(mdirVar0),
    Var1(mdirVar1),
    Var2(mdirVar2),
    Var3(mdirVar3),
}
impl Tablemdir {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            mdirVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            mdirVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            mdirVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            mdirVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1439:1, end:1439:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var0 {
    immed: TokenField_immed,
    rn: Tablern,
}
impl addrmode5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_off8: i128 = 0;
        calc_off8 = self.immed.disassembly().wrapping_mul(4i128);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_off8),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        calc_off8 = token_parser
            .TokenFieldimmed()
            .disassembly()
            .wrapping_mul(4i128);
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immed = token_parser.TokenFieldimmed();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1440:1, end:1440:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var1 {
    immed: TokenField_immed,
    rn: Tablern,
}
impl addrmode5Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-self.immed.disassembly().wrapping_mul(4i128));
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_noff8),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        calc_noff8 = (-token_parser
            .TokenFieldimmed()
            .disassembly()
            .wrapping_mul(4i128));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immed = token_parser.TokenFieldimmed();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1441:1, end:1441:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var2 {
    immed: TokenField_immed,
    rn: Tablern,
}
impl addrmode5Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_off8: i128 = 0;
        calc_off8 = self.immed.disassembly().wrapping_mul(4i128);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_off8),
            DisplayElement::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        calc_off8 = token_parser
            .TokenFieldimmed()
            .disassembly()
            .wrapping_mul(4i128);
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immed = token_parser.TokenFieldimmed();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1442:1, end:1442:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var3 {
    immed: TokenField_immed,
    rn: Tablern,
}
impl addrmode5Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-self.immed.disassembly().wrapping_mul(4i128));
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(",#"),
            DisplayElement::Number(true, calc_noff8),
            DisplayElement::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        calc_noff8 = (-token_parser
            .TokenFieldimmed()
            .disassembly()
            .wrapping_mul(4i128));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immed = token_parser.TokenFieldimmed();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1443:1, end:1443:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var4 {
    immed: TokenField_immed,
    rn: Tablern,
}
impl addrmode5Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_off8: i128 = 0;
        calc_off8 = self.immed.disassembly().wrapping_mul(4i128);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("],#"),
            DisplayElement::Number(true, calc_off8),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        calc_off8 = token_parser
            .TokenFieldimmed()
            .disassembly()
            .wrapping_mul(4i128);
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immed = token_parser.TokenFieldimmed();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1444:1, end:1444:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var5 {
    immed: TokenField_immed,
    rn: Tablern,
}
impl addrmode5Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-self.immed.disassembly().wrapping_mul(4i128));
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("],#"),
            DisplayElement::Number(true, calc_noff8),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 1i128 {
            return None;
        }
        calc_noff8 = (-token_parser
            .TokenFieldimmed()
            .disassembly()
            .wrapping_mul(4i128));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immed = token_parser.TokenFieldimmed();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1445:1, end:1445:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var6 {
    immed: TokenField_immed,
    rn: Tablern,
}
impl addrmode5Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("],{"),
            self.immed.display(),
            DisplayElement::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldP24().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldW21().disassembly() != 0i128 {
            return None;
        }
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let immed = token_parser.TokenFieldimmed();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[derive(Clone, Debug)]
enum Tableaddrmode5 {
    Var0(addrmode5Var0),
    Var1(addrmode5Var1),
    Var2(addrmode5Var2),
    Var3(addrmode5Var3),
    Var4(addrmode5Var4),
    Var5(addrmode5Var5),
    Var6(addrmode5Var6),
}
impl Tableaddrmode5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            addrmode5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode5Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode5Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode5Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode5Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode5Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addrmode5Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1449:1, end:1449:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar0 {}
impl cpsrmaskVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1450:1, end:1450:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar1 {}
impl cpsrmaskVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_c")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1451:1, end:1451:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar2 {}
impl cpsrmaskVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_x")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1452:1, end:1452:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar3 {}
impl cpsrmaskVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_cx")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 3i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1453:1, end:1453:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar4 {}
impl cpsrmaskVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_s")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1454:1, end:1454:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar5 {}
impl cpsrmaskVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_cs")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 5i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1455:1, end:1455:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar6 {}
impl cpsrmaskVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_xs")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 6i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1456:1, end:1456:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar7 {}
impl cpsrmaskVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_cxs")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 7i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1457:1, end:1457:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar8 {}
impl cpsrmaskVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_f")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 8i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1458:1, end:1458:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar9 {}
impl cpsrmaskVar9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_cf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 9i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1459:1, end:1459:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar10 {}
impl cpsrmaskVar10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_xf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 10i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1460:1, end:1460:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar11 {}
impl cpsrmaskVar11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_cxf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 11i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1461:1, end:1461:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar12 {}
impl cpsrmaskVar12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_sf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 12i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1462:1, end:1462:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar13 {}
impl cpsrmaskVar13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_csf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 13i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1463:1, end:1463:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar14 {}
impl cpsrmaskVar14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_xsf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 14i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1464:1, end:1464:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar15 {}
impl cpsrmaskVar15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_cxsf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 15i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablecpsrmask {
    Var0(cpsrmaskVar0),
    Var1(cpsrmaskVar1),
    Var2(cpsrmaskVar2),
    Var3(cpsrmaskVar3),
    Var4(cpsrmaskVar4),
    Var5(cpsrmaskVar5),
    Var6(cpsrmaskVar6),
    Var7(cpsrmaskVar7),
    Var8(cpsrmaskVar8),
    Var9(cpsrmaskVar9),
    Var10(cpsrmaskVar10),
    Var11(cpsrmaskVar11),
    Var12(cpsrmaskVar12),
    Var13(cpsrmaskVar13),
    Var14(cpsrmaskVar14),
    Var15(cpsrmaskVar15),
}
impl Tablecpsrmask {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            cpsrmaskVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar12::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar13::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar14::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cpsrmaskVar15::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1468:1, end:1468:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar0 {}
impl spsrmaskVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1469:1, end:1469:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar1 {}
impl spsrmaskVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_c")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1470:1, end:1470:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar2 {}
impl spsrmaskVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_x")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1471:1, end:1471:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar3 {}
impl spsrmaskVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_cx")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 3i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1472:1, end:1472:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar4 {}
impl spsrmaskVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_s")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1473:1, end:1473:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar5 {}
impl spsrmaskVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_cs")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 5i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1474:1, end:1474:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar6 {}
impl spsrmaskVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_xs")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 6i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1475:1, end:1475:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar7 {}
impl spsrmaskVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_cxs")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 7i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1476:1, end:1476:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar8 {}
impl spsrmaskVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_f")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 8i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1477:1, end:1477:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar9 {}
impl spsrmaskVar9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_cf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 9i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1478:1, end:1478:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar10 {}
impl spsrmaskVar10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_xf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 10i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1479:1, end:1479:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar11 {}
impl spsrmaskVar11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_cxf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 11i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1480:1, end:1480:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar12 {}
impl spsrmaskVar12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_sf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 12i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1481:1, end:1481:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar13 {}
impl spsrmaskVar13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_csf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 13i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1482:1, end:1482:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar14 {}
impl spsrmaskVar14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_xsf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 14i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1483:1, end:1483:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar15 {}
impl spsrmaskVar15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_cxsf")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldmask().disassembly() != 15i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablespsrmask {
    Var0(spsrmaskVar0),
    Var1(spsrmaskVar1),
    Var2(spsrmaskVar2),
    Var3(spsrmaskVar3),
    Var4(spsrmaskVar4),
    Var5(spsrmaskVar5),
    Var6(spsrmaskVar6),
    Var7(spsrmaskVar7),
    Var8(spsrmaskVar8),
    Var9(spsrmaskVar9),
    Var10(spsrmaskVar10),
    Var11(spsrmaskVar11),
    Var12(spsrmaskVar12),
    Var13(spsrmaskVar13),
    Var14(spsrmaskVar14),
    Var15(spsrmaskVar15),
}
impl Tablespsrmask {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            spsrmaskVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar12::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar13::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar14::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) =
            spsrmaskVar15::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1984:1, end:1984:16))"]
#[derive(Clone, Debug)]
struct ArmPCRelImmed12Var0 {
    immed: TokenField_immed,
    rotate: TokenField_rotate,
}
impl ArmPCRelImmed12Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                ((u32::try_from(32i128.wrapping_sub(
                    self.rotate.disassembly().wrapping_mul(2i128),
                ))
                .ok()
                .map(|shl| self.immed.disassembly().checked_shl(shl))
                .flatten()
                .unwrap_or(0)
                    | u32::try_from(
                        self.rotate.disassembly().wrapping_mul(2i128),
                    )
                    .ok()
                    .map(|shr| self.immed.disassembly().checked_shr(shr))
                    .flatten()
                    .unwrap_or(0))
                    & 4294967295i128),
            );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloff)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 1i128 {
            return None;
        }
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                ((u32::try_from(
                    32i128.wrapping_sub(
                        token_parser
                            .TokenFieldrotate()
                            .disassembly()
                            .wrapping_mul(2i128),
                    ),
                )
                .ok()
                .map(|shl| {
                    token_parser
                        .TokenFieldimmed()
                        .disassembly()
                        .checked_shl(shl)
                })
                .flatten()
                .unwrap_or(0)
                    | u32::try_from(
                        token_parser
                            .TokenFieldrotate()
                            .disassembly()
                            .wrapping_mul(2i128),
                    )
                    .ok()
                    .map(|shr| {
                        token_parser
                            .TokenFieldimmed()
                            .disassembly()
                            .checked_shr(shr)
                    })
                    .flatten()
                    .unwrap_or(0))
                    & 4294967295i128),
            );
        let immed = token_parser.TokenFieldimmed();
        let rotate = token_parser.TokenFieldrotate();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed, rotate }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1990:1, end:1990:16))"]
#[derive(Clone, Debug)]
struct ArmPCRelImmed12Var1 {
    immed: TokenField_immed,
    rotate: TokenField_rotate,
}
impl ArmPCRelImmed12Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start).unwrap().wrapping_add(
            8i128.wrapping_sub(
                ((u32::try_from(32i128.wrapping_sub(
                    self.rotate.disassembly().wrapping_mul(2i128),
                ))
                .ok()
                .map(|shl| self.immed.disassembly().checked_shl(shl))
                .flatten()
                .unwrap_or(0)
                    | u32::try_from(
                        self.rotate.disassembly().wrapping_mul(2i128),
                    )
                    .ok()
                    .map(|shr| self.immed.disassembly().checked_shr(shr))
                    .flatten()
                    .unwrap_or(0))
                    & 4294967295i128),
            ),
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloff)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_ARMcondCk_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldU23().disassembly() != 0i128 {
            return None;
        }
        calc_reloff = i128::try_from(inst_start).unwrap().wrapping_add(
            8i128.wrapping_sub(
                ((u32::try_from(
                    32i128.wrapping_sub(
                        token_parser
                            .TokenFieldrotate()
                            .disassembly()
                            .wrapping_mul(2i128),
                    ),
                )
                .ok()
                .map(|shl| {
                    token_parser
                        .TokenFieldimmed()
                        .disassembly()
                        .checked_shl(shl)
                })
                .flatten()
                .unwrap_or(0)
                    | u32::try_from(
                        token_parser
                            .TokenFieldrotate()
                            .disassembly()
                            .wrapping_mul(2i128),
                    )
                    .ok()
                    .map(|shr| {
                        token_parser
                            .TokenFieldimmed()
                            .disassembly()
                            .checked_shr(shr)
                    })
                    .flatten()
                    .unwrap_or(0))
                    & 4294967295i128),
            ),
        );
        let immed = token_parser.TokenFieldimmed();
        let rotate = token_parser.TokenFieldrotate();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed, rotate }))
    }
}
#[derive(Clone, Debug)]
enum TableArmPCRelImmed12 {
    Var0(ArmPCRelImmed12Var0),
    Var1(ArmPCRelImmed12Var1),
}
impl TableArmPCRelImmed12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = ArmPCRelImmed12Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = ArmPCRelImmed12Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
pub fn parse_instruction<T>(
    tokens: &[u8],
    context: &mut T,
    inst_start: u32,
    global_set: &mut impl GlobalSetTrait,
) -> Option<(u32, Vec<DisplayElement>)>
where
    T: ContextTrait + Clone,
{
    let (inst_len, instruction) =
        Tableinstruction::parse(tokens, context, inst_start)?;
    let inst_next = inst_start + inst_len;
    let mut display = vec![];
    instruction.display_extend(
        &mut display,
        context,
        inst_start,
        inst_next,
        global_set,
    );
    Some((inst_next, display))
}
