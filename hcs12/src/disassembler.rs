use sleigh4rust::*;
pub type AddrType = u32;
pub trait GlobalSetTrait {
    fn set_Prefix18(&mut self, address: Option<u32>, value: i128);
    fn set_PrefixHCS12X(&mut self, address: Option<u32>, value: i128);
    fn set_UseGPAGE(&mut self, address: Option<u32>, value: i128);
    fn set_XGATE(&mut self, address: Option<u32>, value: i128);
}
#[derive(Default)]
pub struct GlobalSetDefault<C: ContextTrait>(
    pub std::collections::HashMap<AddrType, C>,
);
impl<C: ContextTrait> GlobalSetTrait for GlobalSetDefault<C> {
    fn set_Prefix18(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_Prefix18_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_PrefixHCS12X(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_PrefixHCS12X_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_UseGPAGE(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_UseGPAGE_disassembly(value)
                .unwrap();
            context
        });
    }
    fn set_XGATE(&mut self, inst_start: Option<AddrType>, value: i128) {
        let Some (inst_start) = inst_start else { return } ;
        self.0.entry(inst_start).or_insert_with(|| {
            let mut context = C::default();
            context
                .register_mut()
                .write_XGATE_disassembly(value)
                .unwrap();
            context
        });
    }
}
pub trait ContextregisterTrait:
    MemoryRead<AddressType = u16> + MemoryWrite
{
    fn read_Prefix18_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<true>(3, 0, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_Prefix18_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<true>(u8::from(param), 3, 0, 1)
    }
    fn read_Prefix18_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_Prefix18_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_Prefix18_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_Prefix18_raw(param as u8)
    }
    fn read_Prefix18_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_Prefix18_raw()
    }
    fn write_Prefix18_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_Prefix18_raw(param)
    }
    fn Prefix18_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_Prefix18_raw()?))
    }
    fn read_PrefixHCS12X_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<true>(3, 0, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_PrefixHCS12X_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<true>(u8::from(param), 3, 0, 1)
    }
    fn read_PrefixHCS12X_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_PrefixHCS12X_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_PrefixHCS12X_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_PrefixHCS12X_raw(param as u8)
    }
    fn read_PrefixHCS12X_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_PrefixHCS12X_raw()
    }
    fn write_PrefixHCS12X_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_PrefixHCS12X_raw(param)
    }
    fn PrefixHCS12X_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_PrefixHCS12X_raw()?))
    }
    fn read_UseGPAGE_raw(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<true>(3, 1, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_UseGPAGE_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<true>(u8::from(param), 3, 1, 1)
    }
    fn read_UseGPAGE_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_UseGPAGE_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_UseGPAGE_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_UseGPAGE_raw(param as u8)
    }
    fn read_UseGPAGE_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_UseGPAGE_raw()
    }
    fn write_UseGPAGE_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_UseGPAGE_raw(param)
    }
    fn UseGPAGE_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_UseGPAGE_raw()?))
    }
    fn read_XGATE_raw(&self) -> Result<u8, MemoryReadError<Self::AddressType>> {
        let work_value = self.read_u8::<true>(3, 2, 1)?;
        Ok(u8::try_from(work_value).unwrap())
    }
    fn write_XGATE_raw(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_u8::<true>(u8::from(param), 3, 2, 1)
    }
    fn read_XGATE_disassembly(
        &self,
    ) -> Result<i128, MemoryReadError<Self::AddressType>> {
        let raw_value = self.read_XGATE_raw()?;
        Ok(i128::try_from(raw_value).unwrap())
    }
    fn write_XGATE_disassembly(
        &mut self,
        param: i128,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_XGATE_raw(param as u8)
    }
    fn read_XGATE_execution(
        &self,
    ) -> Result<u8, MemoryReadError<Self::AddressType>> {
        self.read_XGATE_raw()
    }
    fn write_XGATE_execution(
        &mut self,
        param: u8,
    ) -> Result<(), MemoryWriteError<Self::AddressType>> {
        self.write_XGATE_raw(param)
    }
    fn XGATE_display(
        &self,
    ) -> Result<DisplayElement, MemoryReadError<Self::AddressType>> {
        Ok(meaning_number(true, self.read_XGATE_raw()?))
    }
}
pub trait ContextTrait: Default {
    type Typeregister: ContextregisterTrait;
    fn register(&self) -> &Self::Typeregister;
    fn register_mut(&mut self) -> &mut Self::Typeregister;
}
#[derive(Debug, Clone, Copy)]
pub struct ContextregisterStructDebug {
    pub chunk_0x0: [Option<bool>; 32],
}
impl Default for ContextregisterStructDebug {
    fn default() -> Self {
        Self {
            chunk_0x0: [None; 32],
        }
    }
}
impl ContextregisterStructDebug {
    fn read_bits(
        &self,
        addr: <Self as MemoryRead>::AddressType,
        buf: &mut [u8],
        mask: &[u8],
    ) -> Result<(), MemoryReadError<<Self as MemoryRead>::AddressType>> {
        assert_eq!(buf.len(), mask.len());
        let buf_len =
            <<Self as MemoryRead>::AddressType>::try_from(buf.len()).unwrap();
        let addr_end = addr + ((buf_len + 7) / 8);
        match (addr, addr_end) {
            (0..=3, 0..=4) => {
                let byte_offset = usize::try_from(addr - 0).unwrap();
                for ((buf_byte, mask_byte), byte) in
                    buf.iter_mut().zip(mask.iter()).zip(byte_offset..)
                {
                    for bit in (0..8)
                        .into_iter()
                        .filter(|bit| ((*mask_byte >> bit) & 1) != 0)
                    {
                        *buf_byte |= (self.chunk_0x0[(byte * 8) + bit].unwrap()
                            as u8)
                            << bit;
                    }
                }
            }
            (addr_start, addr_end) => {
                return Err(MemoryReadError::UnableToReadMemory(
                    addr_start, addr_end,
                ))
            }
        }
        Ok(())
    }
    fn write_bits(
        &mut self,
        addr: <Self as MemoryRead>::AddressType,
        buf: &[u8],
        mask: &[u8],
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        assert_eq!(buf.len(), mask.len());
        let buf_len =
            <<Self as MemoryRead>::AddressType>::try_from(buf.len()).unwrap();
        let addr_end = addr + ((buf_len + 7) / 8);
        match (addr, addr_end) {
            (0..=3, 0..=4) => {
                let byte_offset = usize::try_from(addr - 0).unwrap();
                for ((buf_byte, mask_byte), byte) in
                    buf.iter().zip(mask.iter()).zip(byte_offset..)
                {
                    for bit in (0..8)
                        .into_iter()
                        .filter(|bit| ((*mask_byte >> bit) & 1) != 0)
                    {
                        self.chunk_0x0[(byte * 8) + bit] =
                            Some(*buf_byte & (1 << bit) != 0);
                    }
                }
            }
            (addr_start, addr_end) => {
                return Err(MemoryWriteError::UnableToWriteMemory(
                    addr_start, addr_end,
                ))
            }
        }
        Ok(())
    }
}
impl ContextregisterTrait for ContextregisterStructDebug {}
impl MemoryRead for ContextregisterStructDebug {
    type AddressType = u16;
    fn read(
        &self,
        addr: <Self as MemoryRead>::AddressType,
        buf: &mut [u8],
    ) -> Result<(), MemoryReadError<<Self as MemoryRead>::AddressType>> {
        let mut inner_buf = vec![0xFF; buf.len()];
        self.read_bits(addr, buf, &mut inner_buf)
    }
    fn read_u8<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u8, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u8>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u8>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u8>::from_be_bytes(data)
        } else {
            <u8>::from_le_bytes(data)
        };
        let value_mask = <u8>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
    fn read_u16<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u16, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u16>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u16>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u16>::from_be_bytes(data)
        } else {
            <u16>::from_le_bytes(data)
        };
        let value_mask = <u16>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
    fn read_u32<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u32, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u32>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u32>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u32>::from_be_bytes(data)
        } else {
            <u32>::from_le_bytes(data)
        };
        let value_mask = <u32>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
    fn read_u64<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u64, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u64>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u64>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u64>::from_be_bytes(data)
        } else {
            <u64>::from_le_bytes(data)
        };
        let value_mask = <u64>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
    fn read_u128<const BIG_ENDIAN: bool>(
        &self,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<u128, MemoryReadError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u128>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let mut data = [0u8; TYPE_BYTES];
        let mask = (<u128>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        self.read_bits(
            data_addr,
            &mut data[data_start..data_end],
            &mask[data_start..data_end],
        )?;
        let data = if BIG_ENDIAN {
            <u128>::from_be_bytes(data)
        } else {
            <u128>::from_le_bytes(data)
        };
        let value_mask = <u128>::MAX >> (TYPE_BITS - data_bits);
        Ok((data >> data_lsb) & value_mask)
    }
}
impl MemoryWrite for ContextregisterStructDebug {
    fn write(
        &mut self,
        addr: <Self as MemoryRead>::AddressType,
        buf: &[u8],
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        let mut inner_buf = vec![0xFF; buf.len()];
        self.write_bits(addr, buf, &inner_buf)
    }
    fn write_u8<const BIG_ENDIAN: bool>(
        &mut self,
        value: u8,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u8>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u8>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
    fn write_u16<const BIG_ENDIAN: bool>(
        &mut self,
        value: u16,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u16>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u16>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
    fn write_u32<const BIG_ENDIAN: bool>(
        &mut self,
        value: u32,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u32>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u32>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
    fn write_u64<const BIG_ENDIAN: bool>(
        &mut self,
        value: u64,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u64>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u64>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
    fn write_u128<const BIG_ENDIAN: bool>(
        &mut self,
        value: u128,
        data_addr: <Self as MemoryRead>::AddressType,
        varnode_lsb: usize,
        data_bits: usize,
    ) -> Result<(), MemoryWriteError<<Self as MemoryRead>::AddressType>> {
        const TYPE_BITS: usize = <u128>::BITS as usize;
        const TYPE_BYTES: usize = TYPE_BITS / 8;
        assert!(data_bits > 0);
        let data_lsb = varnode_lsb % 8;
        let read_bytes = (data_bits + data_lsb + 7) / 8;
        assert!(read_bytes <= TYPE_BYTES);
        let mask = (<u128>::MAX >> (TYPE_BITS - data_bits)) << data_lsb;
        let mask_raw = if BIG_ENDIAN {
            mask.to_be_bytes()
        } else {
            mask.to_le_bytes()
        };
        let data_start = if BIG_ENDIAN {
            TYPE_BYTES - read_bytes
        } else {
            0
        };
        let data_end = data_start + read_bytes;
        let value = (value << data_lsb) & mask;
        let final_mem = if BIG_ENDIAN {
            value.to_be_bytes()
        } else {
            value.to_le_bytes()
        };
        self.write_bits(
            data_addr,
            &final_mem[data_start..data_end],
            &mask_raw[data_start..data_end],
        )
    }
}
#[derive(Debug, Clone, Copy, Default)]
pub struct SpacesStruct {
    pub register: ContextregisterStructDebug,
}
impl ContextTrait for SpacesStruct {
    type Typeregister = ContextregisterStructDebug;
    fn register(&self) -> &Self::Typeregister {
        &self.register
    }
    fn register_mut(&mut self) -> &mut Self::Typeregister {
        &mut self.register
    }
}
fn meaning_number<T>(hex: bool, num: T) -> DisplayElement
where
    i128: TryFrom<T>,
    <i128 as TryFrom<T>>::Error: core::fmt::Debug,
{
    DisplayElement::Number(hex, i128::try_from(num).unwrap())
}
fn meaning_0_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_0_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_0_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::IX,
        1 => Register::IY,
        2 => Register::SP,
        3 => Register::PC,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_1_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_1_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_1_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::IX,
        1 => Register::IY,
        2 => Register::SP,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_3_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_3_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_3_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A,
        1 => Register::B,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_4_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_4_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_4_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A,
        1 => Register::B,
        2 => Register::CCR,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_5_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_5_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_5_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP2,
        4 => Register::D,
        5 => Register::IX,
        6 => Register::IY,
        7 => Register::SP,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_6_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_6_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_6_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A,
        1 => Register::B,
        2 => Register::CCR,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_7_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_7_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_7_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A,
        1 => Register::B,
        2 => Register::CCR,
        3 => Register::TMP3L,
        4 => Register::B,
        5 => Register::IXL,
        6 => Register::IYL,
        7 => Register::SPL,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_8_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_8_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_8_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A,
        1 => Register::B,
        2 => Register::CCRH,
        3 => Register::TMP3H,
        4 => Register::B,
        5 => Register::IXH,
        6 => Register::IYH,
        7 => Register::SPH,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_9_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_9_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_9_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        2 => Register::CCRW,
        3 => Register::TMP3,
        4 => Register::D,
        5 => Register::IX,
        6 => Register::IY,
        7 => Register::SP,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_10_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_10_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_10_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP3,
        4 => Register::D,
        5 => Register::IX,
        6 => Register::IY,
        7 => Register::SP,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_11_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_11_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_11_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A,
        1 => Register::B,
        2 => Register::CCR,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_12_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_12_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_12_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP3L,
        4 => Register::B,
        5 => Register::IXL,
        6 => Register::IYL,
        7 => Register::SPL,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_13_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_13_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_13_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP2,
        4 => Register::D,
        5 => Register::IX,
        6 => Register::IY,
        7 => Register::SP,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_14_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_14_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_14_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP2H,
        5 => Register::IXH,
        6 => Register::IYH,
        7 => Register::SPH,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_15_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_15_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_15_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP2L,
        5 => Register::IXL,
        6 => Register::IYL,
        7 => Register::SPL,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_16_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_16_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_16_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP3L,
        5 => Register::IXL,
        6 => Register::IYL,
        7 => Register::SPL,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_17_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_17_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_17_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP3H,
        5 => Register::IXH,
        6 => Register::IYH,
        7 => Register::SPH,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_18_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_18_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_18_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP3,
        5 => Register::IX,
        6 => Register::IY,
        7 => Register::SP,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_19_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_19_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_19_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP2H,
        4 => Register::A,
        5 => Register::IXH,
        6 => Register::IYH,
        7 => Register::SPH,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_20_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_20_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_20_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP2L,
        4 => Register::B,
        5 => Register::IXL,
        6 => Register::IYL,
        7 => Register::SPL,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_21_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_21_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_21_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A,
        1 => Register::B,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_22_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_22_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_22_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::D,
        1 => Register::IX,
        2 => Register::IY,
        3 => Register::SP,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_2_display<T>(hex: bool, num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_2_value(num);
    let value = i128::try_from(value).unwrap();
    DisplayElement::Number(hex, value)
}
fn meaning_2_value<T>(num: T) -> i8
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => 1,
        1 => 2,
        2 => 3,
        3 => 4,
        4 => 5,
        5 => 6,
        6 => 7,
        7 => 8,
        8 => -8,
        9 => -7,
        10 => -6,
        11 => -5,
        12 => -4,
        13 => -3,
        14 => -2,
        15 => -1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op8(u8);
impl TokenField_op8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op7_4(u8);
impl TokenField_op7_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op6_4(u8);
impl TokenField_op6_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_nIndex(u8);
impl TokenField_nIndex {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op0_0(u8);
impl TokenField_op0_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_trapnum(u8);
impl TokenField_trapnum {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rr7_6(u8);
impl TokenField_rr7_6 {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rr7_6a(u8);
impl TokenField_rr7_6a {
    fn execution(&self) -> Register {
        meaning_1_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_xb5_5(u8);
impl TokenField_xb5_5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_nn4_0(i8);
impl TokenField_nn4_0 {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_xb7_5(u8);
impl TokenField_xb7_5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rr4_3(u8);
impl TokenField_rr4_3 {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_xb2_2(u8);
impl TokenField_xb2_2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_xb2_1(u8);
impl TokenField_xb2_1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_z1_1(u8);
impl TokenField_z1_1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_s0_0(u8);
impl TokenField_s0_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_ss0_0(i8);
impl TokenField_ss0_0 {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_xb2_0(u8);
impl TokenField_xb2_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_p4_4(u8);
impl TokenField_p4_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_decrement3_3(u8);
impl TokenField_decrement3_3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_nn3_0(i8);
impl TokenField_nn3_0 {
    fn execution(&self) -> i8 {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.execution()).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(false, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_aa1_0(u8);
impl TokenField_aa1_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_aa0_0(u8);
impl TokenField_aa0_0 {
    fn execution(&self) -> Register {
        meaning_3_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_3_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_notUsed7_7(u8);
impl TokenField_notUsed7_7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_abcdxys6_4(u8);
impl TokenField_abcdxys6_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_abc5_4(u8);
impl TokenField_abc5_4 {
    fn execution(&self) -> Register {
        meaning_4_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_4_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_dxys2_0(u8);
impl TokenField_dxys2_0 {
    fn execution(&self) -> Register {
        meaning_5_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_5_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_abcdxys2_0(u8);
impl TokenField_abcdxys2_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_columns7_4(u8);
impl TokenField_columns7_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rows2_0(u8);
impl TokenField_rows2_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rows3_0(u8);
impl TokenField_rows3_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bytes_ABCl_6_4(u8);
impl TokenField_bytes_ABCl_6_4 {
    fn execution(&self) -> Register {
        meaning_6_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_6_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bytes_ABClT3lBXlYlSl_6_4(u8);
impl TokenField_bytes_ABClT3lBXlYlSl_6_4 {
    fn execution(&self) -> Register {
        meaning_7_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_7_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bytes_ABChT3hBXhYhSh_6_4(u8);
impl TokenField_bytes_ABChT3hBXhYhSh_6_4 {
    fn execution(&self) -> Register {
        meaning_8_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_8_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_words_CT3DXYS_6_4(u8);
impl TokenField_words_CT3DXYS_6_4 {
    fn execution(&self) -> Register {
        meaning_9_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_9_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_words_T3DXYS_6_4(u8);
impl TokenField_words_T3DXYS_6_4 {
    fn execution(&self) -> Register {
        meaning_10_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_10_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bytes_ABCl_2_0(u8);
impl TokenField_bytes_ABCl_2_0 {
    fn execution(&self) -> Register {
        meaning_11_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_11_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bytes_T3lDlXlYlSl_6_4(u8);
impl TokenField_bytes_T3lDlXlYlSl_6_4 {
    fn execution(&self) -> Register {
        meaning_12_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_12_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_words_T2DXYS_2_0(u8);
impl TokenField_words_T2DXYS_2_0 {
    fn execution(&self) -> Register {
        meaning_13_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_13_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bytes_T2h_XhYhSh_2_0(u8);
impl TokenField_bytes_T2h_XhYhSh_2_0 {
    fn execution(&self) -> Register {
        meaning_14_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_14_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bytes_T2l_XlYlSl_2_0(u8);
impl TokenField_bytes_T2l_XlYlSl_2_0 {
    fn execution(&self) -> Register {
        meaning_15_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_15_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bytes_T3l_XlYlSl_6_4(u8);
impl TokenField_bytes_T3l_XlYlSl_6_4 {
    fn execution(&self) -> Register {
        meaning_16_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_16_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bytes_T3h_XhYhSh_6_4(u8);
impl TokenField_bytes_T3h_XhYhSh_6_4 {
    fn execution(&self) -> Register {
        meaning_17_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_17_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_words_T3_XYS_6_4(u8);
impl TokenField_words_T3_XYS_6_4 {
    fn execution(&self) -> Register {
        meaning_18_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_18_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bytes_T2hDhXhYhSh_2_0(u8);
impl TokenField_bytes_T2hDhXhYhSh_2_0 {
    fn execution(&self) -> Register {
        meaning_19_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_19_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bytes_T2lDlXlYlSl_2_0(u8);
impl TokenField_bytes_T2lDlXlYlSl_2_0 {
    fn execution(&self) -> Register {
        meaning_20_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_20_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op16(u16);
impl TokenField_op16 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op15_13(u8);
impl TokenField_op15_13 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sign12_12(i8);
impl TokenField_sign12_12 {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_not_used11(u8);
impl TokenField_not_used11 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_size10_10(u8);
impl TokenField_size10_10 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_byte9_8(u8);
impl TokenField_byte9_8 {
    fn execution(&self) -> Register {
        meaning_21_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_21_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_word9_8(u8);
impl TokenField_word9_8 {
    fn execution(&self) -> Register {
        meaning_22_value(self.0)
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_22_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rr7_0(u8);
impl TokenField_rr7_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_imm8(u8);
impl TokenField_imm8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_simm8(i8);
impl TokenField_simm8 {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rel(i8);
impl TokenField_rel {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_imm16(u16);
impl TokenField_imm16 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_imm16p(u8);
impl TokenField_imm16p {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_imm16e(u8);
impl TokenField_imm16e {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_imm16ev(u16);
impl TokenField_imm16ev {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_imm16rv(u16);
impl TokenField_imm16rv {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_imm16pv(u16);
impl TokenField_imm16pv {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_simm16(i16);
impl TokenField_simm16 {
    fn execution(&self) -> i16 {
        self.0
    }
    fn disassembly(&self) -> i128 {
        i128::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
struct TokenParser<const LEN: usize>([u8; LEN]);
impl<const LEN: usize> MemoryRead for TokenParser<LEN> {
    type AddressType = usize;
    fn read(
        &self,
        addr: Self::AddressType,
        buf: &mut [u8],
    ) -> Result<(), MemoryReadError<Self::AddressType>> {
        let end = addr + buf.len();
        self.0
            .get(addr..end)
            .map(|src| buf.copy_from_slice(src))
            .ok_or(MemoryReadError::UnableToReadMemory(addr, end))
    }
}
impl<const LEN: usize> TokenParser<LEN> {
    fn new(data: &[u8]) -> Option<Self> {
        let token_slice: &[u8] = data.get(..LEN)?;
        let token_data = <[u8; LEN]>::try_from(token_slice).unwrap();
        Some(Self(token_data))
    }
    fn TokenFieldop8(&self) -> TokenField_op8 {
        let inner_value = self.read_u8::<true>(0, 0, 8).unwrap();
        TokenField_op8(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldop7_4(&self) -> TokenField_op7_4 {
        let inner_value = self.read_u8::<true>(0, 4, 4).unwrap();
        TokenField_op7_4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldop6_4(&self) -> TokenField_op6_4 {
        let inner_value = self.read_u8::<true>(0, 4, 3).unwrap();
        TokenField_op6_4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldnIndex(&self) -> TokenField_nIndex {
        let inner_value = self.read_u8::<true>(0, 1, 3).unwrap();
        TokenField_nIndex(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldop0_0(&self) -> TokenField_op0_0 {
        let inner_value = self.read_u8::<true>(0, 0, 1).unwrap();
        TokenField_op0_0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldtrapnum(&self) -> TokenField_trapnum {
        let inner_value = self.read_u8::<true>(0, 0, 8).unwrap();
        TokenField_trapnum(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldrr7_6(&self) -> TokenField_rr7_6 {
        let inner_value = self.read_u8::<true>(0, 6, 2).unwrap();
        TokenField_rr7_6(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldrr7_6a(&self) -> TokenField_rr7_6a {
        let inner_value = self.read_u8::<true>(0, 6, 2).unwrap();
        TokenField_rr7_6a(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldxb5_5(&self) -> TokenField_xb5_5 {
        let inner_value = self.read_u8::<true>(0, 5, 1).unwrap();
        TokenField_xb5_5(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldnn4_0(&self) -> TokenField_nn4_0 {
        let inner_value = self.read_i8::<true>(0, 0, 5).unwrap();
        TokenField_nn4_0(i8::try_from(inner_value).unwrap())
    }
    fn TokenFieldxb7_5(&self) -> TokenField_xb7_5 {
        let inner_value = self.read_u8::<true>(0, 5, 3).unwrap();
        TokenField_xb7_5(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldrr4_3(&self) -> TokenField_rr4_3 {
        let inner_value = self.read_u8::<true>(0, 3, 2).unwrap();
        TokenField_rr4_3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldxb2_2(&self) -> TokenField_xb2_2 {
        let inner_value = self.read_u8::<true>(0, 2, 1).unwrap();
        TokenField_xb2_2(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldxb2_1(&self) -> TokenField_xb2_1 {
        let inner_value = self.read_u8::<true>(0, 1, 2).unwrap();
        TokenField_xb2_1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldz1_1(&self) -> TokenField_z1_1 {
        let inner_value = self.read_u8::<true>(0, 1, 1).unwrap();
        TokenField_z1_1(u8::try_from(inner_value).unwrap())
    }
    fn TokenFields0_0(&self) -> TokenField_s0_0 {
        let inner_value = self.read_u8::<true>(0, 0, 1).unwrap();
        TokenField_s0_0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldss0_0(&self) -> TokenField_ss0_0 {
        let inner_value = self.read_i8::<true>(0, 0, 1).unwrap();
        TokenField_ss0_0(i8::try_from(inner_value).unwrap())
    }
    fn TokenFieldxb2_0(&self) -> TokenField_xb2_0 {
        let inner_value = self.read_u8::<true>(0, 0, 3).unwrap();
        TokenField_xb2_0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldp4_4(&self) -> TokenField_p4_4 {
        let inner_value = self.read_u8::<true>(0, 4, 1).unwrap();
        TokenField_p4_4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFielddecrement3_3(&self) -> TokenField_decrement3_3 {
        let inner_value = self.read_u8::<true>(0, 3, 1).unwrap();
        TokenField_decrement3_3(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldnn3_0(&self) -> TokenField_nn3_0 {
        let inner_value = self.read_i8::<true>(0, 0, 4).unwrap();
        TokenField_nn3_0(i8::try_from(inner_value).unwrap())
    }
    fn TokenFieldaa1_0(&self) -> TokenField_aa1_0 {
        let inner_value = self.read_u8::<true>(0, 0, 2).unwrap();
        TokenField_aa1_0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldaa0_0(&self) -> TokenField_aa0_0 {
        let inner_value = self.read_u8::<true>(0, 0, 1).unwrap();
        TokenField_aa0_0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldnotUsed7_7(&self) -> TokenField_notUsed7_7 {
        let inner_value = self.read_u8::<true>(0, 7, 1).unwrap();
        TokenField_notUsed7_7(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldabcdxys6_4(&self) -> TokenField_abcdxys6_4 {
        let inner_value = self.read_u8::<true>(0, 4, 3).unwrap();
        TokenField_abcdxys6_4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldabc5_4(&self) -> TokenField_abc5_4 {
        let inner_value = self.read_u8::<true>(0, 4, 2).unwrap();
        TokenField_abc5_4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFielddxys2_0(&self) -> TokenField_dxys2_0 {
        let inner_value = self.read_u8::<true>(0, 0, 3).unwrap();
        TokenField_dxys2_0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldabcdxys2_0(&self) -> TokenField_abcdxys2_0 {
        let inner_value = self.read_u8::<true>(0, 0, 3).unwrap();
        TokenField_abcdxys2_0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldcolumns7_4(&self) -> TokenField_columns7_4 {
        let inner_value = self.read_u8::<true>(0, 4, 4).unwrap();
        TokenField_columns7_4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldrows2_0(&self) -> TokenField_rows2_0 {
        let inner_value = self.read_u8::<true>(0, 0, 3).unwrap();
        TokenField_rows2_0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldrows3_0(&self) -> TokenField_rows3_0 {
        let inner_value = self.read_u8::<true>(0, 0, 4).unwrap();
        TokenField_rows3_0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbytes_ABCl_6_4(&self) -> TokenField_bytes_ABCl_6_4 {
        let inner_value = self.read_u8::<true>(0, 4, 3).unwrap();
        TokenField_bytes_ABCl_6_4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbytes_ABClT3lBXlYlSl_6_4(
        &self,
    ) -> TokenField_bytes_ABClT3lBXlYlSl_6_4 {
        let inner_value = self.read_u8::<true>(0, 4, 3).unwrap();
        TokenField_bytes_ABClT3lBXlYlSl_6_4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbytes_ABChT3hBXhYhSh_6_4(
        &self,
    ) -> TokenField_bytes_ABChT3hBXhYhSh_6_4 {
        let inner_value = self.read_u8::<true>(0, 4, 3).unwrap();
        TokenField_bytes_ABChT3hBXhYhSh_6_4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldwords_CT3DXYS_6_4(&self) -> TokenField_words_CT3DXYS_6_4 {
        let inner_value = self.read_u8::<true>(0, 4, 3).unwrap();
        TokenField_words_CT3DXYS_6_4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldwords_T3DXYS_6_4(&self) -> TokenField_words_T3DXYS_6_4 {
        let inner_value = self.read_u8::<true>(0, 4, 3).unwrap();
        TokenField_words_T3DXYS_6_4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbytes_ABCl_2_0(&self) -> TokenField_bytes_ABCl_2_0 {
        let inner_value = self.read_u8::<true>(0, 0, 3).unwrap();
        TokenField_bytes_ABCl_2_0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbytes_T3lDlXlYlSl_6_4(
        &self,
    ) -> TokenField_bytes_T3lDlXlYlSl_6_4 {
        let inner_value = self.read_u8::<true>(0, 4, 3).unwrap();
        TokenField_bytes_T3lDlXlYlSl_6_4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldwords_T2DXYS_2_0(&self) -> TokenField_words_T2DXYS_2_0 {
        let inner_value = self.read_u8::<true>(0, 0, 3).unwrap();
        TokenField_words_T2DXYS_2_0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbytes_T2h_XhYhSh_2_0(
        &self,
    ) -> TokenField_bytes_T2h_XhYhSh_2_0 {
        let inner_value = self.read_u8::<true>(0, 0, 3).unwrap();
        TokenField_bytes_T2h_XhYhSh_2_0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbytes_T2l_XlYlSl_2_0(
        &self,
    ) -> TokenField_bytes_T2l_XlYlSl_2_0 {
        let inner_value = self.read_u8::<true>(0, 0, 3).unwrap();
        TokenField_bytes_T2l_XlYlSl_2_0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbytes_T3l_XlYlSl_6_4(
        &self,
    ) -> TokenField_bytes_T3l_XlYlSl_6_4 {
        let inner_value = self.read_u8::<true>(0, 4, 3).unwrap();
        TokenField_bytes_T3l_XlYlSl_6_4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbytes_T3h_XhYhSh_6_4(
        &self,
    ) -> TokenField_bytes_T3h_XhYhSh_6_4 {
        let inner_value = self.read_u8::<true>(0, 4, 3).unwrap();
        TokenField_bytes_T3h_XhYhSh_6_4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldwords_T3_XYS_6_4(&self) -> TokenField_words_T3_XYS_6_4 {
        let inner_value = self.read_u8::<true>(0, 4, 3).unwrap();
        TokenField_words_T3_XYS_6_4(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbytes_T2hDhXhYhSh_2_0(
        &self,
    ) -> TokenField_bytes_T2hDhXhYhSh_2_0 {
        let inner_value = self.read_u8::<true>(0, 0, 3).unwrap();
        TokenField_bytes_T2hDhXhYhSh_2_0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbytes_T2lDlXlYlSl_2_0(
        &self,
    ) -> TokenField_bytes_T2lDlXlYlSl_2_0 {
        let inner_value = self.read_u8::<true>(0, 0, 3).unwrap();
        TokenField_bytes_T2lDlXlYlSl_2_0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldop16(&self) -> TokenField_op16 {
        let inner_value = self.read_u16::<true>(0, 0, 16).unwrap();
        TokenField_op16(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldop15_13(&self) -> TokenField_op15_13 {
        let inner_value = self.read_u8::<true>(0, 5, 3).unwrap();
        TokenField_op15_13(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsign12_12(&self) -> TokenField_sign12_12 {
        let inner_value = self.read_i8::<true>(0, 4, 1).unwrap();
        TokenField_sign12_12(i8::try_from(inner_value).unwrap())
    }
    fn TokenFieldnot_used11(&self) -> TokenField_not_used11 {
        let inner_value = self.read_u8::<true>(0, 3, 1).unwrap();
        TokenField_not_used11(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsize10_10(&self) -> TokenField_size10_10 {
        let inner_value = self.read_u8::<true>(0, 2, 1).unwrap();
        TokenField_size10_10(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldbyte9_8(&self) -> TokenField_byte9_8 {
        let inner_value = self.read_u8::<true>(0, 0, 2).unwrap();
        TokenField_byte9_8(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldword9_8(&self) -> TokenField_word9_8 {
        let inner_value = self.read_u8::<true>(0, 0, 2).unwrap();
        TokenField_word9_8(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldrr7_0(&self) -> TokenField_rr7_0 {
        let inner_value = self.read_u8::<true>(1, 0, 8).unwrap();
        TokenField_rr7_0(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimm8(&self) -> TokenField_imm8 {
        let inner_value = self.read_u8::<true>(0, 0, 8).unwrap();
        TokenField_imm8(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldsimm8(&self) -> TokenField_simm8 {
        let inner_value = self.read_i8::<true>(0, 0, 8).unwrap();
        TokenField_simm8(i8::try_from(inner_value).unwrap())
    }
    fn TokenFieldrel(&self) -> TokenField_rel {
        let inner_value = self.read_i8::<true>(0, 0, 8).unwrap();
        TokenField_rel(i8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimm16(&self) -> TokenField_imm16 {
        let inner_value = self.read_u16::<true>(0, 0, 16).unwrap();
        TokenField_imm16(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldimm16p(&self) -> TokenField_imm16p {
        let inner_value = self.read_u8::<true>(0, 4, 4).unwrap();
        TokenField_imm16p(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimm16e(&self) -> TokenField_imm16e {
        let inner_value = self.read_u8::<true>(0, 0, 8).unwrap();
        TokenField_imm16e(u8::try_from(inner_value).unwrap())
    }
    fn TokenFieldimm16ev(&self) -> TokenField_imm16ev {
        let inner_value = self.read_u16::<true>(0, 0, 10).unwrap();
        TokenField_imm16ev(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldimm16rv(&self) -> TokenField_imm16rv {
        let inner_value = self.read_u16::<true>(0, 0, 12).unwrap();
        TokenField_imm16rv(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldimm16pv(&self) -> TokenField_imm16pv {
        let inner_value = self.read_u16::<true>(0, 0, 14).unwrap();
        TokenField_imm16pv(u16::try_from(inner_value).unwrap())
    }
    fn TokenFieldsimm16(&self) -> TokenField_simm16 {
        let inner_value = self.read_i16::<true>(0, 0, 16).unwrap();
        TokenField_simm16(i16::try_from(inner_value).unwrap())
    }
}
#[derive(Clone, Copy, Debug)]
pub enum Register {
    A,
    B,
    D,
    IX,
    IY,
    TMP2,
    TMP3,
    TMP1,
    IXH,
    IXL,
    IYH,
    IYL,
    TMP2H,
    TMP2L,
    TMP3H,
    TMP3L,
    TMP1H,
    TMP1L,
    PCE,
    PC,
    SP,
    PCH,
    PCL,
    SPH,
    SPL,
    CCRW,
    CCRH,
    CCR,
    physPage,
    DIRECT,
    PPAGE,
    contextreg,
}
impl core::fmt::Display for Register {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::A => write!(f, "A"),
            Self::B => write!(f, "B"),
            Self::D => write!(f, "D"),
            Self::IX => write!(f, "IX"),
            Self::IY => write!(f, "IY"),
            Self::TMP2 => write!(f, "TMP2"),
            Self::TMP3 => write!(f, "TMP3"),
            Self::TMP1 => write!(f, "TMP1"),
            Self::IXH => write!(f, "IXH"),
            Self::IXL => write!(f, "IXL"),
            Self::IYH => write!(f, "IYH"),
            Self::IYL => write!(f, "IYL"),
            Self::TMP2H => write!(f, "TMP2H"),
            Self::TMP2L => write!(f, "TMP2L"),
            Self::TMP3H => write!(f, "TMP3H"),
            Self::TMP3L => write!(f, "TMP3L"),
            Self::TMP1H => write!(f, "TMP1H"),
            Self::TMP1L => write!(f, "TMP1L"),
            Self::PCE => write!(f, "PCE"),
            Self::PC => write!(f, "PC"),
            Self::SP => write!(f, "SP"),
            Self::PCH => write!(f, "PCH"),
            Self::PCL => write!(f, "PCL"),
            Self::SPH => write!(f, "SPH"),
            Self::SPL => write!(f, "SPL"),
            Self::CCRW => write!(f, "CCRW"),
            Self::CCRH => write!(f, "CCRH"),
            Self::CCR => write!(f, "CCR"),
            Self::physPage => write!(f, "physPage"),
            Self::DIRECT => write!(f, "DIRECT"),
            Self::PPAGE => write!(f, "PPAGE"),
            Self::contextreg => write!(f, "contextreg"),
        }
    }
}
#[derive(Clone, Copy, Debug)]
pub enum DisplayElement {
    Literal(&'static str),
    Register(Register),
    Number(bool, i128),
}
impl core::fmt::Display for DisplayElement {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Literal(lit) => lit.fmt(f),
            Self::Register(reg) => reg.fmt(f),
            Self::Number(hex, value) => match (*hex, value.is_negative()) {
                (true, true) => write!(f, "-0x{:x}", value.abs()),
                (true, false) => write!(f, "0x{:x}", value),
                (false, _) => value.fmt(f),
            },
        }
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:940:1, end:940:2))"]
#[derive(Clone, Debug)]
struct ABX_instructionVar0 {}
impl ABX_instructionVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ABX")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c42 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2u64 as u32;
            let token_parser = <TokenParser<2usize>>::new(tokens)?;
            if token_parser.TokenFieldop16().disassembly() != 6885i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c42(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:945:1, end:945:2))"]
#[derive(Clone, Debug)]
struct ABY_instructionVar1 {}
impl ABY_instructionVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ABY")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c42 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2u64 as u32;
            let token_parser = <TokenParser<2usize>>::new(tokens)?;
            if token_parser.TokenFieldop16().disassembly() != 6637i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c42(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2142:1, end:2142:2))"]
#[derive(Clone, Debug)]
struct CLC_instructionVar2 {}
impl CLC_instructionVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("CLC")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 4350i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2147:1, end:2147:2))"]
#[derive(Clone, Debug)]
struct CLI_instructionVar3 {}
impl CLI_instructionVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("CLI")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 4335i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2232:1, end:2232:2))"]
#[derive(Clone, Debug)]
struct CLV_instructionVar4 {}
impl CLV_instructionVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("CLV")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 4349i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2769:1, end:2769:2))"]
#[derive(Clone, Debug)]
struct DBEQ_instructionVar5 {
    byte9_8: TokenField_byte9_8,
    rel9: Tablerel9,
}
impl DBEQ_instructionVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("DBEQ"),
            DisplayElement::Literal(" "),
            self.byte9_8.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 0i128 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let byte9_8 = token_parser.TokenFieldbyte9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, byte9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2775:1, end:2775:2))"]
#[derive(Clone, Debug)]
struct DBEQ_instructionVar6 {
    word9_8: TokenField_word9_8,
    rel9: Tablerel9,
}
impl DBEQ_instructionVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("DBEQ"),
            DisplayElement::Literal(" "),
            self.word9_8.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 1i128 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let word9_8 = token_parser.TokenFieldword9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, word9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2781:1, end:2781:2))"]
#[derive(Clone, Debug)]
struct DBNE_instructionVar7 {
    byte9_8: TokenField_byte9_8,
    rel9: Tablerel9,
}
impl DBNE_instructionVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("DBNE"),
            DisplayElement::Literal(" "),
            self.byte9_8.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 0i128 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let byte9_8 = token_parser.TokenFieldbyte9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, byte9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2787:1, end:2787:2))"]
#[derive(Clone, Debug)]
struct DBNE_instructionVar8 {
    word9_8: TokenField_word9_8,
    rel9: Tablerel9,
}
impl DBNE_instructionVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("DBNE"),
            DisplayElement::Literal(" "),
            self.word9_8.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 1i128 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let word9_8 = token_parser.TokenFieldword9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, word9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2877:1, end:2877:2))"]
#[derive(Clone, Debug)]
struct DES_instructionVar9 {}
impl DES_instructionVar9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("DES")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 7071i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3226:1, end:3226:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar10 {}
impl EXG_instructionVar10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::CCRH),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c31 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c31(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 8i128 {
                    return None;
                }
                let mut sub_pattern_c54 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldcolumns7_4().disassembly()
                            != 10i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c54(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3238:1, end:3238:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar11 {}
impl EXG_instructionVar11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::A),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::CCRH),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c31 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c31(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 10i128 {
                    return None;
                }
                let mut sub_pattern_c20 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldcolumns7_4().disassembly()
                            != 8i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c20(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3250:1, end:3250:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar12 {}
impl EXG_instructionVar12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::CCRW),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("CCRW"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c36 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c36(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 10i128 {
                    return None;
                }
                let mut sub_pattern_c54 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldcolumns7_4().disassembly()
                            != 10i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c54(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3370:1, end:3370:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar13 {}
impl EXG_instructionVar13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::D),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::TMP1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c31 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c31(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 11i128 {
                    return None;
                }
                let mut sub_pattern_c88 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldcolumns7_4().disassembly()
                            != 12i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c88(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3382:1, end:3382:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar14 {}
impl EXG_instructionVar14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::TMP1),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::D),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c31 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c31(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 12i128 {
                    return None;
                }
                let mut sub_pattern_c71 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldcolumns7_4().disassembly()
                            != 11i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c71(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3684:1, end:3684:2))"]
#[derive(Clone, Debug)]
struct INS_instructionVar15 {}
impl INS_instructionVar15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("INS")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 7041i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5161:1, end:5161:2))"]
#[derive(Clone, Debug)]
struct SEC_instructionVar16 {}
impl SEC_instructionVar16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("SEC")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 5121i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5166:1, end:5166:2))"]
#[derive(Clone, Debug)]
struct SEI_instructionVar17 {}
impl SEI_instructionVar17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("SEI")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 5136i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5171:1, end:5171:2))"]
#[derive(Clone, Debug)]
struct SEV_instructionVar18 {}
impl SEV_instructionVar18 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("SEV")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 5122i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5635:1, end:5635:2))"]
#[derive(Clone, Debug)]
struct TAP_instructionVar19 {}
impl TAP_instructionVar19 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("TAP")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 46850i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5713:1, end:5713:2))"]
#[derive(Clone, Debug)]
struct TFR_instructionVar20 {}
impl TFR_instructionVar20 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("TFR"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::A),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::CCRH),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c31 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c31(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 10i128 {
                    return None;
                }
                let mut sub_pattern_c20 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldcolumns7_4().disassembly()
                            != 0i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c20(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5754:1, end:5754:2))"]
#[derive(Clone, Debug)]
struct TFR_instructionVar21 {}
impl TFR_instructionVar21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("TFR"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::D),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::TMP1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c31 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c31(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 11i128 {
                    return None;
                }
                let mut sub_pattern_c88 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldcolumns7_4().disassembly()
                            != 4i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c88(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5763:1, end:5763:2))"]
#[derive(Clone, Debug)]
struct TFR_instructionVar22 {}
impl TFR_instructionVar22 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("TFR"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::TMP1),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::D),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c31 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c31(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 12i128 {
                    return None;
                }
                let mut sub_pattern_c71 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldcolumns7_4().disassembly()
                            != 3i128
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c71(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5811:1, end:5811:2))"]
#[derive(Clone, Debug)]
struct TPA_instructionVar23 {}
impl TPA_instructionVar23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("TPA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 46880i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5903:1, end:5903:2))"]
#[derive(Clone, Debug)]
struct TSX_instructionVar24 {}
impl TSX_instructionVar24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("TSX")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 46965i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5908:1, end:5908:2))"]
#[derive(Clone, Debug)]
struct TSY_instructionVar25 {}
impl TSY_instructionVar25 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("TSY")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 46966i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5913:1, end:5913:2))"]
#[derive(Clone, Debug)]
struct TXS_instructionVar26 {}
impl TXS_instructionVar26 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("TXS")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 46935i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5918:1, end:5918:2))"]
#[derive(Clone, Debug)]
struct TYS_instructionVar27 {}
impl TYS_instructionVar27 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("TYS")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 46951i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5954:1, end:5954:2))"]
#[derive(Clone, Debug)]
struct XGDX_instructionVar28 {}
impl XGDX_instructionVar28 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("XGDX")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 47045i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5961:1, end:5961:2))"]
#[derive(Clone, Debug)]
struct XGDY_instructionVar29 {}
impl XGDY_instructionVar29 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("XGDY")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 47046i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3175:1, end:3175:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar30 {}
impl EXG_instructionVar30 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::D),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c28 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c28(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 0i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c88 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 12i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c88(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 8i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c88 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 12i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c88(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3189:1, end:3189:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar31 {}
impl EXG_instructionVar31 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::D),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c28 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c28(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 1i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c88 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 12i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c88(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 9i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c88 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 12i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c88(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3202:1, end:3202:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar32 {}
impl EXG_instructionVar32 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::A),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::D),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c28 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c28(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 4i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 8i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 12i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 8i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3214:1, end:3214:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar33 {}
impl EXG_instructionVar33 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::B),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::D),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c28 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c28(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 4i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c37 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 9i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c37(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 12i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c37 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 9i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c37(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3274:1, end:3274:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar34 {
    bytes_ABCl_6_4: TokenField_bytes_ABCl_6_4,
}
impl EXG_instructionVar34 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.bytes_ABCl_6_4.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::CCR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c43 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c43(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 2i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 8i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 9i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 10i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c37 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 9i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c37(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABCl_6_4 = token_parser.TokenFieldbytes_ABCl_6_4();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { bytes_ABCl_6_4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3259:1, end:3259:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar35 {
    bytes_ABCl_6_4: TokenField_bytes_ABCl_6_4,
    bytes_ABCl_2_0: TokenField_bytes_ABCl_2_0,
}
impl EXG_instructionVar35 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.bytes_ABCl_6_4.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.bytes_ABCl_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 0i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 8i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 9i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 1i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 8i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 9i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 8i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 8i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 9i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 9i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 8i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 9i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABCl_6_4 = token_parser.TokenFieldbytes_ABCl_6_4();
        let bytes_ABCl_2_0 = token_parser.TokenFieldbytes_ABCl_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_ABCl_6_4,
                bytes_ABCl_2_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3287:1, end:3287:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar36 {
    bytes_ABCl_2_0: TokenField_bytes_ABCl_2_0,
}
impl EXG_instructionVar36 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::CCR),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.bytes_ABCl_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c43 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c43(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 0i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c54 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c54(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 1i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c54 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c54(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 2i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c54 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c54(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 9i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c54 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c54(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABCl_2_0 = token_parser.TokenFieldbytes_ABCl_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { bytes_ABCl_2_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3302:1, end:3302:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar37 {
    bytes_T3l_XlYlSl_6_4: TokenField_bytes_T3l_XlYlSl_6_4,
}
impl EXG_instructionVar37 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.bytes_T3l_XlYlSl_6_4.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 0i128 {
                    return None;
                }
                let mut sub_pattern_c71 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 =
                            |tokens_param: &[u8], context_param: &mut T| {
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 11i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 13i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 14i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 15i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                None
                            };
                        let ((), (), block_0_len) =
                            block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c71(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_T3l_XlYlSl_6_4 =
            token_parser.TokenFieldbytes_T3l_XlYlSl_6_4();
        let words_T3_XYS_6_4 = token_parser.TokenFieldwords_T3_XYS_6_4();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_T3l_XlYlSl_6_4,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3313:1, end:3313:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar38 {
    bytes_T3h_XhYhSh_6_4: TokenField_bytes_T3h_XhYhSh_6_4,
}
impl EXG_instructionVar38 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.bytes_T3h_XhYhSh_6_4.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 8i128 {
                    return None;
                }
                let mut sub_pattern_c71 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 =
                            |tokens_param: &[u8], context_param: &mut T| {
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 11i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 13i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 14i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 15i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                None
                            };
                        let ((), (), block_0_len) =
                            block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c71(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_T3h_XhYhSh_6_4 =
            token_parser.TokenFieldbytes_T3h_XhYhSh_6_4();
        let words_T3_XYS_6_4 = token_parser.TokenFieldwords_T3_XYS_6_4();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_T3h_XhYhSh_6_4,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3324:1, end:3324:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar39 {
    bytes_T3l_XlYlSl_6_4: TokenField_bytes_T3l_XlYlSl_6_4,
}
impl EXG_instructionVar39 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.bytes_T3l_XlYlSl_6_4.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 1i128 {
                    return None;
                }
                let mut sub_pattern_c71 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 =
                            |tokens_param: &[u8], context_param: &mut T| {
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 11i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 13i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 14i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 15i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                None
                            };
                        let ((), (), block_0_len) =
                            block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c71(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_T3l_XlYlSl_6_4 =
            token_parser.TokenFieldbytes_T3l_XlYlSl_6_4();
        let words_T3_XYS_6_4 = token_parser.TokenFieldwords_T3_XYS_6_4();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_T3l_XlYlSl_6_4,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3335:1, end:3335:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar40 {
    bytes_T3l_XlYlSl_6_4: TokenField_bytes_T3l_XlYlSl_6_4,
}
impl EXG_instructionVar40 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.bytes_T3l_XlYlSl_6_4.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 9i128 {
                    return None;
                }
                let mut sub_pattern_c71 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 =
                            |tokens_param: &[u8], context_param: &mut T| {
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 11i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 13i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 14i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 15i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                None
                            };
                        let ((), (), block_0_len) =
                            block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c71(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_T3l_XlYlSl_6_4 =
            token_parser.TokenFieldbytes_T3l_XlYlSl_6_4();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_T3l_XlYlSl_6_4,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3346:1, end:3346:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar41 {
    bytes_T3lDlXlYlSl_6_4: TokenField_bytes_T3lDlXlYlSl_6_4,
}
impl EXG_instructionVar41 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.bytes_T3lDlXlYlSl_6_4.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::CCR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 2i128 {
                    return None;
                }
                let mut sub_pattern_c71 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 =
                            |tokens_param: &[u8], context_param: &mut T| {
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 11i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 12i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 13i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 14i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 15i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                None
                            };
                        let ((), (), block_0_len) =
                            block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c71(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_T3lDlXlYlSl_6_4 =
            token_parser.TokenFieldbytes_T3lDlXlYlSl_6_4();
        let words_T3DXYS_6_4 = token_parser.TokenFieldwords_T3DXYS_6_4();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_T3lDlXlYlSl_6_4,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3358:1, end:3358:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar42 {
    words_T3DXYS_6_4: TokenField_words_T3DXYS_6_4,
}
impl EXG_instructionVar42 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.words_T3DXYS_6_4.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::CCRW),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 10i128 {
                    return None;
                }
                let mut sub_pattern_c71 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 =
                            |tokens_param: &[u8], context_param: &mut T| {
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 11i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 12i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 13i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 14i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 15i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                None
                            };
                        let ((), (), block_0_len) =
                            block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c71(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let words_T3DXYS_6_4 = token_parser.TokenFieldwords_T3DXYS_6_4();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { words_T3DXYS_6_4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3431:1, end:3431:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar43 {
    bytes_ABCl_6_4: TokenField_bytes_ABCl_6_4,
    bytes_T2hDhXhYhSh_2_0: TokenField_bytes_T2hDhXhYhSh_2_0,
}
impl EXG_instructionVar43 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.bytes_ABCl_6_4.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.bytes_T2hDhXhYhSh_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c61 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c61(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 11i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 8i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 13i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 8i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 14i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 8i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 15i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 8i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABCl_6_4 = token_parser.TokenFieldbytes_ABCl_6_4();
        let bytes_T2hDhXhYhSh_2_0 =
            token_parser.TokenFieldbytes_T2hDhXhYhSh_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_ABCl_6_4,
                bytes_T2hDhXhYhSh_2_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3447:1, end:3447:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar44 {
    bytes_ABCl_6_4: TokenField_bytes_ABCl_6_4,
    bytes_T2lDlXlYlSl_2_0: TokenField_bytes_T2lDlXlYlSl_2_0,
}
impl EXG_instructionVar44 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.bytes_ABCl_6_4.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.bytes_T2lDlXlYlSl_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c61 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c61(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 11i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c37 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 9i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c37(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 13i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c37 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 9i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c37(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 14i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c37 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 9i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c37(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 15i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c37 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 9i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c37(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABCl_6_4 = token_parser.TokenFieldbytes_ABCl_6_4();
        let bytes_T2lDlXlYlSl_2_0 =
            token_parser.TokenFieldbytes_T2lDlXlYlSl_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_ABCl_6_4,
                bytes_T2lDlXlYlSl_2_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3462:1, end:3462:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar45 {
    words_T2DXYS_2_0: TokenField_words_T2DXYS_2_0,
}
impl EXG_instructionVar45 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::CCR),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.words_T2DXYS_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c45 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c45(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 3i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c54 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c54(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 4i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c54 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c54(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 5i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c54 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c54(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 6i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c54 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c54(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 7i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c54 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c54(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let words_T2DXYS_2_0 = token_parser.TokenFieldwords_T2DXYS_2_0();
        let bytes_T2lDlXlYlSl_2_0 =
            token_parser.TokenFieldbytes_T2lDlXlYlSl_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { words_T2DXYS_2_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3477:1, end:3477:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar46 {
    words_T2DXYS_2_0: TokenField_words_T2DXYS_2_0,
}
impl EXG_instructionVar46 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::CCRW),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.words_T2DXYS_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 11i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c54 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c54(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 12i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c54 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c54(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 13i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c54 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c54(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 14i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c54 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c54(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 15i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c54 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c54(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let words_T2DXYS_2_0 = token_parser.TokenFieldwords_T2DXYS_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { words_T2DXYS_2_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5772:1, end:5772:2))"]
#[derive(Clone, Debug)]
struct TFR_instructionVar47 {
    words_T2DXYS_2_0: TokenField_words_T2DXYS_2_0,
}
impl TFR_instructionVar47 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("TFR"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::CCRW),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.words_T2DXYS_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 11i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c54 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 2i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c54(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 12i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c54 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 2i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c54(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 13i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c54 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 2i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c54(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 14i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c54 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 2i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c54(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 15i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c54 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 2i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c54(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let words_T2DXYS_2_0 = token_parser.TokenFieldwords_T2DXYS_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { words_T2DXYS_2_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5785:1, end:5785:2))"]
#[derive(Clone, Debug)]
struct TFR_instructionVar48 {
    bytes_T2h_XhYhSh_2_0: TokenField_bytes_T2h_XhYhSh_2_0,
}
impl TFR_instructionVar48 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("TFR"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::A),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.bytes_T2h_XhYhSh_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 11i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 0i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 13i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 0i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 14i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 0i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 15i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 0i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_T2h_XhYhSh_2_0 =
            token_parser.TokenFieldbytes_T2h_XhYhSh_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_T2h_XhYhSh_2_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5798:1, end:5798:2))"]
#[derive(Clone, Debug)]
struct TFR_instructionVar49 {
    bytes_T2l_XlYlSl_2_0: TokenField_bytes_T2l_XlYlSl_2_0,
}
impl TFR_instructionVar49 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("TFR"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::A),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.bytes_T2l_XlYlSl_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 11i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c37 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 1i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c37(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 13i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c37 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 1i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c37(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 14i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c37 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 1i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c37(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 15i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c37 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 1i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c37(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_T2l_XlYlSl_2_0 =
            token_parser.TokenFieldbytes_T2l_XlYlSl_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_T2l_XlYlSl_2_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3416:1, end:3416:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar50 {
    bytes_ABCl_6_4: TokenField_bytes_ABCl_6_4,
    words_T2DXYS_2_0: TokenField_words_T2DXYS_2_0,
}
impl EXG_instructionVar50 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.bytes_ABCl_6_4.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.words_T2DXYS_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c56 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c56(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 3i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 8i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 9i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 5i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 8i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 9i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 6i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 8i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 9i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 7i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 8i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 9i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABCl_6_4 = token_parser.TokenFieldbytes_ABCl_6_4();
        let words_T2DXYS_2_0 = token_parser.TokenFieldwords_T2DXYS_2_0();
        let bytes_T2lDlXlYlSl_2_0 =
            token_parser.TokenFieldbytes_T2lDlXlYlSl_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_ABCl_6_4,
                words_T2DXYS_2_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5226:1, end:5226:2))"]
#[derive(Clone, Debug)]
struct SEX_instructionVar51 {
    abc5_4: TokenField_abc5_4,
    dxys2_0: TokenField_dxys2_0,
}
impl SEX_instructionVar51 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("SEX"),
            DisplayElement::Literal(" "),
            self.abc5_4.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.dxys2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 183i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 3i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 0i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 1i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 2i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 4i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 0i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 1i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 2i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 5i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 0i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 1i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 2i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 6i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 0i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 1i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 2i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 7i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 0i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 1i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 2i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let abc5_4 = token_parser.TokenFieldabc5_4();
        let dxys2_0 = token_parser.TokenFielddxys2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { abc5_4, dxys2_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5704:1, end:5704:2))"]
#[derive(Clone, Debug)]
struct TFR_instructionVar52 {
    bytes_ABChT3hBXhYhSh_6_4: TokenField_bytes_ABChT3hBXhYhSh_6_4,
}
impl TFR_instructionVar52 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("TFR"),
            DisplayElement::Literal(" "),
            self.bytes_ABChT3hBXhYhSh_6_4.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 8i128 {
                    return None;
                }
                let mut sub_pattern_c54 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 =
                            |tokens_param: &[u8], context_param: &mut T| {
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 2i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 3i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 5i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 6i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 7i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                None
                            };
                        let ((), (), block_0_len) =
                            block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c54(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABChT3hBXhYhSh_6_4 =
            token_parser.TokenFieldbytes_ABChT3hBXhYhSh_6_4();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_ABChT3hBXhYhSh_6_4,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5722:1, end:5722:2))"]
#[derive(Clone, Debug)]
struct TFR_instructionVar53 {
    words_CT3DXYS_6_4: TokenField_words_CT3DXYS_6_4,
}
impl TFR_instructionVar53 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("TFR"),
            DisplayElement::Literal(" "),
            self.words_CT3DXYS_6_4.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::CCRW),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 10i128 {
                    return None;
                }
                let mut sub_pattern_c54 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 =
                            |tokens_param: &[u8], context_param: &mut T| {
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 2i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 3i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 4i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 5i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 6i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 7i128
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                None
                            };
                        let ((), (), block_0_len) =
                            block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c54(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let words_CT3DXYS_6_4 = token_parser.TokenFieldwords_CT3DXYS_6_4();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { words_CT3DXYS_6_4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5692:1, end:5692:2))"]
#[derive(Clone, Debug)]
struct TFR_instructionVar54 {
    bytes_ABClT3lBXlYlSl_6_4: TokenField_bytes_ABClT3lBXlYlSl_6_4,
}
impl TFR_instructionVar54 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("TFR"),
            DisplayElement::Literal(" "),
            self.bytes_ABClT3lBXlYlSl_6_4.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::CCR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 2i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c37 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 1i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 2i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c37(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 10i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c37 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 1i128
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c37(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABClT3lBXlYlSl_6_4 =
            token_parser.TokenFieldbytes_ABClT3lBXlYlSl_6_4();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_ABClT3lBXlYlSl_6_4,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5678:1, end:5678:2))"]
#[derive(Clone, Debug)]
struct TFR_instructionVar55 {
    bytes_ABClT3lBXlYlSl_6_4: TokenField_bytes_ABClT3lBXlYlSl_6_4,
    bytes_ABCl_2_0: TokenField_bytes_ABCl_2_0,
}
impl TFR_instructionVar55 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("TFR"),
            DisplayElement::Literal(" "),
            self.bytes_ABClT3lBXlYlSl_6_4.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.bytes_ABCl_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c64 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c64(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 0i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 0i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 1i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 1i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 0i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 1i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 2i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 8i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 0i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 1i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 9i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c20 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 0i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 1i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 2i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c20(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABClT3lBXlYlSl_6_4 =
            token_parser.TokenFieldbytes_ABClT3lBXlYlSl_6_4();
        let bytes_ABCl_2_0 = token_parser.TokenFieldbytes_ABCl_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_ABClT3lBXlYlSl_6_4,
                bytes_ABCl_2_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3393:1, end:3393:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar56 {
    words_T3DXYS_6_4: TokenField_words_T3DXYS_6_4,
    words_T2DXYS_2_0: TokenField_words_T2DXYS_2_0,
}
impl EXG_instructionVar56 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.words_T3DXYS_6_4.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.words_T2DXYS_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c58 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c58(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 3i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c71 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 11i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 12i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 13i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 14i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 15i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c71(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 4i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c71 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 11i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 12i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 13i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 14i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 15i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c71(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 5i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c71 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 11i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 13i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 14i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 15i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c71(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 6i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c71 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 11i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 13i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 14i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 15i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c71(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 7i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c71 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 11i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 12i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 13i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 14i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 15i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c71(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 11i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c71 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 11i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 13i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 14i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 15i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c71(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 12i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c88 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 12i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 13i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 14i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 15i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c88(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 13i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c71 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 11i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 12i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 13i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 14i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 15i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c71(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 14i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c71 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 11i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 12i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 13i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 14i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 15i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c71(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 15i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c71 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 11i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 12i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 13i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 14i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 15i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c71(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let words_T3DXYS_6_4 = token_parser.TokenFieldwords_T3DXYS_6_4();
        let words_T2DXYS_2_0 = token_parser.TokenFieldwords_T2DXYS_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                words_T3DXYS_6_4,
                words_T2DXYS_2_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3553:1, end:3553:2))"]
#[derive(Clone, Debug)]
struct IBEQ_instructionVar57 {
    byte9_8: TokenField_byte9_8,
    rel9: Tablerel9,
}
impl IBEQ_instructionVar57 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("IBEQ"),
            DisplayElement::Literal(" "),
            self.byte9_8.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 0i128 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let byte9_8 = token_parser.TokenFieldbyte9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, byte9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3559:1, end:3559:2))"]
#[derive(Clone, Debug)]
struct IBEQ_instructionVar58 {
    word9_8: TokenField_word9_8,
    rel9: Tablerel9,
}
impl IBEQ_instructionVar58 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("IBEQ"),
            DisplayElement::Literal(" "),
            self.word9_8.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 4i128 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 1i128 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let word9_8 = token_parser.TokenFieldword9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, word9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3565:1, end:3565:2))"]
#[derive(Clone, Debug)]
struct IBNE_instructionVar59 {
    byte9_8: TokenField_byte9_8,
    rel9: Tablerel9,
}
impl IBNE_instructionVar59 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("IBNE"),
            DisplayElement::Literal(" "),
            self.byte9_8.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 0i128 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let byte9_8 = token_parser.TokenFieldbyte9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, byte9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3571:1, end:3571:2))"]
#[derive(Clone, Debug)]
struct IBNE_instructionVar60 {
    word9_8: TokenField_word9_8,
    rel9: Tablerel9,
}
impl IBNE_instructionVar60 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("IBNE"),
            DisplayElement::Literal(" "),
            self.word9_8.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 5i128 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 1i128 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let word9_8 = token_parser.TokenFieldword9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, word9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5648:1, end:5648:2))"]
#[derive(Clone, Debug)]
struct TBEQ_instructionVar61 {
    byte9_8: TokenField_byte9_8,
    rel9: Tablerel9,
}
impl TBEQ_instructionVar61 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("TBEQ"),
            DisplayElement::Literal(" "),
            self.byte9_8.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 0i128 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let byte9_8 = token_parser.TokenFieldbyte9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, byte9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5653:1, end:5653:2))"]
#[derive(Clone, Debug)]
struct TBEQ_instructionVar62 {
    word9_8: TokenField_word9_8,
    rel9: Tablerel9,
}
impl TBEQ_instructionVar62 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("TBEQ"),
            DisplayElement::Literal(" "),
            self.word9_8.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 2i128 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 1i128 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let word9_8 = token_parser.TokenFieldword9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, word9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5668:1, end:5668:2))"]
#[derive(Clone, Debug)]
struct TBNE_instructionVar63 {
    byte9_8: TokenField_byte9_8,
    rel9: Tablerel9,
}
impl TBNE_instructionVar63 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("TBNE"),
            DisplayElement::Literal(" "),
            self.byte9_8.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 0i128 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let byte9_8 = token_parser.TokenFieldbyte9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, byte9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5673:1, end:5673:2))"]
#[derive(Clone, Debug)]
struct TBNE_instructionVar64 {
    word9_8: TokenField_word9_8,
    rel9: Tablerel9,
}
impl TBNE_instructionVar64 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("TBNE"),
            DisplayElement::Literal(" "),
            self.word9_8.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 1i128 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let word9_8 = token_parser.TokenFieldword9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, word9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5731:1, end:5731:2))"]
#[derive(Clone, Debug)]
struct TFR_instructionVar65 {
    words_T3DXYS_6_4: TokenField_words_T3DXYS_6_4,
    words_T2DXYS_2_0: TokenField_words_T2DXYS_2_0,
}
impl TFR_instructionVar65 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("TFR"),
            DisplayElement::Literal(" "),
            self.words_T3DXYS_6_4.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.words_T2DXYS_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c58 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c58(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 3i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c71 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c71(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 4i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c71 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c71(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 5i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c71 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c71(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 6i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c71 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c71(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 7i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c71 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c71(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 11i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c71 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c71(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 12i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c88 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c88(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 13i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c71 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c71(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 14i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c71 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c71(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 15i128
                        {
                            return None;
                        }
                        let mut sub_pattern_c71 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i128 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c71(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let words_T3DXYS_6_4 = token_parser.TokenFieldwords_T3DXYS_6_4();
        let words_T2DXYS_2_0 = token_parser.TokenFieldwords_T2DXYS_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                words_T3DXYS_6_4,
                words_T2DXYS_2_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:930:1, end:930:2))"]
#[derive(Clone, Debug)]
struct instructionVar66 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar66 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 24i128 {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_Prefix18_disassembly(tmp)
            .unwrap();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:933:1, end:933:2))"]
#[derive(Clone, Debug)]
struct ABA_instructionVar67 {}
impl ABA_instructionVar67 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ABA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c29 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if context_instance
                .register()
                .read_Prefix18_disassembly()
                .unwrap()
                != 1i128
            {
                return None;
            }
            if token_parser.TokenFieldop8().disassembly() != 6i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c29(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:950:1, end:950:2))"]
#[derive(Clone, Debug)]
struct ADCA_instructionVar68 {
    iopr8i: Tableiopr8i,
}
impl ADCA_instructionVar68 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADCA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 137i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:960:1, end:960:2))"]
#[derive(Clone, Debug)]
struct ADCA_instructionVar69 {
    opr8a_8: Tableopr8a_8,
}
impl ADCA_instructionVar69 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADCA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 153i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:970:1, end:970:2))"]
#[derive(Clone, Debug)]
struct ADCA_instructionVar70 {
    opr16a_8: Tableopr16a_8,
}
impl ADCA_instructionVar70 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADCA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 185i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:980:1, end:980:2))"]
#[derive(Clone, Debug)]
struct ADCA_instructionVar71 {
    indexed1_5: Tableindexed1_5,
}
impl ADCA_instructionVar71 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADCA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 169i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:989:1, end:989:2))"]
#[derive(Clone, Debug)]
struct ADCB_instructionVar72 {
    iopr8i: Tableiopr8i,
}
impl ADCB_instructionVar72 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADCB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 201i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:999:1, end:999:2))"]
#[derive(Clone, Debug)]
struct ADCB_instructionVar73 {
    opr8a_8: Tableopr8a_8,
}
impl ADCB_instructionVar73 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADCB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 217i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1008:1, end:1008:2))"]
#[derive(Clone, Debug)]
struct ADCB_instructionVar74 {
    opr16a_8: Tableopr16a_8,
}
impl ADCB_instructionVar74 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADCB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 249i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1018:1, end:1018:2))"]
#[derive(Clone, Debug)]
struct ADCB_instructionVar75 {
    indexed1_5: Tableindexed1_5,
}
impl ADCB_instructionVar75 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADCB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 233i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1028:1, end:1028:2))"]
#[derive(Clone, Debug)]
struct ADDA_instructionVar76 {
    iopr8i: Tableiopr8i,
}
impl ADDA_instructionVar76 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 139i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1038:1, end:1038:2))"]
#[derive(Clone, Debug)]
struct ADDA_instructionVar77 {
    opr8a_8: Tableopr8a_8,
}
impl ADDA_instructionVar77 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 155i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1047:1, end:1047:2))"]
#[derive(Clone, Debug)]
struct ADDA_instructionVar78 {
    opr16a_8: Tableopr16a_8,
}
impl ADDA_instructionVar78 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 187i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1056:1, end:1056:2))"]
#[derive(Clone, Debug)]
struct ADDA_instructionVar79 {
    indexed1_5: Tableindexed1_5,
}
impl ADDA_instructionVar79 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 171i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1065:1, end:1065:2))"]
#[derive(Clone, Debug)]
struct ADDB_instructionVar80 {
    iopr8i: Tableiopr8i,
}
impl ADDB_instructionVar80 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 203i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1074:1, end:1074:2))"]
#[derive(Clone, Debug)]
struct ADDB_instructionVar81 {
    opr8a_8: Tableopr8a_8,
}
impl ADDB_instructionVar81 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 219i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1083:1, end:1083:2))"]
#[derive(Clone, Debug)]
struct ADDB_instructionVar82 {
    opr16a_8: Tableopr16a_8,
}
impl ADDB_instructionVar82 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 251i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1092:1, end:1092:2))"]
#[derive(Clone, Debug)]
struct ADDB_instructionVar83 {
    indexed1_5: Tableindexed1_5,
}
impl ADDB_instructionVar83 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 235i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1101:1, end:1101:2))"]
#[derive(Clone, Debug)]
struct ADDD_instructionVar84 {
    iopr16i: Tableiopr16i,
}
impl ADDD_instructionVar84 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDD"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr16i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 195i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr16i = if let Some((len, table)) = Tableiopr16i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1110:1, end:1110:2))"]
#[derive(Clone, Debug)]
struct ADDD_instructionVar85 {
    opr8a_16: Tableopr8a_16,
}
impl ADDD_instructionVar85 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDD"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 211i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1119:1, end:1119:2))"]
#[derive(Clone, Debug)]
struct ADDD_instructionVar86 {
    opr16a_16: Tableopr16a_16,
}
impl ADDD_instructionVar86 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDD"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 243i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1128:1, end:1128:2))"]
#[derive(Clone, Debug)]
struct ADDD_instructionVar87 {
    indexed2_5: Tableindexed2_5,
}
impl ADDD_instructionVar87 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDD"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 227i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1357:1, end:1357:2))"]
#[derive(Clone, Debug)]
struct ANDA_instructionVar88 {
    iopr8i: Tableiopr8i,
}
impl ANDA_instructionVar88 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ANDA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 132i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1365:1, end:1365:2))"]
#[derive(Clone, Debug)]
struct ANDA_instructionVar89 {
    opr8a_8: Tableopr8a_8,
}
impl ANDA_instructionVar89 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ANDA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 148i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1373:1, end:1373:2))"]
#[derive(Clone, Debug)]
struct ANDA_instructionVar90 {
    opr16a_8: Tableopr16a_8,
}
impl ANDA_instructionVar90 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ANDA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 180i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1381:1, end:1381:2))"]
#[derive(Clone, Debug)]
struct ANDA_instructionVar91 {
    indexed1_5: Tableindexed1_5,
}
impl ANDA_instructionVar91 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ANDA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 164i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1389:1, end:1389:2))"]
#[derive(Clone, Debug)]
struct ANDB_instructionVar92 {
    iopr8i: Tableiopr8i,
}
impl ANDB_instructionVar92 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ANDB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 196i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1397:1, end:1397:2))"]
#[derive(Clone, Debug)]
struct ANDB_instructionVar93 {
    opr8a_8: Tableopr8a_8,
}
impl ANDB_instructionVar93 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ANDB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 212i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1405:1, end:1405:2))"]
#[derive(Clone, Debug)]
struct ANDB_instructionVar94 {
    opr16a_8: Tableopr16a_8,
}
impl ANDB_instructionVar94 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ANDB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 244i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1413:1, end:1413:2))"]
#[derive(Clone, Debug)]
struct ANDB_instructionVar95 {
    indexed1_5: Tableindexed1_5,
}
impl ANDB_instructionVar95 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ANDB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 228i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1421:1, end:1421:2))"]
#[derive(Clone, Debug)]
struct ANDCC_instructionVar96 {
    iopr8i: Tableiopr8i,
}
impl ANDCC_instructionVar96 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ANDCC"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 16i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1506:1, end:1506:2))"]
#[derive(Clone, Debug)]
struct ASL_instructionVar97 {
    opr16a_8: Tableopr16a_8,
}
impl ASL_instructionVar97 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ASL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 120i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1517:1, end:1517:2))"]
#[derive(Clone, Debug)]
struct ASL_instructionVar98 {
    indexed1_5: Tableindexed1_5,
}
impl ASL_instructionVar98 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ASL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 104i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1528:1, end:1528:2))"]
#[derive(Clone, Debug)]
struct ASLA_instructionVar99 {}
impl ASLA_instructionVar99 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ASLA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 72i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1537:1, end:1537:2))"]
#[derive(Clone, Debug)]
struct ASLB_instructionVar100 {}
impl ASLB_instructionVar100 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ASLB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 88i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1546:1, end:1546:2))"]
#[derive(Clone, Debug)]
struct ASLD_instructionVar101 {}
impl ASLD_instructionVar101 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ASLD")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 89i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1603:1, end:1603:2))"]
#[derive(Clone, Debug)]
struct ASR_instructionVar102 {
    opr16a_8: Tableopr16a_8,
}
impl ASR_instructionVar102 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ASR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 119i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1614:1, end:1614:2))"]
#[derive(Clone, Debug)]
struct ASR_instructionVar103 {
    indexed1_5: Tableindexed1_5,
}
impl ASR_instructionVar103 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ASR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 103i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1625:1, end:1625:2))"]
#[derive(Clone, Debug)]
struct ASRA_instructionVar104 {}
impl ASRA_instructionVar104 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ASRA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 71i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1634:1, end:1634:2))"]
#[derive(Clone, Debug)]
struct ASRB_instructionVar105 {}
impl ASRB_instructionVar105 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ASRB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 87i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1691:1, end:1691:2))"]
#[derive(Clone, Debug)]
struct BCC_instructionVar106 {
    rel8: Tablerel8,
}
impl BCC_instructionVar106 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BCC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 36i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1696:1, end:1696:2))"]
#[derive(Clone, Debug)]
struct BCLR_instructionVar107 {
    opr8a_8: Tableopr8a_8,
    msk8: Tablemsk8,
}
impl BCLR_instructionVar107 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BCLR"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c38 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 77i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c38(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8, msk8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1706:1, end:1706:2))"]
#[derive(Clone, Debug)]
struct BCLR_instructionVar108 {
    opr16a_8: Tableopr16a_8,
    msk8: Tablemsk8,
}
impl BCLR_instructionVar108 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BCLR"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c38 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 29i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c38(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8, msk8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1716:1, end:1716:2))"]
#[derive(Clone, Debug)]
struct BCLR_instructionVar109 {
    indexed1_3: Tableindexed1_3,
    msk8: Tablemsk8,
}
impl BCLR_instructionVar109 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BCLR"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c40 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 13i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c40(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_3 = if let Some((len, table)) = Tableindexed1_3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_3, msk8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1726:1, end:1726:2))"]
#[derive(Clone, Debug)]
struct BCS_instructionVar110 {
    rel8: Tablerel8,
}
impl BCS_instructionVar110 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BCS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 37i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1731:1, end:1731:2))"]
#[derive(Clone, Debug)]
struct BEQ_instructionVar111 {
    rel8: Tablerel8,
}
impl BEQ_instructionVar111 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BEQ"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 39i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1736:1, end:1736:2))"]
#[derive(Clone, Debug)]
struct BGE_instructionVar112 {
    rel8: Tablerel8,
}
impl BGE_instructionVar112 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BGE"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 44i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1742:1, end:1742:2))"]
#[derive(Clone, Debug)]
struct BGND_instructionVar113 {}
impl BGND_instructionVar113 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("BGND")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1751:1, end:1751:2))"]
#[derive(Clone, Debug)]
struct BGT_instructionVar114 {
    rel8: Tablerel8,
}
impl BGT_instructionVar114 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BGT"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 46i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1756:1, end:1756:2))"]
#[derive(Clone, Debug)]
struct BHI_instructionVar115 {
    rel8: Tablerel8,
}
impl BHI_instructionVar115 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BHI"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 34i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1763:1, end:1763:2))"]
#[derive(Clone, Debug)]
struct BITA_instructionVar116 {
    iopr8i: Tableiopr8i,
}
impl BITA_instructionVar116 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BITA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 133i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1771:1, end:1771:2))"]
#[derive(Clone, Debug)]
struct BITA_instructionVar117 {
    opr8a_8: Tableopr8a_8,
}
impl BITA_instructionVar117 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BITA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 149i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1779:1, end:1779:2))"]
#[derive(Clone, Debug)]
struct BITA_instructionVar118 {
    opr16a_8: Tableopr16a_8,
}
impl BITA_instructionVar118 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BITA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 181i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1787:1, end:1787:2))"]
#[derive(Clone, Debug)]
struct BITA_instructionVar119 {
    indexed1_5: Tableindexed1_5,
}
impl BITA_instructionVar119 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BITA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 165i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1795:1, end:1795:2))"]
#[derive(Clone, Debug)]
struct BITB_instructionVar120 {
    iopr8i: Tableiopr8i,
}
impl BITB_instructionVar120 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BITB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 197i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1803:1, end:1803:2))"]
#[derive(Clone, Debug)]
struct BITB_instructionVar121 {
    opr8a_8: Tableopr8a_8,
}
impl BITB_instructionVar121 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BITB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 213i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1811:1, end:1811:2))"]
#[derive(Clone, Debug)]
struct BITB_instructionVar122 {
    opr16a_8: Tableopr16a_8,
}
impl BITB_instructionVar122 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BITB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 245i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1819:1, end:1819:2))"]
#[derive(Clone, Debug)]
struct BITB_instructionVar123 {
    indexed1_5: Tableindexed1_5,
}
impl BITB_instructionVar123 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BITB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 229i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1908:1, end:1908:2))"]
#[derive(Clone, Debug)]
struct BLE_instructionVar124 {
    rel8: Tablerel8,
}
impl BLE_instructionVar124 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BLE"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 47i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1915:1, end:1915:2))"]
#[derive(Clone, Debug)]
struct BLS_instructionVar125 {
    rel8: Tablerel8,
}
impl BLS_instructionVar125 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BLS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 35i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1920:1, end:1920:2))"]
#[derive(Clone, Debug)]
struct BLT_instructionVar126 {
    rel8: Tablerel8,
}
impl BLT_instructionVar126 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BLT"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 45i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1925:1, end:1925:2))"]
#[derive(Clone, Debug)]
struct BMI_instructionVar127 {
    rel8: Tablerel8,
}
impl BMI_instructionVar127 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BMI"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 43i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1930:1, end:1930:2))"]
#[derive(Clone, Debug)]
struct BNE_instructionVar128 {
    rel8: Tablerel8,
}
impl BNE_instructionVar128 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BNE"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 38i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1935:1, end:1935:2))"]
#[derive(Clone, Debug)]
struct BPL_instructionVar129 {
    rel8: Tablerel8,
}
impl BPL_instructionVar129 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BPL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 42i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1940:1, end:1940:2))"]
#[derive(Clone, Debug)]
struct BRA_instructionVar130 {
    rel8: Tablerel8,
}
impl BRA_instructionVar130 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BRA"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 32i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1945:1, end:1945:2))"]
#[derive(Clone, Debug)]
struct BRCLR_instructionVar131 {
    opr8a_8: Tableopr8a_8,
    msk8: Tablemsk8,
    rel8: Tablerel8,
}
impl BRCLR_instructionVar131 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BRCLR"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 79i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        let mut block_3_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_3_len = block_3_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_3_len;
        tokens_current =
            &tokens_current[usize::try_from(block_3_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                opr8a_8,
                msk8,
                rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1951:1, end:1951:2))"]
#[derive(Clone, Debug)]
struct BRCLR_instructionVar132 {
    opr16a_8: Tableopr16a_8,
    msk8: Tablemsk8,
    rel8: Tablerel8,
}
impl BRCLR_instructionVar132 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BRCLR"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 31i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        let mut block_3_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_3_len = block_3_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_3_len;
        tokens_current =
            &tokens_current[usize::try_from(block_3_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                opr16a_8,
                msk8,
                rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1957:1, end:1957:2))"]
#[derive(Clone, Debug)]
struct BRCLR_instructionVar133 {
    indexed1_3: Tableindexed1_3,
    msk8: Tablemsk8,
    rel8: Tablerel8,
}
impl BRCLR_instructionVar133 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BRCLR"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 15i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_3 = if let Some((len, table)) = Tableindexed1_3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        let mut block_3_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_3_len = block_3_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_3_len;
        tokens_current =
            &tokens_current[usize::try_from(block_3_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed1_3,
                msk8,
                rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1966:1, end:1966:2))"]
#[derive(Clone, Debug)]
struct BRN_instructionVar134 {
    SkipNextInstr: TableSkipNextInstr,
}
impl BRN_instructionVar134 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BRN"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.SkipNextInstr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 33i128 {
            return None;
        }
        let SkipNextInstr = if let Some((len, table)) =
            TableSkipNextInstr::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SkipNextInstr }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1971:1, end:1971:2))"]
#[derive(Clone, Debug)]
struct BRSET_instructionVar135 {
    opr8a_8: Tableopr8a_8,
    msk8: Tablemsk8,
    rel8: Tablerel8,
}
impl BRSET_instructionVar135 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BRSET"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 78i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        let mut block_3_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_3_len = block_3_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_3_len;
        tokens_current =
            &tokens_current[usize::try_from(block_3_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                opr8a_8,
                msk8,
                rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1977:1, end:1977:2))"]
#[derive(Clone, Debug)]
struct BRSET_instructionVar136 {
    opr16a_8: Tableopr16a_8,
    msk8: Tablemsk8,
    rel8: Tablerel8,
}
impl BRSET_instructionVar136 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BRSET"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 30i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        let mut block_3_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_3_len = block_3_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_3_len;
        tokens_current =
            &tokens_current[usize::try_from(block_3_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                opr16a_8,
                msk8,
                rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1983:1, end:1983:2))"]
#[derive(Clone, Debug)]
struct BRSET_instructionVar137 {
    indexed1_3: Tableindexed1_3,
    msk8: Tablemsk8,
    rel8: Tablerel8,
}
impl BRSET_instructionVar137 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BRSET"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 14i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_3 = if let Some((len, table)) = Tableindexed1_3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        let mut block_3_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_3_len = block_3_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_3_len;
        tokens_current =
            &tokens_current[usize::try_from(block_3_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed1_3,
                msk8,
                rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1989:1, end:1989:2))"]
#[derive(Clone, Debug)]
struct BSET_instructionVar138 {
    opr8a_8: Tableopr8a_8,
    msk8: Tablemsk8,
}
impl BSET_instructionVar138 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BSET"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 76i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8, msk8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1998:1, end:1998:2))"]
#[derive(Clone, Debug)]
struct BSET_instructionVar139 {
    opr16a_8: Tableopr16a_8,
    msk8: Tablemsk8,
}
impl BSET_instructionVar139 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BSET"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 28i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8, msk8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2007:1, end:2007:2))"]
#[derive(Clone, Debug)]
struct BSET_instructionVar140 {
    indexed1_3: Tableindexed1_3,
    msk8: Tablemsk8,
}
impl BSET_instructionVar140 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BSET"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 12i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_3 = if let Some((len, table)) = Tableindexed1_3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_3, msk8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2016:1, end:2016:2))"]
#[derive(Clone, Debug)]
struct BSR_instructionVar141 {
    rel8: Tablerel8,
}
impl BSR_instructionVar141 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BSR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 7i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2061:1, end:2061:2))"]
#[derive(Clone, Debug)]
struct BVC_instructionVar142 {
    rel8: Tablerel8,
}
impl BVC_instructionVar142 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BVC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 40i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2066:1, end:2066:2))"]
#[derive(Clone, Debug)]
struct BVS_instructionVar143 {
    rel8: Tablerel8,
}
impl BVS_instructionVar143 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BVS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 41i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2080:1, end:2080:2))"]
#[derive(Clone, Debug)]
struct CALL_instructionVar144 {
    CallDest: TableCallDest,
}
impl CALL_instructionVar144 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CALL"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.CallDest.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 74i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let CallDest = if let Some((len, table)) = TableCallDest::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CallDest }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2096:1, end:2096:2))"]
#[derive(Clone, Debug)]
struct CALL_instructionVar145 {
    indexed2_3: Tableindexed2_3,
    page: Tablepage,
}
impl CALL_instructionVar145 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CALL"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.page.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c43 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 75i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c43(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_3 = if let Some((len, table)) = Tableindexed2_3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let page = if let Some((len, table)) =
            Tablepage::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_3, page }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2113:1, end:2113:2))"]
#[derive(Clone, Debug)]
struct CALL_instructionVar146 {
    indexed0_2: Tableindexed0_2,
}
impl CALL_instructionVar146 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CALL"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed0_2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c37 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 75i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c37(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed0_2 = if let Some((len, table)) = Tableindexed0_2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed0_2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2133:1, end:2133:2))"]
#[derive(Clone, Debug)]
struct CBA_instructionVar147 {}
impl CBA_instructionVar147 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("CBA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if context_instance
                .register()
                .read_Prefix18_disassembly()
                .unwrap()
                != 1i128
            {
                return None;
            }
            if token_parser.TokenFieldop8().disassembly() != 23i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2152:1, end:2152:2))"]
#[derive(Clone, Debug)]
struct CLR_instructionVar148 {
    opr16a_8: Tableopr16a_8,
}
impl CLR_instructionVar148 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CLR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 121i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2161:1, end:2161:2))"]
#[derive(Clone, Debug)]
struct CLR_instructionVar149 {
    indexed1_5: Tableindexed1_5,
}
impl CLR_instructionVar149 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CLR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 105i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2170:1, end:2170:2))"]
#[derive(Clone, Debug)]
struct CLRA_instructionVar150 {}
impl CLRA_instructionVar150 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("CLRA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 135i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2179:1, end:2179:2))"]
#[derive(Clone, Debug)]
struct CLRB_instructionVar151 {}
impl CLRB_instructionVar151 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("CLRB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 199i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2237:1, end:2237:2))"]
#[derive(Clone, Debug)]
struct CMPA_instructionVar152 {
    iopr8i: Tableiopr8i,
}
impl CMPA_instructionVar152 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 129i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2247:1, end:2247:2))"]
#[derive(Clone, Debug)]
struct CMPA_instructionVar153 {
    opr8a_8: Tableopr8a_8,
}
impl CMPA_instructionVar153 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 145i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2257:1, end:2257:2))"]
#[derive(Clone, Debug)]
struct CMPA_instructionVar154 {
    opr16a_8: Tableopr16a_8,
}
impl CMPA_instructionVar154 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 177i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2267:1, end:2267:2))"]
#[derive(Clone, Debug)]
struct CMPA_instructionVar155 {
    indexed1_5: Tableindexed1_5,
}
impl CMPA_instructionVar155 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 161i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2277:1, end:2277:2))"]
#[derive(Clone, Debug)]
struct CMPB_instructionVar156 {
    iopr8i: Tableiopr8i,
}
impl CMPB_instructionVar156 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 193i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2287:1, end:2287:2))"]
#[derive(Clone, Debug)]
struct CMPB_instructionVar157 {
    opr8a_8: Tableopr8a_8,
}
impl CMPB_instructionVar157 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 209i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2297:1, end:2297:2))"]
#[derive(Clone, Debug)]
struct CMPB_instructionVar158 {
    opr16a_8: Tableopr16a_8,
}
impl CMPB_instructionVar158 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 241i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2307:1, end:2307:2))"]
#[derive(Clone, Debug)]
struct CMPB_instructionVar159 {
    indexed1_5: Tableindexed1_5,
}
impl CMPB_instructionVar159 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 225i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2317:1, end:2317:2))"]
#[derive(Clone, Debug)]
struct COM_instructionVar160 {
    opr16a_8: Tableopr16a_8,
}
impl COM_instructionVar160 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("COM"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 113i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2327:1, end:2327:2))"]
#[derive(Clone, Debug)]
struct COM_instructionVar161 {
    indexed1_5: Tableindexed1_5,
}
impl COM_instructionVar161 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("COM"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 97i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2337:1, end:2337:2))"]
#[derive(Clone, Debug)]
struct COMA_instructionVar162 {}
impl COMA_instructionVar162 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("COMA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 65i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2346:1, end:2346:2))"]
#[derive(Clone, Debug)]
struct COMB_instructionVar163 {}
impl COMB_instructionVar163 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("COMB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 81i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2401:1, end:2401:2))"]
#[derive(Clone, Debug)]
struct CPD_instructionVar164 {
    iopr16i: Tableiopr16i,
}
impl CPD_instructionVar164 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 140i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr16i = if let Some((len, table)) = Tableiopr16i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2411:1, end:2411:2))"]
#[derive(Clone, Debug)]
struct CPD_instructionVar165 {
    opr8a_16: Tableopr8a_16,
}
impl CPD_instructionVar165 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 156i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2421:1, end:2421:2))"]
#[derive(Clone, Debug)]
struct CPD_instructionVar166 {
    opr16a_16: Tableopr16a_16,
}
impl CPD_instructionVar166 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 188i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2431:1, end:2431:2))"]
#[derive(Clone, Debug)]
struct CPD_instructionVar167 {
    indexed2_5: Tableindexed2_5,
}
impl CPD_instructionVar167 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 172i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2635:1, end:2635:2))"]
#[derive(Clone, Debug)]
struct CPS_instructionVar168 {
    SkipNext2Bytes: TableSkipNext2Bytes,
}
impl CPS_instructionVar168 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_loc: i128 = 0;
        calc_loc = (i128::try_from(inst_next).unwrap() & 16777215i128);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("CPS"),
            DisplayElement::Literal(" "),
            DisplayElement::Number(true, calc_loc),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_loc: i128 = 0;
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c42 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 143i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c42(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let SkipNext2Bytes = if let Some((len, table)) =
            TableSkipNext2Bytes::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SkipNext2Bytes }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2647:1, end:2647:2))"]
#[derive(Clone, Debug)]
struct CPS_instructionVar169 {
    opr8a_16: Tableopr8a_16,
}
impl CPS_instructionVar169 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 159i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2657:1, end:2657:2))"]
#[derive(Clone, Debug)]
struct CPS_instructionVar170 {
    SkipNext2Bytes: TableSkipNext2Bytes,
}
impl CPS_instructionVar170 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_loc: i128 = 0;
        calc_loc = (i128::try_from(inst_next).unwrap() & 16777215i128);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("CPS"),
            DisplayElement::Literal(" "),
            DisplayElement::Number(true, calc_loc),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_loc: i128 = 0;
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c42 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 191i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c42(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let SkipNext2Bytes = if let Some((len, table)) =
            TableSkipNext2Bytes::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SkipNext2Bytes }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2670:1, end:2670:2))"]
#[derive(Clone, Debug)]
struct CPS_instructionVar171 {
    indexed2_5: Tableindexed2_5,
}
impl CPS_instructionVar171 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 175i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2680:1, end:2680:2))"]
#[derive(Clone, Debug)]
struct CPX_instructionVar172 {
    iopr16i: Tableiopr16i,
}
impl CPX_instructionVar172 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPX"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 142i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr16i = if let Some((len, table)) = Tableiopr16i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2690:1, end:2690:2))"]
#[derive(Clone, Debug)]
struct CPX_instructionVar173 {
    opr8a_16: Tableopr8a_16,
}
impl CPX_instructionVar173 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPX"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 158i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2700:1, end:2700:2))"]
#[derive(Clone, Debug)]
struct CPX_instructionVar174 {
    opr16a_16: Tableopr16a_16,
}
impl CPX_instructionVar174 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPX"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 190i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2710:1, end:2710:2))"]
#[derive(Clone, Debug)]
struct CPX_instructionVar175 {
    indexed2_5: Tableindexed2_5,
}
impl CPX_instructionVar175 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPX"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 174i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2720:1, end:2720:2))"]
#[derive(Clone, Debug)]
struct CPY_instructionVar176 {
    iopr16i: Tableiopr16i,
}
impl CPY_instructionVar176 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPY"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 141i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr16i = if let Some((len, table)) = Tableiopr16i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2730:1, end:2730:2))"]
#[derive(Clone, Debug)]
struct CPY_instructionVar177 {
    opr8a_16: Tableopr8a_16,
}
impl CPY_instructionVar177 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPY"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 157i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2740:1, end:2740:2))"]
#[derive(Clone, Debug)]
struct CPY_instructionVar178 {
    opr16a_16: Tableopr16a_16,
}
impl CPY_instructionVar178 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPY"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 189i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2750:1, end:2750:2))"]
#[derive(Clone, Debug)]
struct CPY_instructionVar179 {
    indexed2_5: Tableindexed2_5,
}
impl CPY_instructionVar179 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPY"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 173i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2760:1, end:2760:2))"]
#[derive(Clone, Debug)]
struct DAA_instructionVar180 {}
impl DAA_instructionVar180 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("DAA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 7i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2793:1, end:2793:2))"]
#[derive(Clone, Debug)]
struct DEC_instructionVar181 {
    opr16a_8: Tableopr16a_8,
}
impl DEC_instructionVar181 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("DEC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 115i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2803:1, end:2803:2))"]
#[derive(Clone, Debug)]
struct DEC_instructionVar182 {
    indexed1_5: Tableindexed1_5,
}
impl DEC_instructionVar182 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("DEC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 99i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2813:1, end:2813:2))"]
#[derive(Clone, Debug)]
struct DECA_instructionVar183 {}
impl DECA_instructionVar183 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("DECA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 67i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2822:1, end:2822:2))"]
#[derive(Clone, Debug)]
struct DECB_instructionVar184 {}
impl DECB_instructionVar184 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("DECB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 83i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2882:1, end:2882:2))"]
#[derive(Clone, Debug)]
struct DEX_instructionVar185 {}
impl DEX_instructionVar185 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("DEX")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 9i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2888:1, end:2888:2))"]
#[derive(Clone, Debug)]
struct DEY_instructionVar186 {}
impl DEY_instructionVar186 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("DEY")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 3i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2894:1, end:2894:2))"]
#[derive(Clone, Debug)]
struct EDIV_instructionVar187 {}
impl EDIV_instructionVar187 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("EDIV")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 17i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2907:1, end:2907:2))"]
#[derive(Clone, Debug)]
struct EDIVS_instructionVar188 {}
impl EDIVS_instructionVar188 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("EDIVS")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 20i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2920:1, end:2920:2))"]
#[derive(Clone, Debug)]
struct EMACS_instructionVar189 {
    opr16a: Tableopr16a,
}
impl EMACS_instructionVar189 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EMACS"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 18i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a = if let Some((len, table)) = Tableopr16a::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2934:1, end:2934:2))"]
#[derive(Clone, Debug)]
struct EMAXD_instructionVar190 {
    indexed2_5: Tableindexed2_5,
}
impl EMAXD_instructionVar190 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EMAXD"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 26i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2947:1, end:2947:2))"]
#[derive(Clone, Debug)]
struct EMAXM_instructionVar191 {
    indexed2_5: Tableindexed2_5,
}
impl EMAXM_instructionVar191 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EMAXM"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 30i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2960:1, end:2960:2))"]
#[derive(Clone, Debug)]
struct EMIND_instructionVar192 {
    indexed2_5: Tableindexed2_5,
}
impl EMIND_instructionVar192 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EMIND"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 27i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2973:1, end:2973:2))"]
#[derive(Clone, Debug)]
struct EMINM_instructionVar193 {
    indexed2_5: Tableindexed2_5,
}
impl EMINM_instructionVar193 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EMINM"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 31i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2986:1, end:2986:2))"]
#[derive(Clone, Debug)]
struct EMUL_instructionVar194 {}
impl EMUL_instructionVar194 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("EMUL")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 19i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2996:1, end:2996:2))"]
#[derive(Clone, Debug)]
struct EMULS_instructionVar195 {}
impl EMULS_instructionVar195 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("EMULS")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 19i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3006:1, end:3006:2))"]
#[derive(Clone, Debug)]
struct EORA_instructionVar196 {
    iopr8i: Tableiopr8i,
}
impl EORA_instructionVar196 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EORA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 136i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3015:1, end:3015:2))"]
#[derive(Clone, Debug)]
struct EORA_instructionVar197 {
    opr8a_8: Tableopr8a_8,
}
impl EORA_instructionVar197 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EORA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 152i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3024:1, end:3024:2))"]
#[derive(Clone, Debug)]
struct EORA_instructionVar198 {
    opr16a_8: Tableopr16a_8,
}
impl EORA_instructionVar198 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EORA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 184i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3033:1, end:3033:2))"]
#[derive(Clone, Debug)]
struct EORA_instructionVar199 {
    indexed1_5: Tableindexed1_5,
}
impl EORA_instructionVar199 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EORA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 168i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3042:1, end:3042:2))"]
#[derive(Clone, Debug)]
struct EORB_instructionVar200 {
    iopr8i: Tableiopr8i,
}
impl EORB_instructionVar200 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EORB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 200i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3051:1, end:3051:2))"]
#[derive(Clone, Debug)]
struct EORB_instructionVar201 {
    opr8a_8: Tableopr8a_8,
}
impl EORB_instructionVar201 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EORB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 216i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3060:1, end:3060:2))"]
#[derive(Clone, Debug)]
struct EORB_instructionVar202 {
    opr16a_8: Tableopr16a_8,
}
impl EORB_instructionVar202 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EORB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 248i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3069:1, end:3069:2))"]
#[derive(Clone, Debug)]
struct EORB_instructionVar203 {
    indexed1_5: Tableindexed1_5,
}
impl EORB_instructionVar203 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EORB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 232i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3166:1, end:3166:2))"]
#[derive(Clone, Debug)]
struct ETBL_instructionVar204 {
    indexed2_1: Tableindexed2_1,
}
impl ETBL_instructionVar204 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ETBL"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 63i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_1 = if let Some((len, table)) = Tableindexed2_1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3492:1, end:3492:2))"]
#[derive(Clone, Debug)]
struct FDIV_instructionVar205 {}
impl FDIV_instructionVar205 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FDIV")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 17i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3577:1, end:3577:2))"]
#[derive(Clone, Debug)]
struct IDIV_instructionVar206 {}
impl IDIV_instructionVar206 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("IDIV")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 16i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3588:1, end:3588:2))"]
#[derive(Clone, Debug)]
struct IDIVS_instructionVar207 {}
impl IDIVS_instructionVar207 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("IDIVS")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 21i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3600:1, end:3600:2))"]
#[derive(Clone, Debug)]
struct INC_instructionVar208 {
    opr16a_8: Tableopr16a_8,
}
impl INC_instructionVar208 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("INC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 114i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3610:1, end:3610:2))"]
#[derive(Clone, Debug)]
struct INC_instructionVar209 {
    indexed1_5: Tableindexed1_5,
}
impl INC_instructionVar209 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("INC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 98i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3620:1, end:3620:2))"]
#[derive(Clone, Debug)]
struct INCA_instructionVar210 {}
impl INCA_instructionVar210 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("INCA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 66i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3629:1, end:3629:2))"]
#[derive(Clone, Debug)]
struct INCB_instructionVar211 {}
impl INCB_instructionVar211 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("INCB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 82i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3689:1, end:3689:2))"]
#[derive(Clone, Debug)]
struct INX_instructionVar212 {}
impl INX_instructionVar212 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("INX")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 8i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3695:1, end:3695:2))"]
#[derive(Clone, Debug)]
struct INY_instructionVar213 {}
impl INY_instructionVar213 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("INY")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3701:1, end:3701:2))"]
#[derive(Clone, Debug)]
struct JMP_instructionVar214 {
    opr16a: Tableopr16a,
}
impl JMP_instructionVar214 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JMP"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c44 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 6i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c44(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a = if let Some((len, table)) = Tableopr16a::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3706:1, end:3706:2))"]
#[derive(Clone, Debug)]
struct JMP_instructionVar215 {
    indexedA_5: TableindexedA_5,
}
impl JMP_instructionVar215 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JMP"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexedA_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 5i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexedA_5 = if let Some((len, table)) = TableindexedA_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexedA_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3711:1, end:3711:2))"]
#[derive(Clone, Debug)]
struct JSR_instructionVar216 {
    opr8a: Tableopr8a,
}
impl JSR_instructionVar216 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JSR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c43 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 23i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c43(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a = if let Some((len, table)) =
            Tableopr8a::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3719:1, end:3719:2))"]
#[derive(Clone, Debug)]
struct JSR_instructionVar217 {
    opr16a: Tableopr16a,
}
impl JSR_instructionVar217 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JSR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c42 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 22i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c42(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a = if let Some((len, table)) = Tableopr16a::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3727:1, end:3727:2))"]
#[derive(Clone, Debug)]
struct JSR_instructionVar218 {
    indexedA_5: TableindexedA_5,
}
impl JSR_instructionVar218 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JSR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexedA_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 21i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexedA_5 = if let Some((len, table)) = TableindexedA_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexedA_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3735:1, end:3735:2))"]
#[derive(Clone, Debug)]
struct LBCC_instructionVar219 {
    rel16: Tablerel16,
}
impl LBCC_instructionVar219 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBCC"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 36i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3740:1, end:3740:2))"]
#[derive(Clone, Debug)]
struct LBCS_instructionVar220 {
    rel16: Tablerel16,
}
impl LBCS_instructionVar220 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBCS"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 37i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3745:1, end:3745:2))"]
#[derive(Clone, Debug)]
struct LBEQ_instructionVar221 {
    rel16: Tablerel16,
}
impl LBEQ_instructionVar221 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBEQ"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 39i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3750:1, end:3750:2))"]
#[derive(Clone, Debug)]
struct LBGE_instructionVar222 {
    rel16: Tablerel16,
}
impl LBGE_instructionVar222 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBGE"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 44i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3755:1, end:3755:2))"]
#[derive(Clone, Debug)]
struct LBGT_instructionVar223 {
    rel16: Tablerel16,
}
impl LBGT_instructionVar223 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBGT"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 46i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3760:1, end:3760:2))"]
#[derive(Clone, Debug)]
struct LBHI_instructionVar224 {
    rel16: Tablerel16,
}
impl LBHI_instructionVar224 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBHI"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 34i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3767:1, end:3767:2))"]
#[derive(Clone, Debug)]
struct LBLE_instructionVar225 {
    rel16: Tablerel16,
}
impl LBLE_instructionVar225 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBLE"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 47i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3774:1, end:3774:2))"]
#[derive(Clone, Debug)]
struct LBLS_instructionVar226 {
    rel16: Tablerel16,
}
impl LBLS_instructionVar226 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBLS"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 35i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3779:1, end:3779:2))"]
#[derive(Clone, Debug)]
struct LBLT_instructionVar227 {
    rel16: Tablerel16,
}
impl LBLT_instructionVar227 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBLT"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 45i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3784:1, end:3784:2))"]
#[derive(Clone, Debug)]
struct LBMI_instructionVar228 {
    rel16: Tablerel16,
}
impl LBMI_instructionVar228 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBMI"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 43i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3789:1, end:3789:2))"]
#[derive(Clone, Debug)]
struct LBNE_instructionVar229 {
    rel16: Tablerel16,
}
impl LBNE_instructionVar229 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBNE"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 38i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3794:1, end:3794:2))"]
#[derive(Clone, Debug)]
struct LBPL_instructionVar230 {
    rel16: Tablerel16,
}
impl LBPL_instructionVar230 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBPL"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 42i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3799:1, end:3799:2))"]
#[derive(Clone, Debug)]
struct LBRA_instructionVar231 {
    rel16: Tablerel16,
}
impl LBRA_instructionVar231 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBRA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 32i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3805:1, end:3805:2))"]
#[derive(Clone, Debug)]
struct LBRN_instructionVar232 {
    rel16: Tablerel16,
}
impl LBRN_instructionVar232 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBRN"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 33i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3809:1, end:3809:2))"]
#[derive(Clone, Debug)]
struct LBVC_instructionVar233 {
    rel16: Tablerel16,
}
impl LBVC_instructionVar233 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBVC"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 40i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3814:1, end:3814:2))"]
#[derive(Clone, Debug)]
struct LBVS_instructionVar234 {
    rel16: Tablerel16,
}
impl LBVS_instructionVar234 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBVS"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 41i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3819:1, end:3819:2))"]
#[derive(Clone, Debug)]
struct LDAA_instructionVar235 {
    iopr8i: Tableiopr8i,
}
impl LDAA_instructionVar235 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LDAA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 134i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3830:1, end:3830:2))"]
#[derive(Clone, Debug)]
struct instructionVar236 {
    GPaged: TableGPaged,
    opr8a_8: Tableopr8a_8,
}
impl instructionVar236 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LDAA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 150i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3839:1, end:3839:2))"]
#[derive(Clone, Debug)]
struct instructionVar237 {
    GPaged: TableGPaged,
    opr16a_8: Tableopr16a_8,
}
impl instructionVar237 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LDAA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 182i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3848:1, end:3848:2))"]
#[derive(Clone, Debug)]
struct instructionVar238 {
    GPaged: TableGPaged,
    indexed1_5: Tableindexed1_5,
}
impl instructionVar238 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LDAA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c56 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 166i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c56(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3857:1, end:3857:2))"]
#[derive(Clone, Debug)]
struct LDAB_instructionVar239 {
    iopr8i: Tableiopr8i,
}
impl LDAB_instructionVar239 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LDAB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 198i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3865:1, end:3865:2))"]
#[derive(Clone, Debug)]
struct instructionVar240 {
    GPaged: TableGPaged,
    opr8a_8: Tableopr8a_8,
}
impl instructionVar240 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LDAB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 214i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3874:1, end:3874:2))"]
#[derive(Clone, Debug)]
struct instructionVar241 {
    GPaged: TableGPaged,
    opr16a_8: Tableopr16a_8,
}
impl instructionVar241 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LDAB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 246i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3883:1, end:3883:2))"]
#[derive(Clone, Debug)]
struct instructionVar242 {
    GPaged: TableGPaged,
    indexed1_5: Tableindexed1_5,
}
impl instructionVar242 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LDAB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c56 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 230i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c56(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3892:1, end:3892:2))"]
#[derive(Clone, Debug)]
struct LDD_instructionVar243 {
    iopr16i: Tableiopr16i,
}
impl LDD_instructionVar243 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 204i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr16i = if let Some((len, table)) = Tableiopr16i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3900:1, end:3900:2))"]
#[derive(Clone, Debug)]
struct instructionVar244 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar244 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 220i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3909:1, end:3909:2))"]
#[derive(Clone, Debug)]
struct instructionVar245 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar245 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 252i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3918:1, end:3918:2))"]
#[derive(Clone, Debug)]
struct instructionVar246 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar246 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 236i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3930:1, end:3930:2))"]
#[derive(Clone, Debug)]
struct LDS_instructionVar247 {
    iopr16i: Tableiopr16i,
}
impl LDS_instructionVar247 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 207i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr16i = if let Some((len, table)) = Tableiopr16i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3938:1, end:3938:2))"]
#[derive(Clone, Debug)]
struct instructionVar248 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar248 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 223i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3947:1, end:3947:2))"]
#[derive(Clone, Debug)]
struct instructionVar249 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar249 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 255i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3956:1, end:3956:2))"]
#[derive(Clone, Debug)]
struct instructionVar250 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar250 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 239i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3965:1, end:3965:2))"]
#[derive(Clone, Debug)]
struct LDX_instructionVar251 {
    iopr16i: Tableiopr16i,
}
impl LDX_instructionVar251 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDX"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 206i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr16i = if let Some((len, table)) = Tableiopr16i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3973:1, end:3973:2))"]
#[derive(Clone, Debug)]
struct instructionVar252 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar252 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDX"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 222i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3982:1, end:3982:2))"]
#[derive(Clone, Debug)]
struct instructionVar253 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar253 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDX"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 254i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3991:1, end:3991:2))"]
#[derive(Clone, Debug)]
struct instructionVar254 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar254 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDX"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 238i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4000:1, end:4000:2))"]
#[derive(Clone, Debug)]
struct LDY_instructionVar255 {
    iopr16i: Tableiopr16i,
}
impl LDY_instructionVar255 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDY"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 205i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr16i = if let Some((len, table)) = Tableiopr16i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4008:1, end:4008:2))"]
#[derive(Clone, Debug)]
struct instructionVar256 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar256 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDY"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 221i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4017:1, end:4017:2))"]
#[derive(Clone, Debug)]
struct instructionVar257 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar257 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDY"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 253i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4026:1, end:4026:2))"]
#[derive(Clone, Debug)]
struct instructionVar258 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar258 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDY"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 237i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4035:1, end:4035:2))"]
#[derive(Clone, Debug)]
struct LEAS_instructionVar259 {
    indexed0_3: Tableindexed0_3,
}
impl LEAS_instructionVar259 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LEAS"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed0_3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 27i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed0_3 = if let Some((len, table)) = Tableindexed0_3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed0_3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4040:1, end:4040:2))"]
#[derive(Clone, Debug)]
struct LEAX_instructionVar260 {
    indexed0_3: Tableindexed0_3,
}
impl LEAX_instructionVar260 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LEAX"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed0_3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 26i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed0_3 = if let Some((len, table)) = Tableindexed0_3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed0_3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4045:1, end:4045:2))"]
#[derive(Clone, Debug)]
struct LEAY_instructionVar261 {
    indexed0_3: Tableindexed0_3,
}
impl LEAY_instructionVar261 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LEAY"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed0_3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 25i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed0_3 = if let Some((len, table)) = Tableindexed0_3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed0_3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4060:1, end:4060:2))"]
#[derive(Clone, Debug)]
struct LSR_instructionVar262 {
    opr16a_8: Tableopr16a_8,
}
impl LSR_instructionVar262 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LSR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 116i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4071:1, end:4071:2))"]
#[derive(Clone, Debug)]
struct LSR_instructionVar263 {
    indexed1_5: Tableindexed1_5,
}
impl LSR_instructionVar263 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LSR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 100i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4082:1, end:4082:2))"]
#[derive(Clone, Debug)]
struct LSRA_instructionVar264 {}
impl LSRA_instructionVar264 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("LSRA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 68i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4091:1, end:4091:2))"]
#[derive(Clone, Debug)]
struct LSRB_instructionVar265 {}
impl LSRB_instructionVar265 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("LSRB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 84i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4100:1, end:4100:2))"]
#[derive(Clone, Debug)]
struct LSRD_instructionVar266 {}
impl LSRD_instructionVar266 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("LSRD")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 73i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4157:1, end:4157:2))"]
#[derive(Clone, Debug)]
struct MAXA_instructionVar267 {
    indexed1_5: Tableindexed1_5,
}
impl MAXA_instructionVar267 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MAXA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 24i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4171:1, end:4171:2))"]
#[derive(Clone, Debug)]
struct MAXM_instructionVar268 {
    indexed1_5: Tableindexed1_5,
}
impl MAXM_instructionVar268 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MAXM"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 28i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4185:1, end:4185:2))"]
#[derive(Clone, Debug)]
struct MEM_instructionVar269 {}
impl MEM_instructionVar269 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("MEM")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4193:1, end:4193:2))"]
#[derive(Clone, Debug)]
struct MINA_instructionVar270 {
    indexed1_5: Tableindexed1_5,
}
impl MINA_instructionVar270 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MINA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 25i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4207:1, end:4207:2))"]
#[derive(Clone, Debug)]
struct MINM_instructionVar271 {
    indexed1_5: Tableindexed1_5,
}
impl MINM_instructionVar271 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MINM"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 29i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4221:1, end:4221:2))"]
#[derive(Clone, Debug)]
struct MOVB_instructionVar272 {
    iopr8i: Tableiopr8i,
    opr16a_8: Tableopr16a_8,
}
impl MOVB_instructionVar272 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 11i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i, opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4232:1, end:4232:2))"]
#[derive(Clone, Debug)]
struct MOVB_instructionVar273 {
    indexed1_1: Tableindexed1_1,
    iopr8i: Tableiopr8i,
}
impl MOVB_instructionVar273 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 8i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_1 = if let Some((len, table)) = Tableindexed1_1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_1, iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4238:1, end:4238:2))"]
#[derive(Clone, Debug)]
struct MOVB_instructionVar274 {
    opr16a_8: Tableopr16a_8,
    op2_opr16a_8: Tableop2_opr16a_8,
}
impl MOVB_instructionVar274 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.op2_opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 12i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let op2_opr16a_8 = if let Some((len, table)) = Tableop2_opr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                opr16a_8,
                op2_opr16a_8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4252:1, end:4252:2))"]
#[derive(Clone, Debug)]
struct MOVB_instructionVar275 {
    indexed1_1: Tableindexed1_1,
    opr16a_8: Tableopr16a_8,
}
impl MOVB_instructionVar275 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 9i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_1 = if let Some((len, table)) = Tableindexed1_1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed1_1,
                opr16a_8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4264:1, end:4264:2))"]
#[derive(Clone, Debug)]
struct MOVB_instructionVar276 {
    indexed1_1: Tableindexed1_1,
    opr16a_8: Tableopr16a_8,
}
impl MOVB_instructionVar276 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 13i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_1 = if let Some((len, table)) = Tableindexed1_1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed1_1,
                opr16a_8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4281:1, end:4281:2))"]
#[derive(Clone, Debug)]
struct MOVB_instructionVar277 {
    indexed1_1: Tableindexed1_1,
    op2_indexed1_1: Tableop2_indexed1_1,
}
impl MOVB_instructionVar277 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.op2_indexed1_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 10i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_1 = if let Some((len, table)) = Tableindexed1_1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let op2_indexed1_1 = if let Some((len, table)) =
            Tableop2_indexed1_1::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed1_1,
                op2_indexed1_1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4292:1, end:4292:2))"]
#[derive(Clone, Debug)]
struct MOVW_instructionVar278 {
    iopr16i: Tableiopr16i,
    opr16a_16: Tableopr16a_16,
}
impl MOVW_instructionVar278 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVW"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr16i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 3i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr16i = if let Some((len, table)) = Tableiopr16i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i, opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4303:1, end:4303:2))"]
#[derive(Clone, Debug)]
struct MOVW_instructionVar279 {
    indexed2_1: Tableindexed2_1,
    iopr16i: Tableiopr16i,
}
impl MOVW_instructionVar279 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVW"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr16i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_1 = if let Some((len, table)) = Tableindexed2_1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let iopr16i = if let Some((len, table)) = Tableiopr16i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed2_1,
                iopr16i,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4309:1, end:4309:2))"]
#[derive(Clone, Debug)]
struct MOVW_instructionVar280 {
    opr16a_16: Tableopr16a_16,
    op2_opr16a_16: Tableop2_opr16a_16,
}
impl MOVW_instructionVar280 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVW"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.op2_opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let op2_opr16a_16 = if let Some((len, table)) =
            Tableop2_opr16a_16::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                opr16a_16,
                op2_opr16a_16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4325:1, end:4325:2))"]
#[derive(Clone, Debug)]
struct MOVW_instructionVar281 {
    indexed2_1: Tableindexed2_1,
    opr16a_16: Tableopr16a_16,
}
impl MOVW_instructionVar281 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVW"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_1 = if let Some((len, table)) = Tableindexed2_1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed2_1,
                opr16a_16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4337:1, end:4337:2))"]
#[derive(Clone, Debug)]
struct MOVW_instructionVar282 {
    indexed2_1: Tableindexed2_1,
    opr16a_16: Tableopr16a_16,
}
impl MOVW_instructionVar282 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVW"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 5i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_1 = if let Some((len, table)) = Tableindexed2_1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed2_1,
                opr16a_16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4354:1, end:4354:2))"]
#[derive(Clone, Debug)]
struct MOVW_instructionVar283 {
    indexed2_1: Tableindexed2_1,
    op2_indexed2_1: Tableop2_indexed2_1,
}
impl MOVW_instructionVar283 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVW"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.op2_indexed2_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 2i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_1 = if let Some((len, table)) = Tableindexed2_1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let op2_indexed2_1 = if let Some((len, table)) =
            Tableop2_indexed2_1::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed2_1,
                op2_indexed2_1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4366:1, end:4366:2))"]
#[derive(Clone, Debug)]
struct MUL_instructionVar284 {}
impl MUL_instructionVar284 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("MUL")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 18i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4372:1, end:4372:2))"]
#[derive(Clone, Debug)]
struct NEG_instructionVar285 {
    opr16a_8: Tableopr16a_8,
}
impl NEG_instructionVar285 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("NEG"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 112i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4383:1, end:4383:2))"]
#[derive(Clone, Debug)]
struct NEG_instructionVar286 {
    indexed1_5: Tableindexed1_5,
}
impl NEG_instructionVar286 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("NEG"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 96i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4394:1, end:4394:2))"]
#[derive(Clone, Debug)]
struct NEGA_instructionVar287 {}
impl NEGA_instructionVar287 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("NEGA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 64i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4404:1, end:4404:2))"]
#[derive(Clone, Debug)]
struct NEGB_instructionVar288 {}
impl NEGB_instructionVar288 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("NEGB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 80i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4464:1, end:4464:2))"]
#[derive(Clone, Debug)]
struct NOP_instructionVar289 {}
impl NOP_instructionVar289 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("NOP")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 167i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4468:1, end:4468:2))"]
#[derive(Clone, Debug)]
struct ORAA_instructionVar290 {
    iopr8i: Tableiopr8i,
}
impl ORAA_instructionVar290 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ORAA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 138i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4476:1, end:4476:2))"]
#[derive(Clone, Debug)]
struct ORAA_instructionVar291 {
    opr8a_8: Tableopr8a_8,
}
impl ORAA_instructionVar291 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ORAA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 154i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4484:1, end:4484:2))"]
#[derive(Clone, Debug)]
struct ORAA_instructionVar292 {
    opr16a_8: Tableopr16a_8,
}
impl ORAA_instructionVar292 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ORAA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 186i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4492:1, end:4492:2))"]
#[derive(Clone, Debug)]
struct ORAA_instructionVar293 {
    indexed1_5: Tableindexed1_5,
}
impl ORAA_instructionVar293 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ORAA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 170i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4500:1, end:4500:2))"]
#[derive(Clone, Debug)]
struct ORAB_instructionVar294 {
    iopr8i: Tableiopr8i,
}
impl ORAB_instructionVar294 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ORAB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 202i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4508:1, end:4508:2))"]
#[derive(Clone, Debug)]
struct ORAB_instructionVar295 {
    opr8a_8: Tableopr8a_8,
}
impl ORAB_instructionVar295 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ORAB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 218i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4516:1, end:4516:2))"]
#[derive(Clone, Debug)]
struct ORAB_instructionVar296 {
    opr16a_8: Tableopr16a_8,
}
impl ORAB_instructionVar296 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ORAB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 250i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4524:1, end:4524:2))"]
#[derive(Clone, Debug)]
struct ORAB_instructionVar297 {
    indexed1_5: Tableindexed1_5,
}
impl ORAB_instructionVar297 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ORAB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 234i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4532:1, end:4532:2))"]
#[derive(Clone, Debug)]
struct ORCC_instructionVar298 {
    iopr8i: Tableiopr8i,
}
impl ORCC_instructionVar298 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ORCC"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 20i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4617:1, end:4617:2))"]
#[derive(Clone, Debug)]
struct PSHA_instructionVar299 {}
impl PSHA_instructionVar299 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PSHA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 54i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4622:1, end:4622:2))"]
#[derive(Clone, Debug)]
struct PSHB_instructionVar300 {}
impl PSHB_instructionVar300 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PSHB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 55i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4627:1, end:4627:2))"]
#[derive(Clone, Debug)]
struct PSHC_instructionVar301 {}
impl PSHC_instructionVar301 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PSHC")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 57i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4639:1, end:4639:2))"]
#[derive(Clone, Debug)]
struct PSHD_instructionVar302 {}
impl PSHD_instructionVar302 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PSHD")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 59i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4644:1, end:4644:2))"]
#[derive(Clone, Debug)]
struct PSHX_instructionVar303 {}
impl PSHX_instructionVar303 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PSHX")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 52i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4649:1, end:4649:2))"]
#[derive(Clone, Debug)]
struct PSHY_instructionVar304 {}
impl PSHY_instructionVar304 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PSHY")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 53i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4654:1, end:4654:2))"]
#[derive(Clone, Debug)]
struct PULA_instructionVar305 {}
impl PULA_instructionVar305 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PULA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 50i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4659:1, end:4659:2))"]
#[derive(Clone, Debug)]
struct PULB_instructionVar306 {}
impl PULB_instructionVar306 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PULB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 51i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4664:1, end:4664:2))"]
#[derive(Clone, Debug)]
struct PULC_instructionVar307 {}
impl PULC_instructionVar307 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PULC")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 56i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4676:1, end:4676:2))"]
#[derive(Clone, Debug)]
struct PULD_instructionVar308 {}
impl PULD_instructionVar308 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PULD")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 58i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4681:1, end:4681:2))"]
#[derive(Clone, Debug)]
struct PULX_instructionVar309 {}
impl PULX_instructionVar309 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PULX")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 48i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4686:1, end:4686:2))"]
#[derive(Clone, Debug)]
struct PULY_instructionVar310 {}
impl PULY_instructionVar310 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PULY")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 49i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4691:1, end:4691:2))"]
#[derive(Clone, Debug)]
struct REV_instructionVar311 {}
impl REV_instructionVar311 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("REV")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 58i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4699:1, end:4699:2))"]
#[derive(Clone, Debug)]
struct REVW_instructionVar312 {}
impl REVW_instructionVar312 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("REVW")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 59i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4709:1, end:4709:2))"]
#[derive(Clone, Debug)]
struct ROL_instructionVar313 {
    opr16a_8: Tableopr16a_8,
}
impl ROL_instructionVar313 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ROL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 117i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4722:1, end:4722:2))"]
#[derive(Clone, Debug)]
struct ROL_instructionVar314 {
    indexed1_5: Tableindexed1_5,
}
impl ROL_instructionVar314 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ROL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 101i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4735:1, end:4735:2))"]
#[derive(Clone, Debug)]
struct ROLA_instructionVar315 {}
impl ROLA_instructionVar315 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ROLA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 69i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4746:1, end:4746:2))"]
#[derive(Clone, Debug)]
struct ROLB_instructionVar316 {}
impl ROLB_instructionVar316 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ROLB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 85i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4813:1, end:4813:2))"]
#[derive(Clone, Debug)]
struct ROR_instructionVar317 {
    opr16a_8: Tableopr16a_8,
}
impl ROR_instructionVar317 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ROR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 118i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4826:1, end:4826:2))"]
#[derive(Clone, Debug)]
struct ROR_instructionVar318 {
    indexed1_5: Tableindexed1_5,
}
impl ROR_instructionVar318 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ROR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 102i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4839:1, end:4839:2))"]
#[derive(Clone, Debug)]
struct RORA_instructionVar319 {}
impl RORA_instructionVar319 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("RORA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 70i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4850:1, end:4850:2))"]
#[derive(Clone, Debug)]
struct RORB_instructionVar320 {}
impl RORB_instructionVar320 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("RORB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 86i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4918:1, end:4918:2))"]
#[derive(Clone, Debug)]
struct RTC_instructionVar321 {}
impl RTC_instructionVar321 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("RTC")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 10i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4929:1, end:4929:2))"]
#[derive(Clone, Debug)]
struct RTI_instructionVar322 {}
impl RTI_instructionVar322 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("RTI")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 11i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4942:1, end:4942:2))"]
#[derive(Clone, Debug)]
struct RTS_instructionVar323 {}
impl RTS_instructionVar323 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("RTS")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 61i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4950:1, end:4950:2))"]
#[derive(Clone, Debug)]
struct SBA_instructionVar324 {}
impl SBA_instructionVar324 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("SBA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let mut sub_pattern_c39 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 22i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c39(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4957:1, end:4957:2))"]
#[derive(Clone, Debug)]
struct SBCA_instructionVar325 {
    iopr8i: Tableiopr8i,
}
impl SBCA_instructionVar325 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SBCA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 130i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4966:1, end:4966:2))"]
#[derive(Clone, Debug)]
struct SBCA_instructionVar326 {
    opr8a_8: Tableopr8a_8,
}
impl SBCA_instructionVar326 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SBCA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 146i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4975:1, end:4975:2))"]
#[derive(Clone, Debug)]
struct SBCA_instructionVar327 {
    opr16a_8: Tableopr16a_8,
}
impl SBCA_instructionVar327 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SBCA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 178i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4984:1, end:4984:2))"]
#[derive(Clone, Debug)]
struct SBCA_instructionVar328 {
    indexed1_5: Tableindexed1_5,
}
impl SBCA_instructionVar328 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SBCA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 162i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4993:1, end:4993:2))"]
#[derive(Clone, Debug)]
struct SBCB_instructionVar329 {
    iopr8i: Tableiopr8i,
}
impl SBCB_instructionVar329 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SBCB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 194i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5002:1, end:5002:2))"]
#[derive(Clone, Debug)]
struct SBCB_instructionVar330 {
    opr8a_8: Tableopr8a_8,
}
impl SBCB_instructionVar330 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SBCB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 210i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5011:1, end:5011:2))"]
#[derive(Clone, Debug)]
struct SBCB_instructionVar331 {
    opr16a_8: Tableopr16a_8,
}
impl SBCB_instructionVar331 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SBCB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 242i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5020:1, end:5020:2))"]
#[derive(Clone, Debug)]
struct SBCB_instructionVar332 {
    indexed1_5: Tableindexed1_5,
}
impl SBCB_instructionVar332 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SBCB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 226i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5239:1, end:5239:2))"]
#[derive(Clone, Debug)]
struct instructionVar333 {
    GPaged: TableGPaged,
    opr8a_8: Tableopr8a_8,
}
impl instructionVar333 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("STAA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 90i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5248:1, end:5248:2))"]
#[derive(Clone, Debug)]
struct instructionVar334 {
    GPaged: TableGPaged,
    opr16a_8: Tableopr16a_8,
}
impl instructionVar334 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("STAA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 122i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5257:1, end:5257:2))"]
#[derive(Clone, Debug)]
struct instructionVar335 {
    GPaged: TableGPaged,
    indexed1_5: Tableindexed1_5,
}
impl instructionVar335 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("STAA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c56 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 106i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c56(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5266:1, end:5266:2))"]
#[derive(Clone, Debug)]
struct instructionVar336 {
    GPaged: TableGPaged,
    opr8a_8: Tableopr8a_8,
}
impl instructionVar336 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("STAB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 91i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5275:1, end:5275:2))"]
#[derive(Clone, Debug)]
struct instructionVar337 {
    GPaged: TableGPaged,
    opr16a_8: Tableopr16a_8,
}
impl instructionVar337 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("STAB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 123i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5284:1, end:5284:2))"]
#[derive(Clone, Debug)]
struct instructionVar338 {
    GPaged: TableGPaged,
    indexed1_5: Tableindexed1_5,
}
impl instructionVar338 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("STAB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c56 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 107i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c56(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5293:1, end:5293:2))"]
#[derive(Clone, Debug)]
struct instructionVar339 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar339 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 92i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5302:1, end:5302:2))"]
#[derive(Clone, Debug)]
struct instructionVar340 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar340 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 124i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5311:1, end:5311:2))"]
#[derive(Clone, Debug)]
struct instructionVar341 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar341 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 108i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5320:1, end:5320:2))"]
#[derive(Clone, Debug)]
struct STOP_instructionVar342 {}
impl STOP_instructionVar342 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("STOP")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 62i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5334:1, end:5334:2))"]
#[derive(Clone, Debug)]
struct instructionVar343 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar343 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 95i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5343:1, end:5343:2))"]
#[derive(Clone, Debug)]
struct instructionVar344 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar344 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 127i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5352:1, end:5352:2))"]
#[derive(Clone, Debug)]
struct instructionVar345 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar345 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 111i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5361:1, end:5361:2))"]
#[derive(Clone, Debug)]
struct instructionVar346 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar346 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STX"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 94i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5370:1, end:5370:2))"]
#[derive(Clone, Debug)]
struct instructionVar347 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar347 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STX"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 126i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5379:1, end:5379:2))"]
#[derive(Clone, Debug)]
struct instructionVar348 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar348 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STX"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 110i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5388:1, end:5388:2))"]
#[derive(Clone, Debug)]
struct instructionVar349 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar349 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STY"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 93i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5397:1, end:5397:2))"]
#[derive(Clone, Debug)]
struct instructionVar350 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar350 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STY"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 125i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5406:1, end:5406:2))"]
#[derive(Clone, Debug)]
struct instructionVar351 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar351 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STY"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 109i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5415:1, end:5415:2))"]
#[derive(Clone, Debug)]
struct SUBA_instructionVar352 {
    iopr8i: Tableiopr8i,
}
impl SUBA_instructionVar352 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 128i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5424:1, end:5424:2))"]
#[derive(Clone, Debug)]
struct SUBA_instructionVar353 {
    opr8a_8: Tableopr8a_8,
}
impl SUBA_instructionVar353 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 144i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5433:1, end:5433:2))"]
#[derive(Clone, Debug)]
struct SUBA_instructionVar354 {
    opr16a_8: Tableopr16a_8,
}
impl SUBA_instructionVar354 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 176i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5442:1, end:5442:2))"]
#[derive(Clone, Debug)]
struct SUBA_instructionVar355 {
    indexed1_5: Tableindexed1_5,
}
impl SUBA_instructionVar355 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 160i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5451:1, end:5451:2))"]
#[derive(Clone, Debug)]
struct SUBB_instructionVar356 {
    iopr8i: Tableiopr8i,
}
impl SUBB_instructionVar356 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 192i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5460:1, end:5460:2))"]
#[derive(Clone, Debug)]
struct SUBB_instructionVar357 {
    opr8a_8: Tableopr8a_8,
}
impl SUBB_instructionVar357 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 208i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5469:1, end:5469:2))"]
#[derive(Clone, Debug)]
struct SUBB_instructionVar358 {
    opr16a_8: Tableopr16a_8,
}
impl SUBB_instructionVar358 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 240i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5478:1, end:5478:2))"]
#[derive(Clone, Debug)]
struct SUBB_instructionVar359 {
    indexed1_5: Tableindexed1_5,
}
impl SUBB_instructionVar359 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 224i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5487:1, end:5487:2))"]
#[derive(Clone, Debug)]
struct SUBD_instructionVar360 {
    iopr16i: Tableiopr16i,
}
impl SUBD_instructionVar360 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBD"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr16i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 131i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr16i = if let Some((len, table)) = Tableiopr16i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5496:1, end:5496:2))"]
#[derive(Clone, Debug)]
struct SUBD_instructionVar361 {
    opr8a_16: Tableopr8a_16,
}
impl SUBD_instructionVar361 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBD"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 147i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5505:1, end:5505:2))"]
#[derive(Clone, Debug)]
struct SUBD_instructionVar362 {
    opr16a_16: Tableopr16a_16,
}
impl SUBD_instructionVar362 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBD"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 179i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5514:1, end:5514:2))"]
#[derive(Clone, Debug)]
struct SUBD_instructionVar363 {
    indexed2_5: Tableindexed2_5,
}
impl SUBD_instructionVar363 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBD"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 163i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5611:1, end:5611:2))"]
#[derive(Clone, Debug)]
struct SWI_instructionVar364 {}
impl SWI_instructionVar364 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("SWI")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 63i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5627:1, end:5627:2))"]
#[derive(Clone, Debug)]
struct TAB_instructionVar365 {}
impl TAB_instructionVar365 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("TAB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 14i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5640:1, end:5640:2))"]
#[derive(Clone, Debug)]
struct TBA_instructionVar366 {}
impl TBA_instructionVar366 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("TBA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 15i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5658:1, end:5658:2))"]
#[derive(Clone, Debug)]
struct TBL_instructionVar367 {
    indexed1_3: Tableindexed1_3,
}
impl TBL_instructionVar367 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("TBL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 61i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_3 = if let Some((len, table)) = Tableindexed1_3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5817:1, end:5817:2))"]
#[derive(Clone, Debug)]
struct TRAP_instructionVar368 {
    trapnum: TokenField_trapnum,
}
impl TRAP_instructionVar368 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("TRAP"),
            DisplayElement::Literal(" "),
            self.trapnum.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 48i128 {
            return None;
        }
        let trapnum = token_parser.TokenFieldtrapnum();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { trapnum }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5833:1, end:5833:2))"]
#[derive(Clone, Debug)]
struct TST_instructionVar369 {
    opr16a_8: Tableopr16a_8,
}
impl TST_instructionVar369 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("TST"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 247i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5842:1, end:5842:2))"]
#[derive(Clone, Debug)]
struct TST_instructionVar370 {
    indexed1_5: Tableindexed1_5,
}
impl TST_instructionVar370 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("TST"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 231i128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5851:1, end:5851:2))"]
#[derive(Clone, Debug)]
struct TSTA_instructionVar371 {}
impl TSTA_instructionVar371 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("TSTA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 151i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5858:1, end:5858:2))"]
#[derive(Clone, Debug)]
struct TSTB_instructionVar372 {}
impl TSTB_instructionVar372 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("TSTB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 215i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5888:1, end:5888:2))"]
#[derive(Clone, Debug)]
struct TSTX_instructionVar373 {}
impl TSTX_instructionVar373 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("TSTX")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 151i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5896:1, end:5896:2))"]
#[derive(Clone, Debug)]
struct TSTY_instructionVar374 {}
impl TSTY_instructionVar374 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("TSTY")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 215i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5923:1, end:5923:2))"]
#[derive(Clone, Debug)]
struct WAI_instructionVar375 {}
impl WAI_instructionVar375 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("WAI")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 62i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5936:1, end:5936:2))"]
#[derive(Clone, Debug)]
struct WAV_instructionVar376 {}
impl WAV_instructionVar376 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("WAV")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 60i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5949:1, end:5949:2))"]
#[derive(Clone, Debug)]
struct WAVR_instructionVar377 {}
impl WAVR_instructionVar377 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("WAVR")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 60i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tableinstruction {
    Var0(ABX_instructionVar0),
    Var1(ABY_instructionVar1),
    Var2(CLC_instructionVar2),
    Var3(CLI_instructionVar3),
    Var4(CLV_instructionVar4),
    Var5(DBEQ_instructionVar5),
    Var6(DBEQ_instructionVar6),
    Var7(DBNE_instructionVar7),
    Var8(DBNE_instructionVar8),
    Var9(DES_instructionVar9),
    Var10(EXG_instructionVar10),
    Var11(EXG_instructionVar11),
    Var12(EXG_instructionVar12),
    Var13(EXG_instructionVar13),
    Var14(EXG_instructionVar14),
    Var15(INS_instructionVar15),
    Var16(SEC_instructionVar16),
    Var17(SEI_instructionVar17),
    Var18(SEV_instructionVar18),
    Var19(TAP_instructionVar19),
    Var20(TFR_instructionVar20),
    Var21(TFR_instructionVar21),
    Var22(TFR_instructionVar22),
    Var23(TPA_instructionVar23),
    Var24(TSX_instructionVar24),
    Var25(TSY_instructionVar25),
    Var26(TXS_instructionVar26),
    Var27(TYS_instructionVar27),
    Var28(XGDX_instructionVar28),
    Var29(XGDY_instructionVar29),
    Var30(EXG_instructionVar30),
    Var31(EXG_instructionVar31),
    Var32(EXG_instructionVar32),
    Var33(EXG_instructionVar33),
    Var34(EXG_instructionVar34),
    Var35(EXG_instructionVar35),
    Var36(EXG_instructionVar36),
    Var37(EXG_instructionVar37),
    Var38(EXG_instructionVar38),
    Var39(EXG_instructionVar39),
    Var40(EXG_instructionVar40),
    Var41(EXG_instructionVar41),
    Var42(EXG_instructionVar42),
    Var43(EXG_instructionVar43),
    Var44(EXG_instructionVar44),
    Var45(EXG_instructionVar45),
    Var46(EXG_instructionVar46),
    Var47(TFR_instructionVar47),
    Var48(TFR_instructionVar48),
    Var49(TFR_instructionVar49),
    Var50(EXG_instructionVar50),
    Var51(SEX_instructionVar51),
    Var52(TFR_instructionVar52),
    Var53(TFR_instructionVar53),
    Var54(TFR_instructionVar54),
    Var55(TFR_instructionVar55),
    Var56(EXG_instructionVar56),
    Var57(IBEQ_instructionVar57),
    Var58(IBEQ_instructionVar58),
    Var59(IBNE_instructionVar59),
    Var60(IBNE_instructionVar60),
    Var61(TBEQ_instructionVar61),
    Var62(TBEQ_instructionVar62),
    Var63(TBNE_instructionVar63),
    Var64(TBNE_instructionVar64),
    Var65(TFR_instructionVar65),
    Var66(instructionVar66),
    Var67(ABA_instructionVar67),
    Var68(ADCA_instructionVar68),
    Var69(ADCA_instructionVar69),
    Var70(ADCA_instructionVar70),
    Var71(ADCA_instructionVar71),
    Var72(ADCB_instructionVar72),
    Var73(ADCB_instructionVar73),
    Var74(ADCB_instructionVar74),
    Var75(ADCB_instructionVar75),
    Var76(ADDA_instructionVar76),
    Var77(ADDA_instructionVar77),
    Var78(ADDA_instructionVar78),
    Var79(ADDA_instructionVar79),
    Var80(ADDB_instructionVar80),
    Var81(ADDB_instructionVar81),
    Var82(ADDB_instructionVar82),
    Var83(ADDB_instructionVar83),
    Var84(ADDD_instructionVar84),
    Var85(ADDD_instructionVar85),
    Var86(ADDD_instructionVar86),
    Var87(ADDD_instructionVar87),
    Var88(ANDA_instructionVar88),
    Var89(ANDA_instructionVar89),
    Var90(ANDA_instructionVar90),
    Var91(ANDA_instructionVar91),
    Var92(ANDB_instructionVar92),
    Var93(ANDB_instructionVar93),
    Var94(ANDB_instructionVar94),
    Var95(ANDB_instructionVar95),
    Var96(ANDCC_instructionVar96),
    Var97(ASL_instructionVar97),
    Var98(ASL_instructionVar98),
    Var99(ASLA_instructionVar99),
    Var100(ASLB_instructionVar100),
    Var101(ASLD_instructionVar101),
    Var102(ASR_instructionVar102),
    Var103(ASR_instructionVar103),
    Var104(ASRA_instructionVar104),
    Var105(ASRB_instructionVar105),
    Var106(BCC_instructionVar106),
    Var107(BCLR_instructionVar107),
    Var108(BCLR_instructionVar108),
    Var109(BCLR_instructionVar109),
    Var110(BCS_instructionVar110),
    Var111(BEQ_instructionVar111),
    Var112(BGE_instructionVar112),
    Var113(BGND_instructionVar113),
    Var114(BGT_instructionVar114),
    Var115(BHI_instructionVar115),
    Var116(BITA_instructionVar116),
    Var117(BITA_instructionVar117),
    Var118(BITA_instructionVar118),
    Var119(BITA_instructionVar119),
    Var120(BITB_instructionVar120),
    Var121(BITB_instructionVar121),
    Var122(BITB_instructionVar122),
    Var123(BITB_instructionVar123),
    Var124(BLE_instructionVar124),
    Var125(BLS_instructionVar125),
    Var126(BLT_instructionVar126),
    Var127(BMI_instructionVar127),
    Var128(BNE_instructionVar128),
    Var129(BPL_instructionVar129),
    Var130(BRA_instructionVar130),
    Var131(BRCLR_instructionVar131),
    Var132(BRCLR_instructionVar132),
    Var133(BRCLR_instructionVar133),
    Var134(BRN_instructionVar134),
    Var135(BRSET_instructionVar135),
    Var136(BRSET_instructionVar136),
    Var137(BRSET_instructionVar137),
    Var138(BSET_instructionVar138),
    Var139(BSET_instructionVar139),
    Var140(BSET_instructionVar140),
    Var141(BSR_instructionVar141),
    Var142(BVC_instructionVar142),
    Var143(BVS_instructionVar143),
    Var144(CALL_instructionVar144),
    Var145(CALL_instructionVar145),
    Var146(CALL_instructionVar146),
    Var147(CBA_instructionVar147),
    Var148(CLR_instructionVar148),
    Var149(CLR_instructionVar149),
    Var150(CLRA_instructionVar150),
    Var151(CLRB_instructionVar151),
    Var152(CMPA_instructionVar152),
    Var153(CMPA_instructionVar153),
    Var154(CMPA_instructionVar154),
    Var155(CMPA_instructionVar155),
    Var156(CMPB_instructionVar156),
    Var157(CMPB_instructionVar157),
    Var158(CMPB_instructionVar158),
    Var159(CMPB_instructionVar159),
    Var160(COM_instructionVar160),
    Var161(COM_instructionVar161),
    Var162(COMA_instructionVar162),
    Var163(COMB_instructionVar163),
    Var164(CPD_instructionVar164),
    Var165(CPD_instructionVar165),
    Var166(CPD_instructionVar166),
    Var167(CPD_instructionVar167),
    Var168(CPS_instructionVar168),
    Var169(CPS_instructionVar169),
    Var170(CPS_instructionVar170),
    Var171(CPS_instructionVar171),
    Var172(CPX_instructionVar172),
    Var173(CPX_instructionVar173),
    Var174(CPX_instructionVar174),
    Var175(CPX_instructionVar175),
    Var176(CPY_instructionVar176),
    Var177(CPY_instructionVar177),
    Var178(CPY_instructionVar178),
    Var179(CPY_instructionVar179),
    Var180(DAA_instructionVar180),
    Var181(DEC_instructionVar181),
    Var182(DEC_instructionVar182),
    Var183(DECA_instructionVar183),
    Var184(DECB_instructionVar184),
    Var185(DEX_instructionVar185),
    Var186(DEY_instructionVar186),
    Var187(EDIV_instructionVar187),
    Var188(EDIVS_instructionVar188),
    Var189(EMACS_instructionVar189),
    Var190(EMAXD_instructionVar190),
    Var191(EMAXM_instructionVar191),
    Var192(EMIND_instructionVar192),
    Var193(EMINM_instructionVar193),
    Var194(EMUL_instructionVar194),
    Var195(EMULS_instructionVar195),
    Var196(EORA_instructionVar196),
    Var197(EORA_instructionVar197),
    Var198(EORA_instructionVar198),
    Var199(EORA_instructionVar199),
    Var200(EORB_instructionVar200),
    Var201(EORB_instructionVar201),
    Var202(EORB_instructionVar202),
    Var203(EORB_instructionVar203),
    Var204(ETBL_instructionVar204),
    Var205(FDIV_instructionVar205),
    Var206(IDIV_instructionVar206),
    Var207(IDIVS_instructionVar207),
    Var208(INC_instructionVar208),
    Var209(INC_instructionVar209),
    Var210(INCA_instructionVar210),
    Var211(INCB_instructionVar211),
    Var212(INX_instructionVar212),
    Var213(INY_instructionVar213),
    Var214(JMP_instructionVar214),
    Var215(JMP_instructionVar215),
    Var216(JSR_instructionVar216),
    Var217(JSR_instructionVar217),
    Var218(JSR_instructionVar218),
    Var219(LBCC_instructionVar219),
    Var220(LBCS_instructionVar220),
    Var221(LBEQ_instructionVar221),
    Var222(LBGE_instructionVar222),
    Var223(LBGT_instructionVar223),
    Var224(LBHI_instructionVar224),
    Var225(LBLE_instructionVar225),
    Var226(LBLS_instructionVar226),
    Var227(LBLT_instructionVar227),
    Var228(LBMI_instructionVar228),
    Var229(LBNE_instructionVar229),
    Var230(LBPL_instructionVar230),
    Var231(LBRA_instructionVar231),
    Var232(LBRN_instructionVar232),
    Var233(LBVC_instructionVar233),
    Var234(LBVS_instructionVar234),
    Var235(LDAA_instructionVar235),
    Var236(instructionVar236),
    Var237(instructionVar237),
    Var238(instructionVar238),
    Var239(LDAB_instructionVar239),
    Var240(instructionVar240),
    Var241(instructionVar241),
    Var242(instructionVar242),
    Var243(LDD_instructionVar243),
    Var244(instructionVar244),
    Var245(instructionVar245),
    Var246(instructionVar246),
    Var247(LDS_instructionVar247),
    Var248(instructionVar248),
    Var249(instructionVar249),
    Var250(instructionVar250),
    Var251(LDX_instructionVar251),
    Var252(instructionVar252),
    Var253(instructionVar253),
    Var254(instructionVar254),
    Var255(LDY_instructionVar255),
    Var256(instructionVar256),
    Var257(instructionVar257),
    Var258(instructionVar258),
    Var259(LEAS_instructionVar259),
    Var260(LEAX_instructionVar260),
    Var261(LEAY_instructionVar261),
    Var262(LSR_instructionVar262),
    Var263(LSR_instructionVar263),
    Var264(LSRA_instructionVar264),
    Var265(LSRB_instructionVar265),
    Var266(LSRD_instructionVar266),
    Var267(MAXA_instructionVar267),
    Var268(MAXM_instructionVar268),
    Var269(MEM_instructionVar269),
    Var270(MINA_instructionVar270),
    Var271(MINM_instructionVar271),
    Var272(MOVB_instructionVar272),
    Var273(MOVB_instructionVar273),
    Var274(MOVB_instructionVar274),
    Var275(MOVB_instructionVar275),
    Var276(MOVB_instructionVar276),
    Var277(MOVB_instructionVar277),
    Var278(MOVW_instructionVar278),
    Var279(MOVW_instructionVar279),
    Var280(MOVW_instructionVar280),
    Var281(MOVW_instructionVar281),
    Var282(MOVW_instructionVar282),
    Var283(MOVW_instructionVar283),
    Var284(MUL_instructionVar284),
    Var285(NEG_instructionVar285),
    Var286(NEG_instructionVar286),
    Var287(NEGA_instructionVar287),
    Var288(NEGB_instructionVar288),
    Var289(NOP_instructionVar289),
    Var290(ORAA_instructionVar290),
    Var291(ORAA_instructionVar291),
    Var292(ORAA_instructionVar292),
    Var293(ORAA_instructionVar293),
    Var294(ORAB_instructionVar294),
    Var295(ORAB_instructionVar295),
    Var296(ORAB_instructionVar296),
    Var297(ORAB_instructionVar297),
    Var298(ORCC_instructionVar298),
    Var299(PSHA_instructionVar299),
    Var300(PSHB_instructionVar300),
    Var301(PSHC_instructionVar301),
    Var302(PSHD_instructionVar302),
    Var303(PSHX_instructionVar303),
    Var304(PSHY_instructionVar304),
    Var305(PULA_instructionVar305),
    Var306(PULB_instructionVar306),
    Var307(PULC_instructionVar307),
    Var308(PULD_instructionVar308),
    Var309(PULX_instructionVar309),
    Var310(PULY_instructionVar310),
    Var311(REV_instructionVar311),
    Var312(REVW_instructionVar312),
    Var313(ROL_instructionVar313),
    Var314(ROL_instructionVar314),
    Var315(ROLA_instructionVar315),
    Var316(ROLB_instructionVar316),
    Var317(ROR_instructionVar317),
    Var318(ROR_instructionVar318),
    Var319(RORA_instructionVar319),
    Var320(RORB_instructionVar320),
    Var321(RTC_instructionVar321),
    Var322(RTI_instructionVar322),
    Var323(RTS_instructionVar323),
    Var324(SBA_instructionVar324),
    Var325(SBCA_instructionVar325),
    Var326(SBCA_instructionVar326),
    Var327(SBCA_instructionVar327),
    Var328(SBCA_instructionVar328),
    Var329(SBCB_instructionVar329),
    Var330(SBCB_instructionVar330),
    Var331(SBCB_instructionVar331),
    Var332(SBCB_instructionVar332),
    Var333(instructionVar333),
    Var334(instructionVar334),
    Var335(instructionVar335),
    Var336(instructionVar336),
    Var337(instructionVar337),
    Var338(instructionVar338),
    Var339(instructionVar339),
    Var340(instructionVar340),
    Var341(instructionVar341),
    Var342(STOP_instructionVar342),
    Var343(instructionVar343),
    Var344(instructionVar344),
    Var345(instructionVar345),
    Var346(instructionVar346),
    Var347(instructionVar347),
    Var348(instructionVar348),
    Var349(instructionVar349),
    Var350(instructionVar350),
    Var351(instructionVar351),
    Var352(SUBA_instructionVar352),
    Var353(SUBA_instructionVar353),
    Var354(SUBA_instructionVar354),
    Var355(SUBA_instructionVar355),
    Var356(SUBB_instructionVar356),
    Var357(SUBB_instructionVar357),
    Var358(SUBB_instructionVar358),
    Var359(SUBB_instructionVar359),
    Var360(SUBD_instructionVar360),
    Var361(SUBD_instructionVar361),
    Var362(SUBD_instructionVar362),
    Var363(SUBD_instructionVar363),
    Var364(SWI_instructionVar364),
    Var365(TAB_instructionVar365),
    Var366(TBA_instructionVar366),
    Var367(TBL_instructionVar367),
    Var368(TRAP_instructionVar368),
    Var369(TST_instructionVar369),
    Var370(TST_instructionVar370),
    Var371(TSTA_instructionVar371),
    Var372(TSTB_instructionVar372),
    Var373(TSTX_instructionVar373),
    Var374(TSTY_instructionVar374),
    Var375(WAI_instructionVar375),
    Var376(WAV_instructionVar376),
    Var377(WAVR_instructionVar377),
}
impl Tableinstruction {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var18(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var19(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var20(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var21(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var22(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var23(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var24(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var25(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var26(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var27(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var28(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var29(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var30(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var31(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var32(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var33(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var34(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var35(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var36(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var37(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var38(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var39(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var40(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var41(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var42(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var43(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var44(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var45(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var46(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var47(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var48(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var49(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var50(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var51(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var52(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var53(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var54(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var55(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var56(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var57(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var58(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var59(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var60(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var61(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var62(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var63(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var64(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var65(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var66(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var67(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var68(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var69(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var70(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var71(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var72(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var73(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var74(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var75(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var76(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var77(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var78(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var79(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var80(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var81(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var82(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var83(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var84(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var85(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var86(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var87(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var88(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var89(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var90(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var91(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var92(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var93(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var94(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var95(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var96(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var97(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var98(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var99(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var100(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var101(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var102(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var103(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var104(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var105(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var106(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var107(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var108(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var109(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var110(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var111(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var112(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var113(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var114(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var115(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var116(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var117(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var118(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var119(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var120(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var121(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var122(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var123(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var124(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var125(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var126(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var127(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var128(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var129(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var130(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var131(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var132(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var133(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var134(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var135(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var136(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var137(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var138(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var139(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var140(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var141(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var142(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var143(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var144(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var145(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var146(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var147(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var148(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var149(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var150(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var151(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var152(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var153(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var154(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var155(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var156(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var157(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var158(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var159(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var160(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var161(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var162(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var163(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var164(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var165(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var166(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var167(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var168(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var169(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var170(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var171(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var172(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var173(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var174(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var175(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var176(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var177(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var178(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var179(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var180(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var181(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var182(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var183(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var184(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var185(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var186(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var187(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var188(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var189(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var190(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var191(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var192(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var193(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var194(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var195(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var196(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var197(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var198(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var199(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var200(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var201(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var202(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var203(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var204(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var205(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var206(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var207(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var208(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var209(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var210(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var211(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var212(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var213(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var214(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var215(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var216(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var217(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var218(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var219(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var220(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var221(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var222(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var223(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var224(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var225(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var226(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var227(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var228(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var229(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var230(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var231(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var232(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var233(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var234(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var235(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var236(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var237(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var238(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var239(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var240(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var241(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var242(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var243(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var244(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var245(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var246(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var247(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var248(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var249(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var250(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var251(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var252(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var253(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var254(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var255(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var256(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var257(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var258(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var259(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var260(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var261(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var262(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var263(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var264(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var265(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var266(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var267(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var268(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var269(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var270(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var271(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var272(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var273(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var274(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var275(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var276(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var277(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var278(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var279(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var280(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var281(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var282(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var283(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var284(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var285(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var286(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var287(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var288(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var289(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var290(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var291(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var292(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var293(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var294(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var295(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var296(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var297(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var298(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var299(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var300(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var301(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var302(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var303(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var304(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var305(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var306(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var307(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var308(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var309(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var310(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var311(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var312(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var313(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var314(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var315(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var316(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var317(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var318(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var319(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var320(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var321(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var322(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var323(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var324(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var325(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var326(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var327(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var328(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var329(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var330(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var331(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var332(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var333(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var334(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var335(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var336(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var337(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var338(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var339(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var340(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var341(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var342(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var343(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var344(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var345(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var346(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var347(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var348(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var349(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var350(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var351(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var352(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var353(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var354(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var355(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var356(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var357(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var358(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var359(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var360(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var361(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var362(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var363(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var364(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var365(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var366(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var367(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var368(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var369(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var370(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var371(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var372(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var373(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var374(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var375(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var376(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var377(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = ABX_instructionVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = ABY_instructionVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = CLC_instructionVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = CLI_instructionVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = CLV_instructionVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = DBEQ_instructionVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = DBEQ_instructionVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = DBNE_instructionVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) = DBNE_instructionVar8::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) = DES_instructionVar9::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar10::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar11::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar12::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar13::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar14::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) = INS_instructionVar15::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        if let Some((inst_len, parsed)) = SEC_instructionVar16::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var16(parsed)));
        }
        if let Some((inst_len, parsed)) = SEI_instructionVar17::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var17(parsed)));
        }
        if let Some((inst_len, parsed)) = SEV_instructionVar18::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var18(parsed)));
        }
        if let Some((inst_len, parsed)) = TAP_instructionVar19::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var19(parsed)));
        }
        if let Some((inst_len, parsed)) = TFR_instructionVar20::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var20(parsed)));
        }
        if let Some((inst_len, parsed)) = TFR_instructionVar21::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var21(parsed)));
        }
        if let Some((inst_len, parsed)) = TFR_instructionVar22::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var22(parsed)));
        }
        if let Some((inst_len, parsed)) = TPA_instructionVar23::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var23(parsed)));
        }
        if let Some((inst_len, parsed)) = TSX_instructionVar24::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var24(parsed)));
        }
        if let Some((inst_len, parsed)) = TSY_instructionVar25::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var25(parsed)));
        }
        if let Some((inst_len, parsed)) = TXS_instructionVar26::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var26(parsed)));
        }
        if let Some((inst_len, parsed)) = TYS_instructionVar27::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var27(parsed)));
        }
        if let Some((inst_len, parsed)) = XGDX_instructionVar28::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var28(parsed)));
        }
        if let Some((inst_len, parsed)) = XGDY_instructionVar29::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var29(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar30::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var30(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar31::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var31(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar32::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var32(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar33::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var33(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar34::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var34(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar35::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var35(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar36::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var36(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar37::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var37(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar38::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var38(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar39::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var39(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar40::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var40(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar41::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var41(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar42::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var42(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar43::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var43(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar44::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var44(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar45::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var45(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar46::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var46(parsed)));
        }
        if let Some((inst_len, parsed)) = TFR_instructionVar47::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var47(parsed)));
        }
        if let Some((inst_len, parsed)) = TFR_instructionVar48::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var48(parsed)));
        }
        if let Some((inst_len, parsed)) = TFR_instructionVar49::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var49(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar50::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var50(parsed)));
        }
        if let Some((inst_len, parsed)) = SEX_instructionVar51::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var51(parsed)));
        }
        if let Some((inst_len, parsed)) = TFR_instructionVar52::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var52(parsed)));
        }
        if let Some((inst_len, parsed)) = TFR_instructionVar53::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var53(parsed)));
        }
        if let Some((inst_len, parsed)) = TFR_instructionVar54::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var54(parsed)));
        }
        if let Some((inst_len, parsed)) = TFR_instructionVar55::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var55(parsed)));
        }
        if let Some((inst_len, parsed)) = EXG_instructionVar56::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var56(parsed)));
        }
        if let Some((inst_len, parsed)) = IBEQ_instructionVar57::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var57(parsed)));
        }
        if let Some((inst_len, parsed)) = IBEQ_instructionVar58::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var58(parsed)));
        }
        if let Some((inst_len, parsed)) = IBNE_instructionVar59::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var59(parsed)));
        }
        if let Some((inst_len, parsed)) = IBNE_instructionVar60::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var60(parsed)));
        }
        if let Some((inst_len, parsed)) = TBEQ_instructionVar61::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var61(parsed)));
        }
        if let Some((inst_len, parsed)) = TBEQ_instructionVar62::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var62(parsed)));
        }
        if let Some((inst_len, parsed)) = TBNE_instructionVar63::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var63(parsed)));
        }
        if let Some((inst_len, parsed)) = TBNE_instructionVar64::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var64(parsed)));
        }
        if let Some((inst_len, parsed)) = TFR_instructionVar65::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var65(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar66::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var66(parsed)));
        }
        if let Some((inst_len, parsed)) = ABA_instructionVar67::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var67(parsed)));
        }
        if let Some((inst_len, parsed)) = ADCA_instructionVar68::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var68(parsed)));
        }
        if let Some((inst_len, parsed)) = ADCA_instructionVar69::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var69(parsed)));
        }
        if let Some((inst_len, parsed)) = ADCA_instructionVar70::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var70(parsed)));
        }
        if let Some((inst_len, parsed)) = ADCA_instructionVar71::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var71(parsed)));
        }
        if let Some((inst_len, parsed)) = ADCB_instructionVar72::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var72(parsed)));
        }
        if let Some((inst_len, parsed)) = ADCB_instructionVar73::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var73(parsed)));
        }
        if let Some((inst_len, parsed)) = ADCB_instructionVar74::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var74(parsed)));
        }
        if let Some((inst_len, parsed)) = ADCB_instructionVar75::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var75(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDA_instructionVar76::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var76(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDA_instructionVar77::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var77(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDA_instructionVar78::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var78(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDA_instructionVar79::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var79(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDB_instructionVar80::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var80(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDB_instructionVar81::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var81(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDB_instructionVar82::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var82(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDB_instructionVar83::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var83(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDD_instructionVar84::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var84(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDD_instructionVar85::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var85(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDD_instructionVar86::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var86(parsed)));
        }
        if let Some((inst_len, parsed)) = ADDD_instructionVar87::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var87(parsed)));
        }
        if let Some((inst_len, parsed)) = ANDA_instructionVar88::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var88(parsed)));
        }
        if let Some((inst_len, parsed)) = ANDA_instructionVar89::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var89(parsed)));
        }
        if let Some((inst_len, parsed)) = ANDA_instructionVar90::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var90(parsed)));
        }
        if let Some((inst_len, parsed)) = ANDA_instructionVar91::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var91(parsed)));
        }
        if let Some((inst_len, parsed)) = ANDB_instructionVar92::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var92(parsed)));
        }
        if let Some((inst_len, parsed)) = ANDB_instructionVar93::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var93(parsed)));
        }
        if let Some((inst_len, parsed)) = ANDB_instructionVar94::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var94(parsed)));
        }
        if let Some((inst_len, parsed)) = ANDB_instructionVar95::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var95(parsed)));
        }
        if let Some((inst_len, parsed)) = ANDCC_instructionVar96::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var96(parsed)));
        }
        if let Some((inst_len, parsed)) = ASL_instructionVar97::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var97(parsed)));
        }
        if let Some((inst_len, parsed)) = ASL_instructionVar98::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var98(parsed)));
        }
        if let Some((inst_len, parsed)) = ASLA_instructionVar99::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var99(parsed)));
        }
        if let Some((inst_len, parsed)) = ASLB_instructionVar100::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var100(parsed)));
        }
        if let Some((inst_len, parsed)) = ASLD_instructionVar101::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var101(parsed)));
        }
        if let Some((inst_len, parsed)) = ASR_instructionVar102::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var102(parsed)));
        }
        if let Some((inst_len, parsed)) = ASR_instructionVar103::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var103(parsed)));
        }
        if let Some((inst_len, parsed)) = ASRA_instructionVar104::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var104(parsed)));
        }
        if let Some((inst_len, parsed)) = ASRB_instructionVar105::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var105(parsed)));
        }
        if let Some((inst_len, parsed)) = BCC_instructionVar106::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var106(parsed)));
        }
        if let Some((inst_len, parsed)) = BCLR_instructionVar107::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var107(parsed)));
        }
        if let Some((inst_len, parsed)) = BCLR_instructionVar108::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var108(parsed)));
        }
        if let Some((inst_len, parsed)) = BCLR_instructionVar109::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var109(parsed)));
        }
        if let Some((inst_len, parsed)) = BCS_instructionVar110::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var110(parsed)));
        }
        if let Some((inst_len, parsed)) = BEQ_instructionVar111::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var111(parsed)));
        }
        if let Some((inst_len, parsed)) = BGE_instructionVar112::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var112(parsed)));
        }
        if let Some((inst_len, parsed)) = BGND_instructionVar113::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var113(parsed)));
        }
        if let Some((inst_len, parsed)) = BGT_instructionVar114::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var114(parsed)));
        }
        if let Some((inst_len, parsed)) = BHI_instructionVar115::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var115(parsed)));
        }
        if let Some((inst_len, parsed)) = BITA_instructionVar116::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var116(parsed)));
        }
        if let Some((inst_len, parsed)) = BITA_instructionVar117::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var117(parsed)));
        }
        if let Some((inst_len, parsed)) = BITA_instructionVar118::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var118(parsed)));
        }
        if let Some((inst_len, parsed)) = BITA_instructionVar119::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var119(parsed)));
        }
        if let Some((inst_len, parsed)) = BITB_instructionVar120::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var120(parsed)));
        }
        if let Some((inst_len, parsed)) = BITB_instructionVar121::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var121(parsed)));
        }
        if let Some((inst_len, parsed)) = BITB_instructionVar122::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var122(parsed)));
        }
        if let Some((inst_len, parsed)) = BITB_instructionVar123::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var123(parsed)));
        }
        if let Some((inst_len, parsed)) = BLE_instructionVar124::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var124(parsed)));
        }
        if let Some((inst_len, parsed)) = BLS_instructionVar125::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var125(parsed)));
        }
        if let Some((inst_len, parsed)) = BLT_instructionVar126::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var126(parsed)));
        }
        if let Some((inst_len, parsed)) = BMI_instructionVar127::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var127(parsed)));
        }
        if let Some((inst_len, parsed)) = BNE_instructionVar128::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var128(parsed)));
        }
        if let Some((inst_len, parsed)) = BPL_instructionVar129::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var129(parsed)));
        }
        if let Some((inst_len, parsed)) = BRA_instructionVar130::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var130(parsed)));
        }
        if let Some((inst_len, parsed)) = BRCLR_instructionVar131::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var131(parsed)));
        }
        if let Some((inst_len, parsed)) = BRCLR_instructionVar132::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var132(parsed)));
        }
        if let Some((inst_len, parsed)) = BRCLR_instructionVar133::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var133(parsed)));
        }
        if let Some((inst_len, parsed)) = BRN_instructionVar134::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var134(parsed)));
        }
        if let Some((inst_len, parsed)) = BRSET_instructionVar135::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var135(parsed)));
        }
        if let Some((inst_len, parsed)) = BRSET_instructionVar136::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var136(parsed)));
        }
        if let Some((inst_len, parsed)) = BRSET_instructionVar137::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var137(parsed)));
        }
        if let Some((inst_len, parsed)) = BSET_instructionVar138::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var138(parsed)));
        }
        if let Some((inst_len, parsed)) = BSET_instructionVar139::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var139(parsed)));
        }
        if let Some((inst_len, parsed)) = BSET_instructionVar140::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var140(parsed)));
        }
        if let Some((inst_len, parsed)) = BSR_instructionVar141::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var141(parsed)));
        }
        if let Some((inst_len, parsed)) = BVC_instructionVar142::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var142(parsed)));
        }
        if let Some((inst_len, parsed)) = BVS_instructionVar143::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var143(parsed)));
        }
        if let Some((inst_len, parsed)) = CALL_instructionVar144::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var144(parsed)));
        }
        if let Some((inst_len, parsed)) = CALL_instructionVar145::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var145(parsed)));
        }
        if let Some((inst_len, parsed)) = CALL_instructionVar146::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var146(parsed)));
        }
        if let Some((inst_len, parsed)) = CBA_instructionVar147::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var147(parsed)));
        }
        if let Some((inst_len, parsed)) = CLR_instructionVar148::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var148(parsed)));
        }
        if let Some((inst_len, parsed)) = CLR_instructionVar149::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var149(parsed)));
        }
        if let Some((inst_len, parsed)) = CLRA_instructionVar150::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var150(parsed)));
        }
        if let Some((inst_len, parsed)) = CLRB_instructionVar151::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var151(parsed)));
        }
        if let Some((inst_len, parsed)) = CMPA_instructionVar152::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var152(parsed)));
        }
        if let Some((inst_len, parsed)) = CMPA_instructionVar153::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var153(parsed)));
        }
        if let Some((inst_len, parsed)) = CMPA_instructionVar154::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var154(parsed)));
        }
        if let Some((inst_len, parsed)) = CMPA_instructionVar155::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var155(parsed)));
        }
        if let Some((inst_len, parsed)) = CMPB_instructionVar156::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var156(parsed)));
        }
        if let Some((inst_len, parsed)) = CMPB_instructionVar157::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var157(parsed)));
        }
        if let Some((inst_len, parsed)) = CMPB_instructionVar158::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var158(parsed)));
        }
        if let Some((inst_len, parsed)) = CMPB_instructionVar159::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var159(parsed)));
        }
        if let Some((inst_len, parsed)) = COM_instructionVar160::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var160(parsed)));
        }
        if let Some((inst_len, parsed)) = COM_instructionVar161::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var161(parsed)));
        }
        if let Some((inst_len, parsed)) = COMA_instructionVar162::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var162(parsed)));
        }
        if let Some((inst_len, parsed)) = COMB_instructionVar163::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var163(parsed)));
        }
        if let Some((inst_len, parsed)) = CPD_instructionVar164::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var164(parsed)));
        }
        if let Some((inst_len, parsed)) = CPD_instructionVar165::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var165(parsed)));
        }
        if let Some((inst_len, parsed)) = CPD_instructionVar166::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var166(parsed)));
        }
        if let Some((inst_len, parsed)) = CPD_instructionVar167::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var167(parsed)));
        }
        if let Some((inst_len, parsed)) = CPS_instructionVar168::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var168(parsed)));
        }
        if let Some((inst_len, parsed)) = CPS_instructionVar169::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var169(parsed)));
        }
        if let Some((inst_len, parsed)) = CPS_instructionVar170::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var170(parsed)));
        }
        if let Some((inst_len, parsed)) = CPS_instructionVar171::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var171(parsed)));
        }
        if let Some((inst_len, parsed)) = CPX_instructionVar172::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var172(parsed)));
        }
        if let Some((inst_len, parsed)) = CPX_instructionVar173::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var173(parsed)));
        }
        if let Some((inst_len, parsed)) = CPX_instructionVar174::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var174(parsed)));
        }
        if let Some((inst_len, parsed)) = CPX_instructionVar175::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var175(parsed)));
        }
        if let Some((inst_len, parsed)) = CPY_instructionVar176::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var176(parsed)));
        }
        if let Some((inst_len, parsed)) = CPY_instructionVar177::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var177(parsed)));
        }
        if let Some((inst_len, parsed)) = CPY_instructionVar178::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var178(parsed)));
        }
        if let Some((inst_len, parsed)) = CPY_instructionVar179::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var179(parsed)));
        }
        if let Some((inst_len, parsed)) = DAA_instructionVar180::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var180(parsed)));
        }
        if let Some((inst_len, parsed)) = DEC_instructionVar181::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var181(parsed)));
        }
        if let Some((inst_len, parsed)) = DEC_instructionVar182::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var182(parsed)));
        }
        if let Some((inst_len, parsed)) = DECA_instructionVar183::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var183(parsed)));
        }
        if let Some((inst_len, parsed)) = DECB_instructionVar184::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var184(parsed)));
        }
        if let Some((inst_len, parsed)) = DEX_instructionVar185::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var185(parsed)));
        }
        if let Some((inst_len, parsed)) = DEY_instructionVar186::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var186(parsed)));
        }
        if let Some((inst_len, parsed)) = EDIV_instructionVar187::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var187(parsed)));
        }
        if let Some((inst_len, parsed)) = EDIVS_instructionVar188::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var188(parsed)));
        }
        if let Some((inst_len, parsed)) = EMACS_instructionVar189::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var189(parsed)));
        }
        if let Some((inst_len, parsed)) = EMAXD_instructionVar190::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var190(parsed)));
        }
        if let Some((inst_len, parsed)) = EMAXM_instructionVar191::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var191(parsed)));
        }
        if let Some((inst_len, parsed)) = EMIND_instructionVar192::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var192(parsed)));
        }
        if let Some((inst_len, parsed)) = EMINM_instructionVar193::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var193(parsed)));
        }
        if let Some((inst_len, parsed)) = EMUL_instructionVar194::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var194(parsed)));
        }
        if let Some((inst_len, parsed)) = EMULS_instructionVar195::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var195(parsed)));
        }
        if let Some((inst_len, parsed)) = EORA_instructionVar196::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var196(parsed)));
        }
        if let Some((inst_len, parsed)) = EORA_instructionVar197::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var197(parsed)));
        }
        if let Some((inst_len, parsed)) = EORA_instructionVar198::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var198(parsed)));
        }
        if let Some((inst_len, parsed)) = EORA_instructionVar199::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var199(parsed)));
        }
        if let Some((inst_len, parsed)) = EORB_instructionVar200::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var200(parsed)));
        }
        if let Some((inst_len, parsed)) = EORB_instructionVar201::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var201(parsed)));
        }
        if let Some((inst_len, parsed)) = EORB_instructionVar202::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var202(parsed)));
        }
        if let Some((inst_len, parsed)) = EORB_instructionVar203::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var203(parsed)));
        }
        if let Some((inst_len, parsed)) = ETBL_instructionVar204::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var204(parsed)));
        }
        if let Some((inst_len, parsed)) = FDIV_instructionVar205::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var205(parsed)));
        }
        if let Some((inst_len, parsed)) = IDIV_instructionVar206::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var206(parsed)));
        }
        if let Some((inst_len, parsed)) = IDIVS_instructionVar207::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var207(parsed)));
        }
        if let Some((inst_len, parsed)) = INC_instructionVar208::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var208(parsed)));
        }
        if let Some((inst_len, parsed)) = INC_instructionVar209::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var209(parsed)));
        }
        if let Some((inst_len, parsed)) = INCA_instructionVar210::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var210(parsed)));
        }
        if let Some((inst_len, parsed)) = INCB_instructionVar211::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var211(parsed)));
        }
        if let Some((inst_len, parsed)) = INX_instructionVar212::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var212(parsed)));
        }
        if let Some((inst_len, parsed)) = INY_instructionVar213::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var213(parsed)));
        }
        if let Some((inst_len, parsed)) = JMP_instructionVar214::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var214(parsed)));
        }
        if let Some((inst_len, parsed)) = JMP_instructionVar215::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var215(parsed)));
        }
        if let Some((inst_len, parsed)) = JSR_instructionVar216::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var216(parsed)));
        }
        if let Some((inst_len, parsed)) = JSR_instructionVar217::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var217(parsed)));
        }
        if let Some((inst_len, parsed)) = JSR_instructionVar218::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var218(parsed)));
        }
        if let Some((inst_len, parsed)) = LBCC_instructionVar219::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var219(parsed)));
        }
        if let Some((inst_len, parsed)) = LBCS_instructionVar220::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var220(parsed)));
        }
        if let Some((inst_len, parsed)) = LBEQ_instructionVar221::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var221(parsed)));
        }
        if let Some((inst_len, parsed)) = LBGE_instructionVar222::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var222(parsed)));
        }
        if let Some((inst_len, parsed)) = LBGT_instructionVar223::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var223(parsed)));
        }
        if let Some((inst_len, parsed)) = LBHI_instructionVar224::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var224(parsed)));
        }
        if let Some((inst_len, parsed)) = LBLE_instructionVar225::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var225(parsed)));
        }
        if let Some((inst_len, parsed)) = LBLS_instructionVar226::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var226(parsed)));
        }
        if let Some((inst_len, parsed)) = LBLT_instructionVar227::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var227(parsed)));
        }
        if let Some((inst_len, parsed)) = LBMI_instructionVar228::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var228(parsed)));
        }
        if let Some((inst_len, parsed)) = LBNE_instructionVar229::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var229(parsed)));
        }
        if let Some((inst_len, parsed)) = LBPL_instructionVar230::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var230(parsed)));
        }
        if let Some((inst_len, parsed)) = LBRA_instructionVar231::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var231(parsed)));
        }
        if let Some((inst_len, parsed)) = LBRN_instructionVar232::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var232(parsed)));
        }
        if let Some((inst_len, parsed)) = LBVC_instructionVar233::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var233(parsed)));
        }
        if let Some((inst_len, parsed)) = LBVS_instructionVar234::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var234(parsed)));
        }
        if let Some((inst_len, parsed)) = LDAA_instructionVar235::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var235(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar236::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var236(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar237::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var237(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar238::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var238(parsed)));
        }
        if let Some((inst_len, parsed)) = LDAB_instructionVar239::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var239(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar240::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var240(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar241::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var241(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar242::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var242(parsed)));
        }
        if let Some((inst_len, parsed)) = LDD_instructionVar243::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var243(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar244::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var244(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar245::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var245(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar246::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var246(parsed)));
        }
        if let Some((inst_len, parsed)) = LDS_instructionVar247::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var247(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar248::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var248(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar249::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var249(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar250::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var250(parsed)));
        }
        if let Some((inst_len, parsed)) = LDX_instructionVar251::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var251(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar252::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var252(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar253::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var253(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar254::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var254(parsed)));
        }
        if let Some((inst_len, parsed)) = LDY_instructionVar255::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var255(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar256::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var256(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar257::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var257(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar258::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var258(parsed)));
        }
        if let Some((inst_len, parsed)) = LEAS_instructionVar259::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var259(parsed)));
        }
        if let Some((inst_len, parsed)) = LEAX_instructionVar260::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var260(parsed)));
        }
        if let Some((inst_len, parsed)) = LEAY_instructionVar261::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var261(parsed)));
        }
        if let Some((inst_len, parsed)) = LSR_instructionVar262::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var262(parsed)));
        }
        if let Some((inst_len, parsed)) = LSR_instructionVar263::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var263(parsed)));
        }
        if let Some((inst_len, parsed)) = LSRA_instructionVar264::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var264(parsed)));
        }
        if let Some((inst_len, parsed)) = LSRB_instructionVar265::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var265(parsed)));
        }
        if let Some((inst_len, parsed)) = LSRD_instructionVar266::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var266(parsed)));
        }
        if let Some((inst_len, parsed)) = MAXA_instructionVar267::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var267(parsed)));
        }
        if let Some((inst_len, parsed)) = MAXM_instructionVar268::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var268(parsed)));
        }
        if let Some((inst_len, parsed)) = MEM_instructionVar269::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var269(parsed)));
        }
        if let Some((inst_len, parsed)) = MINA_instructionVar270::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var270(parsed)));
        }
        if let Some((inst_len, parsed)) = MINM_instructionVar271::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var271(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVB_instructionVar272::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var272(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVB_instructionVar273::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var273(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVB_instructionVar274::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var274(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVB_instructionVar275::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var275(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVB_instructionVar276::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var276(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVB_instructionVar277::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var277(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVW_instructionVar278::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var278(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVW_instructionVar279::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var279(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVW_instructionVar280::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var280(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVW_instructionVar281::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var281(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVW_instructionVar282::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var282(parsed)));
        }
        if let Some((inst_len, parsed)) = MOVW_instructionVar283::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var283(parsed)));
        }
        if let Some((inst_len, parsed)) = MUL_instructionVar284::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var284(parsed)));
        }
        if let Some((inst_len, parsed)) = NEG_instructionVar285::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var285(parsed)));
        }
        if let Some((inst_len, parsed)) = NEG_instructionVar286::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var286(parsed)));
        }
        if let Some((inst_len, parsed)) = NEGA_instructionVar287::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var287(parsed)));
        }
        if let Some((inst_len, parsed)) = NEGB_instructionVar288::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var288(parsed)));
        }
        if let Some((inst_len, parsed)) = NOP_instructionVar289::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var289(parsed)));
        }
        if let Some((inst_len, parsed)) = ORAA_instructionVar290::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var290(parsed)));
        }
        if let Some((inst_len, parsed)) = ORAA_instructionVar291::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var291(parsed)));
        }
        if let Some((inst_len, parsed)) = ORAA_instructionVar292::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var292(parsed)));
        }
        if let Some((inst_len, parsed)) = ORAA_instructionVar293::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var293(parsed)));
        }
        if let Some((inst_len, parsed)) = ORAB_instructionVar294::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var294(parsed)));
        }
        if let Some((inst_len, parsed)) = ORAB_instructionVar295::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var295(parsed)));
        }
        if let Some((inst_len, parsed)) = ORAB_instructionVar296::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var296(parsed)));
        }
        if let Some((inst_len, parsed)) = ORAB_instructionVar297::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var297(parsed)));
        }
        if let Some((inst_len, parsed)) = ORCC_instructionVar298::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var298(parsed)));
        }
        if let Some((inst_len, parsed)) = PSHA_instructionVar299::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var299(parsed)));
        }
        if let Some((inst_len, parsed)) = PSHB_instructionVar300::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var300(parsed)));
        }
        if let Some((inst_len, parsed)) = PSHC_instructionVar301::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var301(parsed)));
        }
        if let Some((inst_len, parsed)) = PSHD_instructionVar302::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var302(parsed)));
        }
        if let Some((inst_len, parsed)) = PSHX_instructionVar303::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var303(parsed)));
        }
        if let Some((inst_len, parsed)) = PSHY_instructionVar304::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var304(parsed)));
        }
        if let Some((inst_len, parsed)) = PULA_instructionVar305::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var305(parsed)));
        }
        if let Some((inst_len, parsed)) = PULB_instructionVar306::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var306(parsed)));
        }
        if let Some((inst_len, parsed)) = PULC_instructionVar307::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var307(parsed)));
        }
        if let Some((inst_len, parsed)) = PULD_instructionVar308::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var308(parsed)));
        }
        if let Some((inst_len, parsed)) = PULX_instructionVar309::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var309(parsed)));
        }
        if let Some((inst_len, parsed)) = PULY_instructionVar310::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var310(parsed)));
        }
        if let Some((inst_len, parsed)) = REV_instructionVar311::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var311(parsed)));
        }
        if let Some((inst_len, parsed)) = REVW_instructionVar312::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var312(parsed)));
        }
        if let Some((inst_len, parsed)) = ROL_instructionVar313::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var313(parsed)));
        }
        if let Some((inst_len, parsed)) = ROL_instructionVar314::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var314(parsed)));
        }
        if let Some((inst_len, parsed)) = ROLA_instructionVar315::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var315(parsed)));
        }
        if let Some((inst_len, parsed)) = ROLB_instructionVar316::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var316(parsed)));
        }
        if let Some((inst_len, parsed)) = ROR_instructionVar317::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var317(parsed)));
        }
        if let Some((inst_len, parsed)) = ROR_instructionVar318::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var318(parsed)));
        }
        if let Some((inst_len, parsed)) = RORA_instructionVar319::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var319(parsed)));
        }
        if let Some((inst_len, parsed)) = RORB_instructionVar320::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var320(parsed)));
        }
        if let Some((inst_len, parsed)) = RTC_instructionVar321::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var321(parsed)));
        }
        if let Some((inst_len, parsed)) = RTI_instructionVar322::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var322(parsed)));
        }
        if let Some((inst_len, parsed)) = RTS_instructionVar323::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var323(parsed)));
        }
        if let Some((inst_len, parsed)) = SBA_instructionVar324::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var324(parsed)));
        }
        if let Some((inst_len, parsed)) = SBCA_instructionVar325::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var325(parsed)));
        }
        if let Some((inst_len, parsed)) = SBCA_instructionVar326::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var326(parsed)));
        }
        if let Some((inst_len, parsed)) = SBCA_instructionVar327::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var327(parsed)));
        }
        if let Some((inst_len, parsed)) = SBCA_instructionVar328::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var328(parsed)));
        }
        if let Some((inst_len, parsed)) = SBCB_instructionVar329::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var329(parsed)));
        }
        if let Some((inst_len, parsed)) = SBCB_instructionVar330::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var330(parsed)));
        }
        if let Some((inst_len, parsed)) = SBCB_instructionVar331::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var331(parsed)));
        }
        if let Some((inst_len, parsed)) = SBCB_instructionVar332::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var332(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar333::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var333(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar334::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var334(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar335::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var335(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar336::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var336(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar337::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var337(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar338::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var338(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar339::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var339(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar340::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var340(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar341::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var341(parsed)));
        }
        if let Some((inst_len, parsed)) = STOP_instructionVar342::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var342(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar343::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var343(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar344::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var344(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar345::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var345(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar346::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var346(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar347::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var347(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar348::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var348(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar349::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var349(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar350::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var350(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar351::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var351(parsed)));
        }
        if let Some((inst_len, parsed)) = SUBA_instructionVar352::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var352(parsed)));
        }
        if let Some((inst_len, parsed)) = SUBA_instructionVar353::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var353(parsed)));
        }
        if let Some((inst_len, parsed)) = SUBA_instructionVar354::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var354(parsed)));
        }
        if let Some((inst_len, parsed)) = SUBA_instructionVar355::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var355(parsed)));
        }
        if let Some((inst_len, parsed)) = SUBB_instructionVar356::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var356(parsed)));
        }
        if let Some((inst_len, parsed)) = SUBB_instructionVar357::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var357(parsed)));
        }
        if let Some((inst_len, parsed)) = SUBB_instructionVar358::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var358(parsed)));
        }
        if let Some((inst_len, parsed)) = SUBB_instructionVar359::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var359(parsed)));
        }
        if let Some((inst_len, parsed)) = SUBD_instructionVar360::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var360(parsed)));
        }
        if let Some((inst_len, parsed)) = SUBD_instructionVar361::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var361(parsed)));
        }
        if let Some((inst_len, parsed)) = SUBD_instructionVar362::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var362(parsed)));
        }
        if let Some((inst_len, parsed)) = SUBD_instructionVar363::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var363(parsed)));
        }
        if let Some((inst_len, parsed)) = SWI_instructionVar364::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var364(parsed)));
        }
        if let Some((inst_len, parsed)) = TAB_instructionVar365::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var365(parsed)));
        }
        if let Some((inst_len, parsed)) = TBA_instructionVar366::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var366(parsed)));
        }
        if let Some((inst_len, parsed)) = TBL_instructionVar367::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var367(parsed)));
        }
        if let Some((inst_len, parsed)) = TRAP_instructionVar368::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var368(parsed)));
        }
        if let Some((inst_len, parsed)) = TST_instructionVar369::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var369(parsed)));
        }
        if let Some((inst_len, parsed)) = TST_instructionVar370::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var370(parsed)));
        }
        if let Some((inst_len, parsed)) = TSTA_instructionVar371::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var371(parsed)));
        }
        if let Some((inst_len, parsed)) = TSTB_instructionVar372::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var372(parsed)));
        }
        if let Some((inst_len, parsed)) = TSTX_instructionVar373::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var373(parsed)));
        }
        if let Some((inst_len, parsed)) = TSTY_instructionVar374::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var374(parsed)));
        }
        if let Some((inst_len, parsed)) = WAI_instructionVar375::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var375(parsed)));
        }
        if let Some((inst_len, parsed)) = WAV_instructionVar376::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var376(parsed)));
        }
        if let Some((inst_len, parsed)) = WAVR_instructionVar377::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var377(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:409:1, end:409:7))"]
#[derive(Clone, Debug)]
struct opr16aVar0 {
    imm16: TokenField_imm16,
}
impl opr16aVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 0i128 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:410:1, end:410:7))"]
#[derive(Clone, Debug)]
struct opr16aVar1 {
    imm16: TokenField_imm16,
}
impl opr16aVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 1i128 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:411:1, end:411:7))"]
#[derive(Clone, Debug)]
struct opr16aVar2 {
    imm16: TokenField_imm16,
}
impl opr16aVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 2i128 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:412:1, end:412:7))"]
#[derive(Clone, Debug)]
struct opr16aVar3 {
    imm16: TokenField_imm16,
}
impl opr16aVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 3i128 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:414:1, end:414:7))"]
#[derive(Clone, Debug)]
struct opr16aVar4 {
    imm16: TokenField_imm16,
}
impl opr16aVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 4i128 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:415:1, end:415:7))"]
#[derive(Clone, Debug)]
struct opr16aVar5 {
    imm16: TokenField_imm16,
}
impl opr16aVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 5i128 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:416:1, end:416:7))"]
#[derive(Clone, Debug)]
struct opr16aVar6 {
    imm16: TokenField_imm16,
}
impl opr16aVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 6i128 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:417:1, end:417:7))"]
#[derive(Clone, Debug)]
struct opr16aVar7 {
    imm16: TokenField_imm16,
}
impl opr16aVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 7i128 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:419:1, end:419:7))"]
#[derive(Clone, Debug)]
struct opr16aVar8 {
    imm16: TokenField_imm16,
}
impl opr16aVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 8i128 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:420:1, end:420:7))"]
#[derive(Clone, Debug)]
struct opr16aVar9 {
    imm16: TokenField_imm16,
}
impl opr16aVar9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 9i128 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:421:1, end:421:7))"]
#[derive(Clone, Debug)]
struct opr16aVar10 {
    imm16: TokenField_imm16,
}
impl opr16aVar10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 10i128 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:422:1, end:422:7))"]
#[derive(Clone, Debug)]
struct opr16aVar11 {
    imm16: TokenField_imm16,
}
impl opr16aVar11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 11i128 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:424:1, end:424:7))"]
#[derive(Clone, Debug)]
struct opr16aVar12 {
    imm16: TokenField_imm16,
}
impl opr16aVar12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 12i128 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:425:1, end:425:7))"]
#[derive(Clone, Debug)]
struct opr16aVar13 {
    imm16: TokenField_imm16,
}
impl opr16aVar13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 13i128 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:426:1, end:426:7))"]
#[derive(Clone, Debug)]
struct opr16aVar14 {
    imm16: TokenField_imm16,
}
impl opr16aVar14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 14i128 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:427:1, end:427:7))"]
#[derive(Clone, Debug)]
struct opr16aVar15 {
    imm16: TokenField_imm16,
}
impl opr16aVar15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 15i128 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[derive(Clone, Debug)]
enum Tableopr16a {
    Var0(opr16aVar0),
    Var1(opr16aVar1),
    Var2(opr16aVar2),
    Var3(opr16aVar3),
    Var4(opr16aVar4),
    Var5(opr16aVar5),
    Var6(opr16aVar6),
    Var7(opr16aVar7),
    Var8(opr16aVar8),
    Var9(opr16aVar9),
    Var10(opr16aVar10),
    Var11(opr16aVar11),
    Var12(opr16aVar12),
    Var13(opr16aVar13),
    Var14(opr16aVar14),
    Var15(opr16aVar15),
}
impl Tableopr16a {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            opr16aVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar12::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar13::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar14::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar15::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:429:1, end:429:5))"]
#[derive(Clone, Debug)]
struct pageVar0 {
    imm8: TokenField_imm8,
}
impl pageVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm8.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let imm8 = token_parser.TokenFieldimm8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablepage {
    Var0(pageVar0),
}
impl Tablepage {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            pageVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:431:1, end:431:9))"]
#[derive(Clone, Debug)]
struct PageDestVar0 {
    opr16a: Tableopr16a,
    page: Tablepage,
}
impl PageDestVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.opr16a.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let opr16a = if let Some((len, table)) = Tableopr16a::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let page = if let Some((len, table)) =
            Tablepage::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a, page }))
    }
}
#[derive(Clone, Debug)]
enum TablePageDest {
    Var0(PageDestVar0),
}
impl TablePageDest {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            PageDestVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:437:1, end:437:6))"]
#[derive(Clone, Debug)]
struct opr8aVar0 {
    imm8: TokenField_imm8,
}
impl opr8aVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm8.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let imm8 = token_parser.TokenFieldimm8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm8 }))
    }
}
#[derive(Clone, Debug)]
enum Tableopr8a {
    Var0(opr8aVar0),
}
impl Tableopr8a {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            opr8aVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:439:1, end:439:8))"]
#[derive(Clone, Debug)]
struct opr8a_8Var0 {
    imm8: TokenField_imm8,
}
impl opr8a_8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm8.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_UseGPAGE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let imm8 = token_parser.TokenFieldimm8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm8 }))
    }
}
#[derive(Clone, Debug)]
enum Tableopr8a_8 {
    Var0(opr8a_8Var0),
}
impl Tableopr8a_8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            opr8a_8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:440:1, end:440:9))"]
#[derive(Clone, Debug)]
struct opr8a_16Var0 {
    imm8: TokenField_imm8,
}
impl opr8a_16Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm8.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_UseGPAGE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let imm8 = token_parser.TokenFieldimm8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm8 }))
    }
}
#[derive(Clone, Debug)]
enum Tableopr8a_16 {
    Var0(opr8a_16Var0),
}
impl Tableopr8a_16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            opr8a_16Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:442:1, end:442:9))"]
#[derive(Clone, Debug)]
struct opr16a_8Var0 {
    opr16a: Tableopr16a,
}
impl opr16a_8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.opr16a.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let opr16a = if let Some((len, table)) = Tableopr16a::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a }))
    }
}
#[derive(Clone, Debug)]
enum Tableopr16a_8 {
    Var0(opr16a_8Var0),
}
impl Tableopr16a_8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            opr16a_8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:443:1, end:443:10))"]
#[derive(Clone, Debug)]
struct opr16a_16Var0 {
    opr16a: Tableopr16a,
}
impl opr16a_16Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.opr16a.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let opr16a = if let Some((len, table)) = Tableopr16a::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a }))
    }
}
#[derive(Clone, Debug)]
enum Tableopr16a_16 {
    Var0(opr16a_16Var0),
}
impl Tableopr16a_16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            opr16a_16Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:445:1, end:445:7))"]
#[derive(Clone, Debug)]
struct iopr8iVar0 {
    imm8: TokenField_imm8,
}
impl iopr8iVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.imm8.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let imm8 = token_parser.TokenFieldimm8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm8 }))
    }
}
#[derive(Clone, Debug)]
enum Tableiopr8i {
    Var0(iopr8iVar0),
}
impl Tableiopr8i {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            iopr8iVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:446:1, end:446:8))"]
#[derive(Clone, Debug)]
struct iopr16iVar0 {
    imm16: TokenField_imm16,
}
impl iopr16iVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let imm16 = token_parser.TokenFieldimm16();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[derive(Clone, Debug)]
enum Tableiopr16i {
    Var0(iopr16iVar0),
}
impl Tableiopr16i {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            iopr16iVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:447:1, end:447:5))"]
#[derive(Clone, Debug)]
struct msk8Var0 {
    imm8: TokenField_imm8,
}
impl msk8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm8.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let imm8 = token_parser.TokenFieldimm8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablemsk8 {
    Var0(msk8Var0),
}
impl Tablemsk8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            msk8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:467:1, end:467:6))"]
#[derive(Clone, Debug)]
struct IDX_aVar0 {
    rr7_6: TokenField_rr7_6,
}
impl IDX_aVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("0,"), self.rr7_6.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb5_5().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldnn4_0().disassembly() != 0i128 {
            return None;
        }
        let rr7_6 = token_parser.TokenFieldrr7_6();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr7_6 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_a {
    Var0(IDX_aVar0),
}
impl TableIDX_a {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_aVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:471:1, end:471:6))"]
#[derive(Clone, Debug)]
struct IDX_bVar0 {
    nn4_0: TokenField_nn4_0,
    rr7_6: TokenField_rr7_6,
}
impl IDX_bVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            self.nn4_0.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.rr7_6.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb5_5().disassembly() != 0i128 {
            return None;
        }
        let rr7_6 = token_parser.TokenFieldrr7_6();
        let nn4_0 = token_parser.TokenFieldnn4_0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr7_6, nn4_0 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_b {
    Var0(IDX_bVar0),
}
impl TableIDX_b {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_bVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:479:1, end:479:6))"]
#[derive(Clone, Debug)]
struct IDX_cVar0 {
    nn3_0: TokenField_nn3_0,
    rr7_6a: TokenField_rr7_6a,
}
impl IDX_cVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            self.nn3_0.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("-"),
            self.rr7_6a.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldp4_4().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFielddecrement3_3().disassembly() != 1i128 {
            return None;
        }
        let mut sub_pattern_c27 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 1i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 3i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 5i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c27(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let rr7_6a = token_parser.TokenFieldrr7_6a();
        let nn3_0 = token_parser.TokenFieldnn3_0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr7_6a, nn3_0 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_c {
    Var0(IDX_cVar0),
}
impl TableIDX_c {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_cVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:483:1, end:483:6))"]
#[derive(Clone, Debug)]
struct IDX_dVar0 {
    nn3_0: TokenField_nn3_0,
    rr7_6a: TokenField_rr7_6a,
}
impl IDX_dVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            self.nn3_0.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("+"),
            self.rr7_6a.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldp4_4().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFielddecrement3_3().disassembly() != 0i128 {
            return None;
        }
        let mut sub_pattern_c27 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 1i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 3i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 5i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c27(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let rr7_6a = token_parser.TokenFieldrr7_6a();
        let nn3_0 = token_parser.TokenFieldnn3_0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr7_6a, nn3_0 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_d {
    Var0(IDX_dVar0),
}
impl TableIDX_d {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_dVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:487:1, end:487:6))"]
#[derive(Clone, Debug)]
struct IDX_eVar0 {
    nn3_0: TokenField_nn3_0,
    rr7_6a: TokenField_rr7_6a,
}
impl IDX_eVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            self.nn3_0.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.rr7_6a.display(),
            DisplayElement::Literal("-"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldp4_4().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFielddecrement3_3().disassembly() != 1i128 {
            return None;
        }
        let mut sub_pattern_c27 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 1i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 3i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 5i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c27(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let rr7_6a = token_parser.TokenFieldrr7_6a();
        let nn3_0 = token_parser.TokenFieldnn3_0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr7_6a, nn3_0 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_e {
    Var0(IDX_eVar0),
}
impl TableIDX_e {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_eVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:491:1, end:491:6))"]
#[derive(Clone, Debug)]
struct IDX_fVar0 {
    nn3_0: TokenField_nn3_0,
    rr7_6a: TokenField_rr7_6a,
}
impl IDX_fVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            self.nn3_0.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.rr7_6a.display(),
            DisplayElement::Literal("+"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldp4_4().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFielddecrement3_3().disassembly() != 0i128 {
            return None;
        }
        let mut sub_pattern_c27 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 1i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 3i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 5i128 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c27(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let rr7_6a = token_parser.TokenFieldrr7_6a();
        let nn3_0 = token_parser.TokenFieldnn3_0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr7_6a, nn3_0 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_f {
    Var0(IDX_fVar0),
}
impl TableIDX_f {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_fVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:499:1, end:499:6))"]
#[derive(Clone, Debug)]
struct IDX_gVar0 {
    aa0_0: TokenField_aa0_0,
}
impl IDX_gVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            self.aa0_0.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::PC),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb7_5().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldrr4_3().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldxb2_1().disassembly() != 2i128 {
            return None;
        }
        let aa0_0 = token_parser.TokenFieldaa0_0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { aa0_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:497:1, end:497:6))"]
#[derive(Clone, Debug)]
struct IDX_gVar1 {
    aa0_0: TokenField_aa0_0,
    rr4_3: TokenField_rr4_3,
}
impl IDX_gVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            self.aa0_0.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.rr4_3.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb7_5().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldxb2_1().disassembly() != 2i128 {
            return None;
        }
        let rr4_3 = token_parser.TokenFieldrr4_3();
        let aa0_0 = token_parser.TokenFieldaa0_0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr4_3, aa0_0 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_g {
    Var0(IDX_gVar0),
    Var1(IDX_gVar1),
}
impl TableIDX_g {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_gVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            IDX_gVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:505:1, end:505:6))"]
#[derive(Clone, Debug)]
struct IDX_hVar0 {}
impl IDX_hVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Register(Register::D),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::PC),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb7_5().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldrr4_3().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldxb2_0().disassembly() != 6i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:503:1, end:503:6))"]
#[derive(Clone, Debug)]
struct IDX_hVar1 {
    rr4_3: TokenField_rr4_3,
}
impl IDX_hVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Register(Register::D),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.rr4_3.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb7_5().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldxb2_0().disassembly() != 6i128 {
            return None;
        }
        let rr4_3 = token_parser.TokenFieldrr4_3();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr4_3 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_h {
    Var0(IDX_hVar0),
    Var1(IDX_hVar1),
}
impl TableIDX_h {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_hVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            IDX_hVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:519:1, end:519:6))"]
#[derive(Clone, Debug)]
struct IDX_iVar0 {
    ss0_0: TokenField_ss0_0,
    imm8: TokenField_imm8,
    IDX_i_PCRel: TableIDX_i_PCRel,
}
impl IDX_iVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_opr9: i128 = 0;
        calc_opr9 = (u32::try_from(8i128)
            .ok()
            .map(|shl| self.ss0_0.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            | self.imm8.disassembly());
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Number(true, calc_opr9),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::PC),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_opr9: i128 = 0;
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        calc_opr9 = (u32::try_from(8i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldss0_0()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldimm8().disassembly());
        let mut sub_pattern_c22 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldxb7_5().disassembly() != 7i128 {
                return None;
            }
            if token_parser.TokenFieldrr4_3().disassembly() != 3i128 {
                return None;
            }
            if token_parser.TokenFieldxb2_2().disassembly() != 0i128 {
                return None;
            }
            if token_parser.TokenFieldz1_1().disassembly() != 0i128 {
                return None;
            }
            let ss0_0 = token_parser.TokenFieldss0_0();
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            let imm8 = token_parser.TokenFieldimm8();
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (ss0_0, imm8), pattern_len))
        };
        let ((), (ss0_0, imm8), sub_len) =
            sub_pattern_c22(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let IDX_i_PCRel = if let Some((len, table)) = TableIDX_i_PCRel::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                IDX_i_PCRel,
                ss0_0,
                imm8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:515:1, end:515:6))"]
#[derive(Clone, Debug)]
struct IDX_iVar1 {
    rr4_3: TokenField_rr4_3,
    ss0_0: TokenField_ss0_0,
    imm8: TokenField_imm8,
}
impl IDX_iVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_opr9: i128 = 0;
        calc_opr9 = (u32::try_from(8i128)
            .ok()
            .map(|shl| self.ss0_0.disassembly().checked_shl(shl))
            .flatten()
            .unwrap_or(0)
            | self.imm8.disassembly());
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Number(true, calc_opr9),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.rr4_3.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_opr9: i128 = 0;
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb7_5().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldxb2_2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldz1_1().disassembly() != 0i128 {
            return None;
        }
        let rr4_3 = token_parser.TokenFieldrr4_3();
        let ss0_0 = token_parser.TokenFieldss0_0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        calc_opr9 = (u32::try_from(8i128)
            .ok()
            .map(|shl| {
                token_parser
                    .TokenFieldss0_0()
                    .disassembly()
                    .checked_shl(shl)
            })
            .flatten()
            .unwrap_or(0)
            | token_parser.TokenFieldimm8().disassembly());
        let imm8 = token_parser.TokenFieldimm8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr4_3, ss0_0, imm8 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_i {
    Var0(IDX_iVar0),
    Var1(IDX_iVar1),
}
impl TableIDX_i {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_iVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            IDX_iVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:518:1, end:518:12))"]
#[derive(Clone, Debug)]
struct IDX_i_PCRelVar0 {
    ss0_0: TokenField_ss0_0,
    imm8: TokenField_imm8,
}
impl IDX_i_PCRelVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_target: i128 = 0;
        calc_target = i128::try_from(inst_next).unwrap().wrapping_add(
            (u32::try_from(8i128)
                .ok()
                .map(|shl| self.ss0_0.disassembly().checked_shl(shl))
                .flatten()
                .unwrap_or(0)
                | self.imm8.disassembly()),
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_target)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_target: i128 = 0;
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let ss0_0 = token_parser.TokenFieldss0_0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let imm8 = token_parser.TokenFieldimm8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ss0_0, imm8 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_i_PCRel {
    Var0(IDX_i_PCRelVar0),
}
impl TableIDX_i_PCRel {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = IDX_i_PCRelVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:533:1, end:533:6))"]
#[derive(Clone, Debug)]
struct IDX_kVar0 {
    simm16: TokenField_simm16,
    IDX_k_PCRel: TableIDX_k_PCRel,
}
impl IDX_kVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            self.simm16.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::PC),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb7_5().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldrr4_3().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldxb2_2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldz1_1().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFields0_0().disassembly() != 0i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let IDX_k_PCRel = if let Some((len, table)) = TableIDX_k_PCRel::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let simm16 = token_parser.TokenFieldsimm16();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                IDX_k_PCRel,
                simm16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:529:1, end:529:6))"]
#[derive(Clone, Debug)]
struct IDX_kVar1 {
    simm16: TokenField_simm16,
    rr4_3: TokenField_rr4_3,
}
impl IDX_kVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            self.simm16.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.rr4_3.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb7_5().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldxb2_2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldz1_1().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFields0_0().disassembly() != 0i128 {
            return None;
        }
        let rr4_3 = token_parser.TokenFieldrr4_3();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let simm16 = token_parser.TokenFieldsimm16();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr4_3, simm16 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_k {
    Var0(IDX_kVar0),
    Var1(IDX_kVar1),
}
impl TableIDX_k {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_kVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            IDX_kVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:532:1, end:532:12))"]
#[derive(Clone, Debug)]
struct IDX_k_PCRelVar0 {
    simm16: TokenField_simm16,
}
impl IDX_k_PCRelVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_target: i128 = 0;
        calc_target = i128::try_from(inst_next)
            .unwrap()
            .wrapping_add(self.simm16.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_target)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_target: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let simm16 = token_parser.TokenFieldsimm16();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { simm16 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_k_PCRel {
    Var0(IDX_k_PCRelVar0),
}
impl TableIDX_k_PCRel {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = IDX_k_PCRelVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:548:1, end:548:6))"]
#[derive(Clone, Debug)]
struct IDX_lVar0 {
    simm16: TokenField_simm16,
    IDX_l_PCRel: TableIDX_l_PCRel,
}
impl IDX_lVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("["),
            self.simm16.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::PC),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb7_5().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldrr4_3().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldxb2_2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldz1_1().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFields0_0().disassembly() != 1i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let IDX_l_PCRel = if let Some((len, table)) = TableIDX_l_PCRel::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let simm16 = token_parser.TokenFieldsimm16();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                IDX_l_PCRel,
                simm16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:544:1, end:544:6))"]
#[derive(Clone, Debug)]
struct IDX_lVar1 {
    simm16: TokenField_simm16,
    rr4_3: TokenField_rr4_3,
}
impl IDX_lVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("["),
            self.simm16.display(),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.rr4_3.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb7_5().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldxb2_2().disassembly() != 0i128 {
            return None;
        }
        if token_parser.TokenFieldz1_1().disassembly() != 1i128 {
            return None;
        }
        if token_parser.TokenFields0_0().disassembly() != 1i128 {
            return None;
        }
        let rr4_3 = token_parser.TokenFieldrr4_3();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let simm16 = token_parser.TokenFieldsimm16();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr4_3, simm16 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_l {
    Var0(IDX_lVar0),
    Var1(IDX_lVar1),
}
impl TableIDX_l {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_lVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            IDX_lVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:547:1, end:547:12))"]
#[derive(Clone, Debug)]
struct IDX_l_PCRelVar0 {
    simm16: TokenField_simm16,
}
impl IDX_l_PCRelVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_target: i128 = 0;
        calc_target = i128::try_from(inst_next)
            .unwrap()
            .wrapping_add(self.simm16.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_target)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_target: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let simm16 = token_parser.TokenFieldsimm16();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { simm16 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_l_PCRel {
    Var0(IDX_l_PCRelVar0),
}
impl TableIDX_l_PCRel {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = IDX_l_PCRelVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:561:1, end:561:6))"]
#[derive(Clone, Debug)]
struct IDX_mVar0 {}
impl IDX_mVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("["),
            DisplayElement::Register(Register::D),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::PC),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb7_5().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldrr4_3().disassembly() != 3i128 {
            return None;
        }
        if token_parser.TokenFieldxb2_0().disassembly() != 7i128 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:558:1, end:558:6))"]
#[derive(Clone, Debug)]
struct IDX_mVar1 {
    rr4_3: TokenField_rr4_3,
}
impl IDX_mVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("["),
            DisplayElement::Register(Register::D),
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.rr4_3.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb7_5().disassembly() != 7i128 {
            return None;
        }
        if token_parser.TokenFieldxb2_0().disassembly() != 7i128 {
            return None;
        }
        let rr4_3 = token_parser.TokenFieldrr4_3();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr4_3 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_m {
    Var0(IDX_mVar0),
    Var1(IDX_mVar1),
}
impl TableIDX_m {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_mVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            IDX_mVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:569:1, end:569:9))"]
#[derive(Clone, Debug)]
struct indexed3Var0 {
    IDX_a: TableIDX_a,
}
impl indexed3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_a.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_a = if let Some((len, table)) =
            TableIDX_a::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_a }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:570:1, end:570:9))"]
#[derive(Clone, Debug)]
struct indexed3Var1 {
    IDX_b: TableIDX_b,
}
impl indexed3Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_b.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_b = if let Some((len, table)) =
            TableIDX_b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_b }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:571:1, end:571:9))"]
#[derive(Clone, Debug)]
struct indexed3Var2 {
    IDX_c: TableIDX_c,
}
impl indexed3Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_c.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_c = if let Some((len, table)) =
            TableIDX_c::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_c }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:572:1, end:572:9))"]
#[derive(Clone, Debug)]
struct indexed3Var3 {
    IDX_d: TableIDX_d,
}
impl indexed3Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_d.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_d = if let Some((len, table)) =
            TableIDX_d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_d }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:573:1, end:573:9))"]
#[derive(Clone, Debug)]
struct indexed3Var4 {
    IDX_e: TableIDX_e,
}
impl indexed3Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_e.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_e = if let Some((len, table)) =
            TableIDX_e::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_e }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:574:1, end:574:9))"]
#[derive(Clone, Debug)]
struct indexed3Var5 {
    IDX_f: TableIDX_f,
}
impl indexed3Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_f.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_f = if let Some((len, table)) =
            TableIDX_f::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_f }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:575:1, end:575:9))"]
#[derive(Clone, Debug)]
struct indexed3Var6 {
    IDX_g: TableIDX_g,
}
impl indexed3Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_g.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_g = if let Some((len, table)) =
            TableIDX_g::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_g }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:576:1, end:576:9))"]
#[derive(Clone, Debug)]
struct indexed3Var7 {
    IDX_h: TableIDX_h,
}
impl indexed3Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_h.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_h = if let Some((len, table)) =
            TableIDX_h::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_h }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:577:1, end:577:9))"]
#[derive(Clone, Debug)]
struct indexed3Var8 {
    IDX_i: TableIDX_i,
}
impl indexed3Var8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_i = if let Some((len, table)) =
            TableIDX_i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:578:1, end:578:9))"]
#[derive(Clone, Debug)]
struct indexed3Var9 {
    IDX_k: TableIDX_k,
}
impl indexed3Var9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_k.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_k = if let Some((len, table)) =
            TableIDX_k::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_k }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed3 {
    Var0(indexed3Var0),
    Var1(indexed3Var1),
    Var2(indexed3Var2),
    Var3(indexed3Var3),
    Var4(indexed3Var4),
    Var5(indexed3Var5),
    Var6(indexed3Var6),
    Var7(indexed3Var7),
    Var8(indexed3Var8),
    Var9(indexed3Var9),
}
impl Tableindexed3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            indexed3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed3Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed3Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed3Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed3Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed3Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed3Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed3Var7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed3Var8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed3Var9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:596:1, end:596:9))"]
#[derive(Clone, Debug)]
struct indexed2Var0 {
    IDX_l: TableIDX_l,
}
impl indexed2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_l.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_l = if let Some((len, table)) =
            TableIDX_l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:597:1, end:597:9))"]
#[derive(Clone, Debug)]
struct indexed2Var1 {
    IDX_m: TableIDX_m,
}
impl indexed2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_m.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_m = if let Some((len, table)) =
            TableIDX_m::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_m }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed2 {
    Var0(indexed2Var0),
    Var1(indexed2Var1),
}
impl Tableindexed2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            indexed2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:603:1, end:603:9))"]
#[derive(Clone, Debug)]
struct indexed5Var0 {
    IDX_a: TableIDX_a,
}
impl indexed5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_a.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_a = if let Some((len, table)) =
            TableIDX_a::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_a }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:604:1, end:604:9))"]
#[derive(Clone, Debug)]
struct indexed5Var1 {
    IDX_b: TableIDX_b,
}
impl indexed5Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_b.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_b = if let Some((len, table)) =
            TableIDX_b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_b }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:605:1, end:605:9))"]
#[derive(Clone, Debug)]
struct indexed5Var2 {
    IDX_c: TableIDX_c,
}
impl indexed5Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_c.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_c = if let Some((len, table)) =
            TableIDX_c::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_c }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:606:1, end:606:9))"]
#[derive(Clone, Debug)]
struct indexed5Var3 {
    IDX_d: TableIDX_d,
}
impl indexed5Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_d.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_d = if let Some((len, table)) =
            TableIDX_d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_d }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:607:1, end:607:9))"]
#[derive(Clone, Debug)]
struct indexed5Var4 {
    IDX_e: TableIDX_e,
}
impl indexed5Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_e.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_e = if let Some((len, table)) =
            TableIDX_e::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_e }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:608:1, end:608:9))"]
#[derive(Clone, Debug)]
struct indexed5Var5 {
    IDX_f: TableIDX_f,
}
impl indexed5Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_f.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_f = if let Some((len, table)) =
            TableIDX_f::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_f }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:609:1, end:609:9))"]
#[derive(Clone, Debug)]
struct indexed5Var6 {
    IDX_g: TableIDX_g,
}
impl indexed5Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_g.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_g = if let Some((len, table)) =
            TableIDX_g::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_g }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:610:1, end:610:9))"]
#[derive(Clone, Debug)]
struct indexed5Var7 {
    IDX_h: TableIDX_h,
}
impl indexed5Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_h.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_h = if let Some((len, table)) =
            TableIDX_h::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_h }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:611:1, end:611:9))"]
#[derive(Clone, Debug)]
struct indexed5Var8 {
    IDX_i: TableIDX_i,
}
impl indexed5Var8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_i = if let Some((len, table)) =
            TableIDX_i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:612:1, end:612:9))"]
#[derive(Clone, Debug)]
struct indexed5Var9 {
    IDX_k: TableIDX_k,
}
impl indexed5Var9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_k.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_k = if let Some((len, table)) =
            TableIDX_k::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_k }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:613:1, end:613:9))"]
#[derive(Clone, Debug)]
struct indexed5Var10 {
    IDX_l: TableIDX_l,
}
impl indexed5Var10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_l.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_l = if let Some((len, table)) =
            TableIDX_l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:614:1, end:614:9))"]
#[derive(Clone, Debug)]
struct indexed5Var11 {
    IDX_m: TableIDX_m,
}
impl indexed5Var11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_m.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_m = if let Some((len, table)) =
            TableIDX_m::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_m }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed5 {
    Var0(indexed5Var0),
    Var1(indexed5Var1),
    Var2(indexed5Var2),
    Var3(indexed5Var3),
    Var4(indexed5Var4),
    Var5(indexed5Var5),
    Var6(indexed5Var6),
    Var7(indexed5Var7),
    Var8(indexed5Var8),
    Var9(indexed5Var9),
    Var10(indexed5Var10),
    Var11(indexed5Var11),
}
impl Tableindexed5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            indexed5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed5Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed5Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed5Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed5Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed5Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed5Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed5Var7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed5Var8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed5Var9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed5Var10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed5Var11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:619:1, end:619:9))"]
#[derive(Clone, Debug)]
struct indexed1Var0 {
    IDX_a: TableIDX_a,
}
impl indexed1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_a.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_a = if let Some((len, table)) =
            TableIDX_a::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_a }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:620:1, end:620:9))"]
#[derive(Clone, Debug)]
struct indexed1Var1 {
    IDX_b: TableIDX_b,
}
impl indexed1Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_b.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_b = if let Some((len, table)) =
            TableIDX_b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_b }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:621:1, end:621:9))"]
#[derive(Clone, Debug)]
struct indexed1Var2 {
    IDX_c: TableIDX_c,
}
impl indexed1Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_c.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_c = if let Some((len, table)) =
            TableIDX_c::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_c }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:622:1, end:622:9))"]
#[derive(Clone, Debug)]
struct indexed1Var3 {
    IDX_d: TableIDX_d,
}
impl indexed1Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_d.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_d = if let Some((len, table)) =
            TableIDX_d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_d }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:623:1, end:623:9))"]
#[derive(Clone, Debug)]
struct indexed1Var4 {
    IDX_e: TableIDX_e,
}
impl indexed1Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_e.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_e = if let Some((len, table)) =
            TableIDX_e::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_e }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:624:1, end:624:9))"]
#[derive(Clone, Debug)]
struct indexed1Var5 {
    IDX_f: TableIDX_f,
}
impl indexed1Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_f.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_f = if let Some((len, table)) =
            TableIDX_f::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_f }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:625:1, end:625:9))"]
#[derive(Clone, Debug)]
struct indexed1Var6 {
    IDX_g: TableIDX_g,
}
impl indexed1Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_g.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_g = if let Some((len, table)) =
            TableIDX_g::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_g }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:626:1, end:626:9))"]
#[derive(Clone, Debug)]
struct indexed1Var7 {
    IDX_h: TableIDX_h,
}
impl indexed1Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_h.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_h = if let Some((len, table)) =
            TableIDX_h::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_h }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed1 {
    Var0(indexed1Var0),
    Var1(indexed1Var1),
    Var2(indexed1Var2),
    Var3(indexed1Var3),
    Var4(indexed1Var4),
    Var5(indexed1Var5),
    Var6(indexed1Var6),
    Var7(indexed1Var7),
}
impl Tableindexed1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            indexed1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed1Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed1Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed1Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed1Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed1Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed1Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed1Var7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:640:1, end:640:11))"]
#[derive(Clone, Debug)]
struct indexed1_1Var0 {
    indexed1: Tableindexed1,
}
impl indexed1_1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.indexed1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let indexed1 = if let Some((len, table)) = Tableindexed1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed1_1 {
    Var0(indexed1_1Var0),
}
impl Tableindexed1_1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexed1_1Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:648:1, end:648:11))"]
#[derive(Clone, Debug)]
struct indexed2_1Var0 {
    indexed1: Tableindexed1,
}
impl indexed2_1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.indexed1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let indexed1 = if let Some((len, table)) = Tableindexed1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed2_1 {
    Var0(indexed2_1Var0),
}
impl Tableindexed2_1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexed2_1Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:660:1, end:660:11))"]
#[derive(Clone, Debug)]
struct indexed0_2Var0 {
    indexed2: Tableindexed2,
}
impl indexed0_2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.indexed2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let indexed2 = if let Some((len, table)) = Tableindexed2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed0_2 {
    Var0(indexed0_2Var0),
}
impl Tableindexed0_2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexed0_2Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:666:1, end:666:11))"]
#[derive(Clone, Debug)]
struct indexed0_3Var0 {
    indexed3: Tableindexed3,
}
impl indexed0_3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.indexed3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let indexed3 = if let Some((len, table)) = Tableindexed3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed3 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed0_3 {
    Var0(indexed0_3Var0),
}
impl Tableindexed0_3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexed0_3Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:670:1, end:670:11))"]
#[derive(Clone, Debug)]
struct indexed1_3Var0 {
    indexed3: Tableindexed3,
}
impl indexed1_3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.indexed3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let indexed3 = if let Some((len, table)) = Tableindexed3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed3 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed1_3 {
    Var0(indexed1_3Var0),
}
impl Tableindexed1_3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexed1_3Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:682:1, end:682:11))"]
#[derive(Clone, Debug)]
struct indexed2_3Var0 {
    indexed3: Tableindexed3,
}
impl indexed2_3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.indexed3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let indexed3 = if let Some((len, table)) = Tableindexed3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed3 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed2_3 {
    Var0(indexed2_3Var0),
}
impl Tableindexed2_3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexed2_3Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:690:1, end:690:11))"]
#[derive(Clone, Debug)]
struct indexedA_5Var0 {
    indexed5: Tableindexed5,
}
impl indexedA_5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.indexed5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_UseGPAGE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let indexed5 = if let Some((len, table)) = Tableindexed5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed5 }))
    }
}
#[derive(Clone, Debug)]
enum TableindexedA_5 {
    Var0(indexedA_5Var0),
}
impl TableindexedA_5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexedA_5Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:709:1, end:709:11))"]
#[derive(Clone, Debug)]
struct indexed1_5Var0 {
    indexed5: Tableindexed5,
}
impl indexed1_5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.indexed5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_UseGPAGE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let indexed5 = if let Some((len, table)) = Tableindexed5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed5 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed1_5 {
    Var0(indexed1_5Var0),
}
impl Tableindexed1_5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexed1_5Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:728:1, end:728:11))"]
#[derive(Clone, Debug)]
struct indexed2_5Var0 {
    indexed5: Tableindexed5,
}
impl indexed2_5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.indexed5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_UseGPAGE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let indexed5 = if let Some((len, table)) = Tableindexed5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed5 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed2_5 {
    Var0(indexed2_5Var0),
}
impl Tableindexed2_5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexed2_5Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:747:1, end:747:5))"]
#[derive(Clone, Debug)]
struct rel8Var0 {
    rel: TokenField_rel,
}
impl rel8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_next)
            .unwrap()
            .wrapping_add(self.rel.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let rel = token_parser.TokenFieldrel();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel }))
    }
}
#[derive(Clone, Debug)]
enum Tablerel8 {
    Var0(rel8Var0),
}
impl Tablerel8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            rel8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:750:1, end:750:5))"]
#[derive(Clone, Debug)]
struct rel9Var0 {
    sign12_12: TokenField_sign12_12,
    rr7_0: TokenField_rr7_0,
}
impl rel9Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_next).unwrap().wrapping_add(
            (u32::try_from(8i128)
                .ok()
                .map(|shl| self.sign12_12.disassembly().checked_shl(shl))
                .flatten()
                .unwrap_or(0)
                | self.rr7_0.disassembly()),
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let sign12_12 = token_parser.TokenFieldsign12_12();
        let rr7_0 = token_parser.TokenFieldrr7_0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sign12_12, rr7_0 }))
    }
}
#[derive(Clone, Debug)]
enum Tablerel9 {
    Var0(rel9Var0),
}
impl Tablerel9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            rel9Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:753:1, end:753:6))"]
#[derive(Clone, Debug)]
struct rel16Var0 {
    simm16: TokenField_simm16,
}
impl rel16Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_next)
            .unwrap()
            .wrapping_add(self.simm16.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let simm16 = token_parser.TokenFieldsimm16();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { simm16 }))
    }
}
#[derive(Clone, Debug)]
enum Tablerel16 {
    Var0(rel16Var0),
}
impl Tablerel16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            rel16Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:756:1, end:756:13))"]
#[derive(Clone, Debug)]
struct op2_opr16a_8Var0 {
    opr16a_8: Tableopr16a_8,
}
impl op2_opr16a_8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[derive(Clone, Debug)]
enum Tableop2_opr16a_8 {
    Var0(op2_opr16a_8Var0),
}
impl Tableop2_opr16a_8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = op2_opr16a_8Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:757:1, end:757:14))"]
#[derive(Clone, Debug)]
struct op2_opr16a_16Var0 {
    opr16a_16: Tableopr16a_16,
}
impl op2_opr16a_16Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_16 }))
    }
}
#[derive(Clone, Debug)]
enum Tableop2_opr16a_16 {
    Var0(op2_opr16a_16Var0),
}
impl Tableop2_opr16a_16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = op2_opr16a_16Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:762:1, end:762:15))"]
#[derive(Clone, Debug)]
struct op2_indexed1_1Var0 {
    indexed1_1: Tableindexed1_1,
}
impl op2_indexed1_1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.indexed1_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let indexed1_1 = if let Some((len, table)) = Tableindexed1_1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_1 }))
    }
}
#[derive(Clone, Debug)]
enum Tableop2_indexed1_1 {
    Var0(op2_indexed1_1Var0),
}
impl Tableop2_indexed1_1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = op2_indexed1_1Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:768:1, end:768:15))"]
#[derive(Clone, Debug)]
struct op2_indexed2_1Var0 {
    indexed2_1: Tableindexed2_1,
}
impl op2_indexed2_1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.indexed2_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let indexed2_1 = if let Some((len, table)) = Tableindexed2_1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_1 }))
    }
}
#[derive(Clone, Debug)]
enum Tableop2_indexed2_1 {
    Var0(op2_indexed2_1Var0),
}
impl Tableop2_indexed2_1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = op2_indexed2_1Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1964:1, end:1964:14))"]
#[derive(Clone, Debug)]
struct SkipNextInstrVar0 {}
impl SkipNextInstrVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_dest: i128 = 0;
        calc_dest = i128::try_from(inst_next).unwrap().wrapping_add(1i128);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_dest)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_dest: i128 = 0;
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSkipNextInstr {
    Var0(SkipNextInstrVar0),
}
impl TableSkipNextInstr {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = SkipNextInstrVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2072:1, end:2072:9))"]
#[derive(Clone, Debug)]
struct CallDestVar0 {
    imm8: TokenField_imm8,
    PageDest: TablePageDest,
}
impl CallDestVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.PageDest.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal(" "),
            self.imm8.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let mut sub_pattern_c30 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2u64 as u32;
            let token_parser = <TokenParser<2usize>>::new(tokens)?;
            let imm16 = token_parser.TokenFieldimm16();
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            let imm8 = token_parser.TokenFieldimm8();
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (imm16, imm8), pattern_len))
        };
        let ((), (imm16, imm8), sub_len) =
            sub_pattern_c30(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let PageDest = if let Some((len, table)) = TablePageDest::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PageDest, imm8 }))
    }
}
#[derive(Clone, Debug)]
enum TableCallDest {
    Var0(CallDestVar0),
}
impl TableCallDest {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            CallDestVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2633:1, end:2633:15))"]
#[derive(Clone, Debug)]
struct SkipNext2BytesVar0 {}
impl SkipNext2BytesVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_dest: i128 = 0;
        calc_dest = i128::try_from(inst_next).unwrap().wrapping_add(2i128);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_dest)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_dest: i128 = 0;
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSkipNext2Bytes {
    Var0(SkipNext2BytesVar0),
}
impl TableSkipNext2Bytes {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = SkipNext2BytesVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3827:1, end:3827:7))"]
#[derive(Clone, Debug)]
struct GPagedVar0 {}
impl GPagedVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("G")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 1i128
        {
            return None;
        }
        let tmp = 1i128;
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3828:1, end:3828:7))"]
#[derive(Clone, Debug)]
struct GPagedVar1 {}
impl GPagedVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance
            .register()
            .read_XGATE_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        if context_instance
            .register()
            .read_Prefix18_disassembly()
            .unwrap()
            != 0i128
        {
            return None;
        }
        let tmp = 0i128;
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp)
            .unwrap();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableGPaged {
    Var0(GPagedVar0),
    Var1(GPagedVar1),
}
impl TableGPaged {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            GPagedVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            GPagedVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
pub fn parse_instruction<T>(
    tokens: &[u8],
    context: &mut T,
    inst_start: u32,
    global_set: &mut impl GlobalSetTrait,
) -> Option<(u32, Vec<DisplayElement>)>
where
    T: ContextTrait + Clone,
{
    let (inst_len, instruction) =
        Tableinstruction::parse(tokens, context, inst_start)?;
    let inst_next = inst_start + inst_len;
    let mut display = vec![];
    instruction.display_extend(
        &mut display,
        context,
        inst_start,
        inst_next,
        global_set,
    );
    Some((inst_next, display))
}
