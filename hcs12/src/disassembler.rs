pub type AddrType = u32;
macro_rules! impl_read_to_type {
    ($ unsigned_type : ty , $ signed_type : ty , $ len : literal , $ read_unsigned : ident , $ read_signed : ident , $ write_unsigned : ident , $ write_signed : ident) => {
        fn $read_unsigned<const BIG_ENDIAN: bool>(
            data: [u8; $len],
            start_bit: usize,
            len_bits: usize,
        ) -> $unsigned_type {
            const TYPE_BITS: usize = <$unsigned_type>::BITS as usize;
            assert!(TYPE_BITS / 8 == $len);
            assert!(len_bits > 0);
            assert!(len_bits + start_bit <= TYPE_BITS);
            let mut data = if BIG_ENDIAN {
                <$unsigned_type>::from_be_bytes(data)
            } else {
                <$unsigned_type>::from_le_bytes(data)
            };
            let value_mask = <$unsigned_type>::MAX >> (TYPE_BITS - len_bits);
            data = data >> start_bit;
            data = data & value_mask;
            data
        }
        fn $read_signed<const BIG_ENDIAN: bool>(
            data: [u8; $len],
            start_bit: usize,
            len_bits: usize,
        ) -> $signed_type {
            const TYPE_BITS: usize = <$signed_type>::BITS as usize;
            assert!(len_bits > 1);
            assert!(TYPE_BITS / 8 == $len);
            let data = $read_unsigned::<BIG_ENDIAN>(data, start_bit, len_bits);
            let value_mask = <$unsigned_type>::try_from(<$signed_type>::MAX)
                .unwrap()
                >> (TYPE_BITS - len_bits);
            let sign_mask = !value_mask;
            let value_part = data & value_mask;
            let sign_part = data & sign_mask;
            if sign_part != 0 {
                let neg_value = (!value_part + 1) & value_mask;
                <$signed_type>::try_from(neg_value)
                    .unwrap()
                    .checked_neg()
                    .unwrap()
            } else {
                <$signed_type>::try_from(value_part).unwrap()
            }
        }
        fn $write_unsigned<const BIG_ENDIAN: bool>(
            value: $unsigned_type,
            mem: $unsigned_type,
            start_bit: usize,
            len_bits: usize,
        ) -> [u8; $len] {
            const TYPE_BITS: usize = <$unsigned_type>::BITS as usize;
            assert!(len_bits > 0);
            assert!(len_bits + start_bit <= TYPE_BITS);
            let value_max = <$unsigned_type>::MAX >> (TYPE_BITS - len_bits);
            let mask = value_max << start_bit;
            let mut value = value;
            value <<= start_bit;
            value = (mem & !mask) | value;
            if BIG_ENDIAN {
                value.to_be_bytes()
            } else {
                value.to_le_bytes()
            }
        }
        fn $write_signed<const BIG_ENDIAN: bool>(
            value: $signed_type,
            mem: $signed_type,
            start_bit: usize,
            len_bits: usize,
        ) -> [u8; $len] {
            const TYPE_BITS: usize = <$unsigned_type>::BITS as usize;
            assert!(len_bits > 0);
            assert!(len_bits + start_bit <= TYPE_BITS);
            let value: $unsigned_type = if value < 0 {
                <$unsigned_type>::MAX
                    - <$unsigned_type>::try_from(value.abs() - 1).unwrap()
            } else {
                <$unsigned_type>::try_from(value).unwrap()
            };
            let mem: $unsigned_type = if mem < 0 {
                <$unsigned_type>::MAX
                    - <$unsigned_type>::try_from(mem.abs() - 1).unwrap()
            } else {
                <$unsigned_type>::try_from(value).unwrap()
            };
            let mask = <$unsigned_type>::MAX >> (TYPE_BITS - len_bits);
            let value = value & mask;
            $write_unsigned::<BIG_ENDIAN>(value, mem, start_bit, len_bits)
        }
    };
}
impl_read_to_type!(u8, i8, 1, read_u8, read_i8, write_u8, write_i8);
impl_read_to_type!(u16, i16, 2, read_u16, read_i16, write_u16, write_i16);
impl_read_to_type!(u32, i32, 4, read_u32, read_i32, write_u32, write_i32);
impl_read_to_type!(u64, i64, 8, read_u64, read_i64, write_u64, write_i64);
impl_read_to_type!(
    u128, i128, 16, read_u128, read_i128, write_u128, write_i128
);
impl_read_to_type!(
    ethnum::u256,
    ethnum::i256,
    32,
    read_u256,
    read_i256,
    write_u256,
    write_i256
);
pub trait GlobalSetTrait {
    fn set_Prefix18(&mut self, address: Option<u32>, value: i64);
    fn set_PrefixHCS12X(&mut self, address: Option<u32>, value: i64);
    fn set_UseGPAGE(&mut self, address: Option<u32>, value: i64);
    fn set_XGATE(&mut self, address: Option<u32>, value: i64);
}
pub trait MemoryRead {
    type AddressType;
    fn read(&self, addr: Self::AddressType, buf: &mut [u8]);
}
pub trait MemoryWrite {
    type AddressType;
    fn write(&mut self, addr: Self::AddressType, buf: &[u8]);
}
pub trait ContextregisterTrait:
    MemoryRead<AddressType = u16> + MemoryWrite<AddressType = u16>
{
    fn read_Prefix18_raw(&self) -> u8 {
        let mut work_value = [0u8; 1u64 as usize];
        self.read(3u64 as u16, &mut work_value[0..1]);
        let value = read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
        u8::try_from(value).unwrap()
    }
    fn write_Prefix18_raw(&mut self, param: u8) {
        let mut mem = [0u8; 1];
        self.read(3u64 as u16, &mut mem[0..1]);
        let mem = u8::from_be_bytes(mem);
        let mem =
            write_u8::<true>(param as u8, mem, 0u64 as usize, 1u64 as usize);
        self.write(3u64 as u16, &mem[0..1]);
    }
    fn read_Prefix18_disassembly(&self) -> i64 {
        i64::try_from(self.read_Prefix18_raw()).unwrap()
    }
    fn write_Prefix18_disassembly(&mut self, param: i64) {
        self.write_Prefix18_raw(param as u8)
    }
    fn read_Prefix18_execution(&self) -> u8 {
        self.read_Prefix18_raw()
    }
    fn write_Prefix18_execution(&mut self, param: u8) {
        self.write_Prefix18_raw(param)
    }
    fn Prefix18_display(&self) -> DisplayElement {
        meaning_number(true, self.read_Prefix18_raw())
    }
    fn read_PrefixHCS12X_raw(&self) -> u8 {
        let mut work_value = [0u8; 1u64 as usize];
        self.read(3u64 as u16, &mut work_value[0..1]);
        let value = read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
        u8::try_from(value).unwrap()
    }
    fn write_PrefixHCS12X_raw(&mut self, param: u8) {
        let mut mem = [0u8; 1];
        self.read(3u64 as u16, &mut mem[0..1]);
        let mem = u8::from_be_bytes(mem);
        let mem =
            write_u8::<true>(param as u8, mem, 0u64 as usize, 1u64 as usize);
        self.write(3u64 as u16, &mem[0..1]);
    }
    fn read_PrefixHCS12X_disassembly(&self) -> i64 {
        i64::try_from(self.read_PrefixHCS12X_raw()).unwrap()
    }
    fn write_PrefixHCS12X_disassembly(&mut self, param: i64) {
        self.write_PrefixHCS12X_raw(param as u8)
    }
    fn read_PrefixHCS12X_execution(&self) -> u8 {
        self.read_PrefixHCS12X_raw()
    }
    fn write_PrefixHCS12X_execution(&mut self, param: u8) {
        self.write_PrefixHCS12X_raw(param)
    }
    fn PrefixHCS12X_display(&self) -> DisplayElement {
        meaning_number(true, self.read_PrefixHCS12X_raw())
    }
    fn read_UseGPAGE_raw(&self) -> u8 {
        let mut work_value = [0u8; 1u64 as usize];
        self.read(3u64 as u16, &mut work_value[0..1]);
        let value = read_u8::<true>(work_value, 1u64 as usize, 1u64 as usize);
        u8::try_from(value).unwrap()
    }
    fn write_UseGPAGE_raw(&mut self, param: u8) {
        let mut mem = [0u8; 1];
        self.read(3u64 as u16, &mut mem[0..1]);
        let mem = u8::from_be_bytes(mem);
        let mem =
            write_u8::<true>(param as u8, mem, 1u64 as usize, 1u64 as usize);
        self.write(3u64 as u16, &mem[0..1]);
    }
    fn read_UseGPAGE_disassembly(&self) -> i64 {
        i64::try_from(self.read_UseGPAGE_raw()).unwrap()
    }
    fn write_UseGPAGE_disassembly(&mut self, param: i64) {
        self.write_UseGPAGE_raw(param as u8)
    }
    fn read_UseGPAGE_execution(&self) -> u8 {
        self.read_UseGPAGE_raw()
    }
    fn write_UseGPAGE_execution(&mut self, param: u8) {
        self.write_UseGPAGE_raw(param)
    }
    fn UseGPAGE_display(&self) -> DisplayElement {
        meaning_number(true, self.read_UseGPAGE_raw())
    }
    fn read_XGATE_raw(&self) -> u8 {
        let mut work_value = [0u8; 1u64 as usize];
        self.read(3u64 as u16, &mut work_value[0..1]);
        let value = read_u8::<true>(work_value, 2u64 as usize, 1u64 as usize);
        u8::try_from(value).unwrap()
    }
    fn write_XGATE_raw(&mut self, param: u8) {
        let mut mem = [0u8; 1];
        self.read(3u64 as u16, &mut mem[0..1]);
        let mem = u8::from_be_bytes(mem);
        let mem =
            write_u8::<true>(param as u8, mem, 2u64 as usize, 1u64 as usize);
        self.write(3u64 as u16, &mem[0..1]);
    }
    fn read_XGATE_disassembly(&self) -> i64 {
        i64::try_from(self.read_XGATE_raw()).unwrap()
    }
    fn write_XGATE_disassembly(&mut self, param: i64) {
        self.write_XGATE_raw(param as u8)
    }
    fn read_XGATE_execution(&self) -> u8 {
        self.read_XGATE_raw()
    }
    fn write_XGATE_execution(&mut self, param: u8) {
        self.write_XGATE_raw(param)
    }
    fn XGATE_display(&self) -> DisplayElement {
        meaning_number(true, self.read_XGATE_raw())
    }
}
pub trait ContextTrait {
    type Typeregister: ContextregisterTrait;
    fn register(&self) -> &Self::Typeregister;
    fn register_mut(&mut self) -> &mut Self::Typeregister;
}
#[derive(Debug, Clone, Copy, Default)]
pub struct ContextregisterStruct {
    pub chunk_0x0: [u8; 4u64 as usize],
}
impl ContextregisterTrait for ContextregisterStruct {}
impl MemoryRead for ContextregisterStruct {
    type AddressType = u16;
    fn read(&self, addr: Self::AddressType, buf: &mut [u8]) {
        let addr = <u64>::try_from(addr).unwrap();
        let buf_len = <u64>::try_from(buf.len()).unwrap();
        let addr_end = addr + buf_len;
        match (addr, addr_end) {
            (0u64..=3u64, 0u64..=4u64) => {
                let start = addr - 0u64;
                let end = usize::try_from(start + buf_len).unwrap();
                let start = usize::try_from(start).unwrap();
                buf.copy_from_slice(&self.chunk_0x0[start..end]);
            }
            _ => panic!("undefined mem {}:{}", addr, buf.len()),
        }
    }
}
impl MemoryWrite for ContextregisterStruct {
    type AddressType = u16;
    fn write(&mut self, addr: Self::AddressType, buf: &[u8]) {
        let addr = <u64>::try_from(addr).unwrap();
        let buf_len = <u64>::try_from(buf.len()).unwrap();
        let addr_end = addr + buf_len;
        match (addr, addr_end) {
            (0u64..=3u64, 0u64..=4u64) => {
                let start = addr - 0u64;
                let end = usize::try_from(start + buf_len).unwrap();
                let start = usize::try_from(start).unwrap();
                self.chunk_0x0[start..end].copy_from_slice(buf);
            }
            _ => panic!("undefined mem {}:{}", addr, buf.len()),
        }
    }
}
#[derive(Debug, Clone, Copy, Default)]
pub struct SpacesStruct {
    pub register: ContextregisterStruct,
}
impl ContextTrait for SpacesStruct {
    type Typeregister = ContextregisterStruct;
    fn register(&self) -> &Self::Typeregister {
        &self.register
    }
    fn register_mut(&mut self) -> &mut Self::Typeregister {
        &mut self.register
    }
}
fn meaning_number<T>(hex: bool, num: T) -> DisplayElement
where
    i64: TryFrom<T>,
    <i64 as TryFrom<T>>::Error: core::fmt::Debug,
{
    DisplayElement::Number(hex, i64::try_from(num).unwrap())
}
fn meaning_0_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_0_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_0_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::IX,
        1 => Register::IY,
        2 => Register::SP,
        3 => Register::PC,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_1_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_1_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_1_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::IX,
        1 => Register::IY,
        2 => Register::SP,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_3_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_3_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_3_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A,
        1 => Register::B,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_4_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_4_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_4_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A,
        1 => Register::B,
        2 => Register::CCR,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_5_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_5_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_5_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP2,
        4 => Register::D,
        5 => Register::IX,
        6 => Register::IY,
        7 => Register::SP,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_6_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_6_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_6_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A,
        1 => Register::B,
        2 => Register::CCR,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_7_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_7_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_7_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A,
        1 => Register::B,
        2 => Register::CCR,
        3 => Register::TMP3L,
        4 => Register::B,
        5 => Register::IXL,
        6 => Register::IYL,
        7 => Register::SPL,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_8_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_8_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_8_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A,
        1 => Register::B,
        2 => Register::CCRH,
        3 => Register::TMP3H,
        4 => Register::B,
        5 => Register::IXH,
        6 => Register::IYH,
        7 => Register::SPH,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_9_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_9_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_9_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        2 => Register::CCRW,
        3 => Register::TMP3,
        4 => Register::D,
        5 => Register::IX,
        6 => Register::IY,
        7 => Register::SP,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_10_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_10_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_10_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP3,
        4 => Register::D,
        5 => Register::IX,
        6 => Register::IY,
        7 => Register::SP,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_11_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_11_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_11_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A,
        1 => Register::B,
        2 => Register::CCR,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_12_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_12_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_12_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP3L,
        4 => Register::B,
        5 => Register::IXL,
        6 => Register::IYL,
        7 => Register::SPL,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_13_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_13_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_13_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP2,
        4 => Register::D,
        5 => Register::IX,
        6 => Register::IY,
        7 => Register::SP,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_14_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_14_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_14_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP2H,
        5 => Register::IXH,
        6 => Register::IYH,
        7 => Register::SPH,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_15_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_15_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_15_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP2L,
        5 => Register::IXL,
        6 => Register::IYL,
        7 => Register::SPL,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_16_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_16_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_16_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP3L,
        5 => Register::IXL,
        6 => Register::IYL,
        7 => Register::SPL,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_17_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_17_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_17_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP3H,
        5 => Register::IXH,
        6 => Register::IYH,
        7 => Register::SPH,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_18_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_18_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_18_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP3,
        5 => Register::IX,
        6 => Register::IY,
        7 => Register::SP,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_19_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_19_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_19_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP2H,
        4 => Register::A,
        5 => Register::IXH,
        6 => Register::IYH,
        7 => Register::SPH,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_20_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_20_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_20_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP2L,
        4 => Register::B,
        5 => Register::IXL,
        6 => Register::IYL,
        7 => Register::SPL,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_21_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_21_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_21_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A,
        1 => Register::B,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_22_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_22_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_22_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::D,
        1 => Register::IX,
        2 => Register::IY,
        3 => Register::SP,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_2_display<T>(hex: bool, num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_2_value(num);
    let value = i64::try_from(value).unwrap();
    DisplayElement::Number(hex, value)
}
fn meaning_2_value<T>(num: T) -> i8
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => 1,
        1 => 2,
        2 => 3,
        3 => 4,
        4 => 5,
        5 => 6,
        6 => 7,
        7 => 8,
        8 => -8,
        9 => -7,
        10 => -6,
        11 => -5,
        12 => -4,
        13 => -3,
        14 => -2,
        15 => -1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op8(u8);
impl TokenField_op8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op7_4(u8);
impl TokenField_op7_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op6_4(u8);
impl TokenField_op6_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_nIndex(u8);
impl TokenField_nIndex {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op0_0(u8);
impl TokenField_op0_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_trapnum(u8);
impl TokenField_trapnum {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rr7_6(u8);
impl TokenField_rr7_6 {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rr7_6a(u8);
impl TokenField_rr7_6a {
    fn execution(&self) -> Register {
        meaning_1_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_xb5_5(u8);
impl TokenField_xb5_5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_nn4_0(i8);
impl TokenField_nn4_0 {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_xb7_5(u8);
impl TokenField_xb7_5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rr4_3(u8);
impl TokenField_rr4_3 {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_xb2_2(u8);
impl TokenField_xb2_2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_xb2_1(u8);
impl TokenField_xb2_1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_z1_1(u8);
impl TokenField_z1_1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_s0_0(u8);
impl TokenField_s0_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_ss0_0(i8);
impl TokenField_ss0_0 {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_xb2_0(u8);
impl TokenField_xb2_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_p4_4(u8);
impl TokenField_p4_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_decrement3_3(u8);
impl TokenField_decrement3_3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_nn3_0(i8);
impl TokenField_nn3_0 {
    fn execution(&self) -> i8 {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.execution()).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(false, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_aa1_0(u8);
impl TokenField_aa1_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_aa0_0(u8);
impl TokenField_aa0_0 {
    fn execution(&self) -> Register {
        meaning_3_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_3_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_notUsed7_7(u8);
impl TokenField_notUsed7_7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_abcdxys6_4(u8);
impl TokenField_abcdxys6_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_abc5_4(u8);
impl TokenField_abc5_4 {
    fn execution(&self) -> Register {
        meaning_4_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_4_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_dxys2_0(u8);
impl TokenField_dxys2_0 {
    fn execution(&self) -> Register {
        meaning_5_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_5_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_abcdxys2_0(u8);
impl TokenField_abcdxys2_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_columns7_4(u8);
impl TokenField_columns7_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rows2_0(u8);
impl TokenField_rows2_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rows3_0(u8);
impl TokenField_rows3_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bytes_ABCl_6_4(u8);
impl TokenField_bytes_ABCl_6_4 {
    fn execution(&self) -> Register {
        meaning_6_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_6_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bytes_ABClT3lBXlYlSl_6_4(u8);
impl TokenField_bytes_ABClT3lBXlYlSl_6_4 {
    fn execution(&self) -> Register {
        meaning_7_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_7_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bytes_ABChT3hBXhYhSh_6_4(u8);
impl TokenField_bytes_ABChT3hBXhYhSh_6_4 {
    fn execution(&self) -> Register {
        meaning_8_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_8_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_words_CT3DXYS_6_4(u8);
impl TokenField_words_CT3DXYS_6_4 {
    fn execution(&self) -> Register {
        meaning_9_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_9_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_words_T3DXYS_6_4(u8);
impl TokenField_words_T3DXYS_6_4 {
    fn execution(&self) -> Register {
        meaning_10_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_10_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bytes_ABCl_2_0(u8);
impl TokenField_bytes_ABCl_2_0 {
    fn execution(&self) -> Register {
        meaning_11_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_11_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bytes_T3lDlXlYlSl_6_4(u8);
impl TokenField_bytes_T3lDlXlYlSl_6_4 {
    fn execution(&self) -> Register {
        meaning_12_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_12_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_words_T2DXYS_2_0(u8);
impl TokenField_words_T2DXYS_2_0 {
    fn execution(&self) -> Register {
        meaning_13_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_13_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bytes_T2h_XhYhSh_2_0(u8);
impl TokenField_bytes_T2h_XhYhSh_2_0 {
    fn execution(&self) -> Register {
        meaning_14_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_14_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bytes_T2l_XlYlSl_2_0(u8);
impl TokenField_bytes_T2l_XlYlSl_2_0 {
    fn execution(&self) -> Register {
        meaning_15_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_15_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bytes_T3l_XlYlSl_6_4(u8);
impl TokenField_bytes_T3l_XlYlSl_6_4 {
    fn execution(&self) -> Register {
        meaning_16_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_16_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bytes_T3h_XhYhSh_6_4(u8);
impl TokenField_bytes_T3h_XhYhSh_6_4 {
    fn execution(&self) -> Register {
        meaning_17_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_17_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_words_T3_XYS_6_4(u8);
impl TokenField_words_T3_XYS_6_4 {
    fn execution(&self) -> Register {
        meaning_18_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_18_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bytes_T2hDhXhYhSh_2_0(u8);
impl TokenField_bytes_T2hDhXhYhSh_2_0 {
    fn execution(&self) -> Register {
        meaning_19_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_19_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bytes_T2lDlXlYlSl_2_0(u8);
impl TokenField_bytes_T2lDlXlYlSl_2_0 {
    fn execution(&self) -> Register {
        meaning_20_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_20_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op16(u16);
impl TokenField_op16 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op15_13(u8);
impl TokenField_op15_13 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sign12_12(i8);
impl TokenField_sign12_12 {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_not_used11(u8);
impl TokenField_not_used11 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_size10_10(u8);
impl TokenField_size10_10 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_byte9_8(u8);
impl TokenField_byte9_8 {
    fn execution(&self) -> Register {
        meaning_21_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_21_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_word9_8(u8);
impl TokenField_word9_8 {
    fn execution(&self) -> Register {
        meaning_22_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_22_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rr7_0(u8);
impl TokenField_rr7_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_imm8(u8);
impl TokenField_imm8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_simm8(i8);
impl TokenField_simm8 {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_rel(i8);
impl TokenField_rel {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_imm16(u16);
impl TokenField_imm16 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_imm16p(u8);
impl TokenField_imm16p {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_imm16e(u8);
impl TokenField_imm16e {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_imm16ev(u16);
impl TokenField_imm16ev {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_imm16rv(u16);
impl TokenField_imm16rv {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_imm16pv(u16);
impl TokenField_imm16pv {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_simm16(i16);
impl TokenField_simm16 {
    fn execution(&self) -> i16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
struct TokenParser<const LEN: usize>([u8; LEN]);
impl<const LEN: usize> TokenParser<LEN> {
    fn new(data: &[u8]) -> Option<Self> {
        let token_slice: &[u8] = data.get(..LEN)?;
        let token_data = <[u8; LEN]>::try_from(token_slice).unwrap();
        Some(Self(token_data))
    }
    fn TokenFieldop8(&self) -> TokenField_op8 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_op8(inner_value)
    }
    fn TokenFieldop7_4(&self) -> TokenField_op7_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_op7_4(inner_value)
    }
    fn TokenFieldop6_4(&self) -> TokenField_op6_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_op6_4(inner_value)
    }
    fn TokenFieldnIndex(&self) -> TokenField_nIndex {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_nIndex(inner_value)
    }
    fn TokenFieldop0_0(&self) -> TokenField_op0_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_op0_0(inner_value)
    }
    fn TokenFieldtrapnum(&self) -> TokenField_trapnum {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_trapnum(inner_value)
    }
    fn TokenFieldrr7_6(&self) -> TokenField_rr7_6 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 6u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_rr7_6(inner_value)
    }
    fn TokenFieldrr7_6a(&self) -> TokenField_rr7_6a {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 6u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_rr7_6a(inner_value)
    }
    fn TokenFieldxb5_5(&self) -> TokenField_xb5_5 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_xb5_5(inner_value)
    }
    fn TokenFieldnn4_0(&self) -> TokenField_nn4_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            i8::try_from(value).unwrap()
        };
        TokenField_nn4_0(inner_value)
    }
    fn TokenFieldxb7_5(&self) -> TokenField_xb7_5 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_xb7_5(inner_value)
    }
    fn TokenFieldrr4_3(&self) -> TokenField_rr4_3 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_rr4_3(inner_value)
    }
    fn TokenFieldxb2_2(&self) -> TokenField_xb2_2 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_xb2_2(inner_value)
    }
    fn TokenFieldxb2_1(&self) -> TokenField_xb2_1 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_xb2_1(inner_value)
    }
    fn TokenFieldz1_1(&self) -> TokenField_z1_1 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_z1_1(inner_value)
    }
    fn TokenFields0_0(&self) -> TokenField_s0_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_s0_0(inner_value)
    }
    fn TokenFieldss0_0(&self) -> TokenField_ss0_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            i8::try_from(value).unwrap()
        };
        TokenField_ss0_0(inner_value)
    }
    fn TokenFieldxb2_0(&self) -> TokenField_xb2_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_xb2_0(inner_value)
    }
    fn TokenFieldp4_4(&self) -> TokenField_p4_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_p4_4(inner_value)
    }
    fn TokenFielddecrement3_3(&self) -> TokenField_decrement3_3 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_decrement3_3(inner_value)
    }
    fn TokenFieldnn3_0(&self) -> TokenField_nn3_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i8::<true>(work_value, 0u64 as usize, 4u64 as usize);
            i8::try_from(value).unwrap()
        };
        TokenField_nn3_0(inner_value)
    }
    fn TokenFieldaa1_0(&self) -> TokenField_aa1_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_aa1_0(inner_value)
    }
    fn TokenFieldaa0_0(&self) -> TokenField_aa0_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_aa0_0(inner_value)
    }
    fn TokenFieldnotUsed7_7(&self) -> TokenField_notUsed7_7 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 7u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_notUsed7_7(inner_value)
    }
    fn TokenFieldabcdxys6_4(&self) -> TokenField_abcdxys6_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_abcdxys6_4(inner_value)
    }
    fn TokenFieldabc5_4(&self) -> TokenField_abc5_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_abc5_4(inner_value)
    }
    fn TokenFielddxys2_0(&self) -> TokenField_dxys2_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_dxys2_0(inner_value)
    }
    fn TokenFieldabcdxys2_0(&self) -> TokenField_abcdxys2_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_abcdxys2_0(inner_value)
    }
    fn TokenFieldcolumns7_4(&self) -> TokenField_columns7_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_columns7_4(inner_value)
    }
    fn TokenFieldrows2_0(&self) -> TokenField_rows2_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_rows2_0(inner_value)
    }
    fn TokenFieldrows3_0(&self) -> TokenField_rows3_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_rows3_0(inner_value)
    }
    fn TokenFieldbytes_ABCl_6_4(&self) -> TokenField_bytes_ABCl_6_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_bytes_ABCl_6_4(inner_value)
    }
    fn TokenFieldbytes_ABClT3lBXlYlSl_6_4(
        &self,
    ) -> TokenField_bytes_ABClT3lBXlYlSl_6_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_bytes_ABClT3lBXlYlSl_6_4(inner_value)
    }
    fn TokenFieldbytes_ABChT3hBXhYhSh_6_4(
        &self,
    ) -> TokenField_bytes_ABChT3hBXhYhSh_6_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_bytes_ABChT3hBXhYhSh_6_4(inner_value)
    }
    fn TokenFieldwords_CT3DXYS_6_4(&self) -> TokenField_words_CT3DXYS_6_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_words_CT3DXYS_6_4(inner_value)
    }
    fn TokenFieldwords_T3DXYS_6_4(&self) -> TokenField_words_T3DXYS_6_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_words_T3DXYS_6_4(inner_value)
    }
    fn TokenFieldbytes_ABCl_2_0(&self) -> TokenField_bytes_ABCl_2_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_bytes_ABCl_2_0(inner_value)
    }
    fn TokenFieldbytes_T3lDlXlYlSl_6_4(
        &self,
    ) -> TokenField_bytes_T3lDlXlYlSl_6_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_bytes_T3lDlXlYlSl_6_4(inner_value)
    }
    fn TokenFieldwords_T2DXYS_2_0(&self) -> TokenField_words_T2DXYS_2_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_words_T2DXYS_2_0(inner_value)
    }
    fn TokenFieldbytes_T2h_XhYhSh_2_0(
        &self,
    ) -> TokenField_bytes_T2h_XhYhSh_2_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_bytes_T2h_XhYhSh_2_0(inner_value)
    }
    fn TokenFieldbytes_T2l_XlYlSl_2_0(
        &self,
    ) -> TokenField_bytes_T2l_XlYlSl_2_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_bytes_T2l_XlYlSl_2_0(inner_value)
    }
    fn TokenFieldbytes_T3l_XlYlSl_6_4(
        &self,
    ) -> TokenField_bytes_T3l_XlYlSl_6_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_bytes_T3l_XlYlSl_6_4(inner_value)
    }
    fn TokenFieldbytes_T3h_XhYhSh_6_4(
        &self,
    ) -> TokenField_bytes_T3h_XhYhSh_6_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_bytes_T3h_XhYhSh_6_4(inner_value)
    }
    fn TokenFieldwords_T3_XYS_6_4(&self) -> TokenField_words_T3_XYS_6_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_words_T3_XYS_6_4(inner_value)
    }
    fn TokenFieldbytes_T2hDhXhYhSh_2_0(
        &self,
    ) -> TokenField_bytes_T2hDhXhYhSh_2_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_bytes_T2hDhXhYhSh_2_0(inner_value)
    }
    fn TokenFieldbytes_T2lDlXlYlSl_2_0(
        &self,
    ) -> TokenField_bytes_T2lDlXlYlSl_2_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_bytes_T2lDlXlYlSl_2_0(inner_value)
    }
    fn TokenFieldop16(&self) -> TokenField_op16 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 0u64 as usize, 16u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_op16(inner_value)
    }
    fn TokenFieldop15_13(&self) -> TokenField_op15_13 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_op15_13(inner_value)
    }
    fn TokenFieldsign12_12(&self) -> TokenField_sign12_12 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i8::<true>(work_value, 4u64 as usize, 1u64 as usize);
            i8::try_from(value).unwrap()
        };
        TokenField_sign12_12(inner_value)
    }
    fn TokenFieldnot_used11(&self) -> TokenField_not_used11 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_not_used11(inner_value)
    }
    fn TokenFieldsize10_10(&self) -> TokenField_size10_10 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_size10_10(inner_value)
    }
    fn TokenFieldbyte9_8(&self) -> TokenField_byte9_8 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_byte9_8(inner_value)
    }
    fn TokenFieldword9_8(&self) -> TokenField_word9_8 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_word9_8(inner_value)
    }
    fn TokenFieldrr7_0(&self) -> TokenField_rr7_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_rr7_0(inner_value)
    }
    fn TokenFieldimm8(&self) -> TokenField_imm8 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_imm8(inner_value)
    }
    fn TokenFieldsimm8(&self) -> TokenField_simm8 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i8::<true>(work_value, 0u64 as usize, 8u64 as usize);
            i8::try_from(value).unwrap()
        };
        TokenField_simm8(inner_value)
    }
    fn TokenFieldrel(&self) -> TokenField_rel {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i8::<true>(work_value, 0u64 as usize, 8u64 as usize);
            i8::try_from(value).unwrap()
        };
        TokenField_rel(inner_value)
    }
    fn TokenFieldimm16(&self) -> TokenField_imm16 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 0u64 as usize, 16u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_imm16(inner_value)
    }
    fn TokenFieldimm16p(&self) -> TokenField_imm16p {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_imm16p(inner_value)
    }
    fn TokenFieldimm16e(&self) -> TokenField_imm16e {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_imm16e(inner_value)
    }
    fn TokenFieldimm16ev(&self) -> TokenField_imm16ev {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 0u64 as usize, 10u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_imm16ev(inner_value)
    }
    fn TokenFieldimm16rv(&self) -> TokenField_imm16rv {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 0u64 as usize, 12u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_imm16rv(inner_value)
    }
    fn TokenFieldimm16pv(&self) -> TokenField_imm16pv {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 0u64 as usize, 14u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_imm16pv(inner_value)
    }
    fn TokenFieldsimm16(&self) -> TokenField_simm16 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i16::<true>(work_value, 0u64 as usize, 16u64 as usize);
            i16::try_from(value).unwrap()
        };
        TokenField_simm16(inner_value)
    }
}
#[derive(Clone, Copy, Debug)]
pub enum Register {
    A,
    B,
    D,
    IX,
    IY,
    TMP2,
    TMP3,
    TMP1,
    IXH,
    IXL,
    IYH,
    IYL,
    TMP2H,
    TMP2L,
    TMP3H,
    TMP3L,
    TMP1H,
    TMP1L,
    PCE,
    PC,
    SP,
    PCH,
    PCL,
    SPH,
    SPL,
    CCRW,
    CCRH,
    CCR,
    physPage,
    DIRECT,
    PPAGE,
    contextreg,
}
impl core::fmt::Display for Register {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::A => write!(f, "A"),
            Self::B => write!(f, "B"),
            Self::D => write!(f, "D"),
            Self::IX => write!(f, "IX"),
            Self::IY => write!(f, "IY"),
            Self::TMP2 => write!(f, "TMP2"),
            Self::TMP3 => write!(f, "TMP3"),
            Self::TMP1 => write!(f, "TMP1"),
            Self::IXH => write!(f, "IXH"),
            Self::IXL => write!(f, "IXL"),
            Self::IYH => write!(f, "IYH"),
            Self::IYL => write!(f, "IYL"),
            Self::TMP2H => write!(f, "TMP2H"),
            Self::TMP2L => write!(f, "TMP2L"),
            Self::TMP3H => write!(f, "TMP3H"),
            Self::TMP3L => write!(f, "TMP3L"),
            Self::TMP1H => write!(f, "TMP1H"),
            Self::TMP1L => write!(f, "TMP1L"),
            Self::PCE => write!(f, "PCE"),
            Self::PC => write!(f, "PC"),
            Self::SP => write!(f, "SP"),
            Self::PCH => write!(f, "PCH"),
            Self::PCL => write!(f, "PCL"),
            Self::SPH => write!(f, "SPH"),
            Self::SPL => write!(f, "SPL"),
            Self::CCRW => write!(f, "CCRW"),
            Self::CCRH => write!(f, "CCRH"),
            Self::CCR => write!(f, "CCR"),
            Self::physPage => write!(f, "physPage"),
            Self::DIRECT => write!(f, "DIRECT"),
            Self::PPAGE => write!(f, "PPAGE"),
            Self::contextreg => write!(f, "contextreg"),
        }
    }
}
#[derive(Clone, Copy, Debug)]
pub enum DisplayElement {
    Literal(&'static str),
    Register(Register),
    Number(bool, i64),
}
impl core::fmt::Display for DisplayElement {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Literal(lit) => lit.fmt(f),
            Self::Register(reg) => reg.fmt(f),
            Self::Number(hex, value) => match (*hex, value.is_negative()) {
                (true, true) => write!(f, "-0x{:x}", value.abs()),
                (true, false) => write!(f, "0x{:x}", value),
                (false, _) => value.fmt(f),
            },
        }
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:930:1"]
#[derive(Clone, Debug)]
struct instructionVar0 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 24i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_Prefix18_disassembly(tmp);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:933:1"]
#[derive(Clone, Debug)]
struct instructionVar1 {}
impl instructionVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ABA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c30 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if context_instance.register().read_Prefix18_disassembly() != 1i64 {
                return None;
            }
            if token_parser.TokenFieldop8().disassembly() != 6i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c30(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:940:1"]
#[derive(Clone, Debug)]
struct instructionVar2 {}
impl instructionVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ABX")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c43 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2u64 as u32;
            let token_parser = <TokenParser<2usize>>::new(tokens)?;
            if token_parser.TokenFieldop16().disassembly() != 6885i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c43(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:945:1"]
#[derive(Clone, Debug)]
struct instructionVar3 {}
impl instructionVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ABY")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c43 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2u64 as u32;
            let token_parser = <TokenParser<2usize>>::new(tokens)?;
            if token_parser.TokenFieldop16().disassembly() != 6637i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c43(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:950:1"]
#[derive(Clone, Debug)]
struct instructionVar4 {
    iopr8i: Tableiopr8i,
}
impl instructionVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADCA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 137i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:960:1"]
#[derive(Clone, Debug)]
struct instructionVar5 {
    opr8a_8: Tableopr8a_8,
}
impl instructionVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADCA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 153i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:970:1"]
#[derive(Clone, Debug)]
struct instructionVar6 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADCA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 185i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:980:1"]
#[derive(Clone, Debug)]
struct instructionVar7 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADCA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 169i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:989:1"]
#[derive(Clone, Debug)]
struct instructionVar8 {
    iopr8i: Tableiopr8i,
}
impl instructionVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADCB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 201i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:999:1"]
#[derive(Clone, Debug)]
struct instructionVar9 {
    opr8a_8: Tableopr8a_8,
}
impl instructionVar9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADCB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 217i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1008:1"]
#[derive(Clone, Debug)]
struct instructionVar10 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADCB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 249i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1018:1"]
#[derive(Clone, Debug)]
struct instructionVar11 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADCB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 233i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1028:1"]
#[derive(Clone, Debug)]
struct instructionVar12 {
    iopr8i: Tableiopr8i,
}
impl instructionVar12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 139i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1038:1"]
#[derive(Clone, Debug)]
struct instructionVar13 {
    opr8a_8: Tableopr8a_8,
}
impl instructionVar13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 155i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1047:1"]
#[derive(Clone, Debug)]
struct instructionVar14 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 187i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1056:1"]
#[derive(Clone, Debug)]
struct instructionVar15 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 171i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1065:1"]
#[derive(Clone, Debug)]
struct instructionVar16 {
    iopr8i: Tableiopr8i,
}
impl instructionVar16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 203i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1074:1"]
#[derive(Clone, Debug)]
struct instructionVar17 {
    opr8a_8: Tableopr8a_8,
}
impl instructionVar17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 219i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1083:1"]
#[derive(Clone, Debug)]
struct instructionVar18 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar18 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 251i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1092:1"]
#[derive(Clone, Debug)]
struct instructionVar19 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar19 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 235i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1101:1"]
#[derive(Clone, Debug)]
struct instructionVar20 {
    iopr16i: Tableiopr16i,
}
impl instructionVar20 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDD"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr16i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 195i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr16i = if let Some((len, table)) = Tableiopr16i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1110:1"]
#[derive(Clone, Debug)]
struct instructionVar21 {
    opr8a_16: Tableopr8a_16,
}
impl instructionVar21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDD"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 211i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1119:1"]
#[derive(Clone, Debug)]
struct instructionVar22 {
    opr16a_16: Tableopr16a_16,
}
impl instructionVar22 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDD"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 243i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1128:1"]
#[derive(Clone, Debug)]
struct instructionVar23 {
    indexed2_5: Tableindexed2_5,
}
impl instructionVar23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDD"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 227i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1357:1"]
#[derive(Clone, Debug)]
struct instructionVar24 {
    iopr8i: Tableiopr8i,
}
impl instructionVar24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ANDA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 132i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1365:1"]
#[derive(Clone, Debug)]
struct instructionVar25 {
    opr8a_8: Tableopr8a_8,
}
impl instructionVar25 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ANDA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 148i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1373:1"]
#[derive(Clone, Debug)]
struct instructionVar26 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar26 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ANDA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 180i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1381:1"]
#[derive(Clone, Debug)]
struct instructionVar27 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar27 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ANDA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 164i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1389:1"]
#[derive(Clone, Debug)]
struct instructionVar28 {
    iopr8i: Tableiopr8i,
}
impl instructionVar28 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ANDB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 196i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1397:1"]
#[derive(Clone, Debug)]
struct instructionVar29 {
    opr8a_8: Tableopr8a_8,
}
impl instructionVar29 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ANDB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 212i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1405:1"]
#[derive(Clone, Debug)]
struct instructionVar30 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar30 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ANDB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 244i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1413:1"]
#[derive(Clone, Debug)]
struct instructionVar31 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar31 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ANDB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 228i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1421:1"]
#[derive(Clone, Debug)]
struct instructionVar32 {
    iopr8i: Tableiopr8i,
}
impl instructionVar32 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ANDCC"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 16i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1506:1"]
#[derive(Clone, Debug)]
struct instructionVar33 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar33 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ASL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 120i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1517:1"]
#[derive(Clone, Debug)]
struct instructionVar34 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar34 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ASL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 104i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1528:1"]
#[derive(Clone, Debug)]
struct instructionVar35 {}
impl instructionVar35 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ASLA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 72i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1537:1"]
#[derive(Clone, Debug)]
struct instructionVar36 {}
impl instructionVar36 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ASLB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 88i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1546:1"]
#[derive(Clone, Debug)]
struct instructionVar37 {}
impl instructionVar37 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ASLD")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 89i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1603:1"]
#[derive(Clone, Debug)]
struct instructionVar38 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar38 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ASR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 119i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1614:1"]
#[derive(Clone, Debug)]
struct instructionVar39 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar39 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ASR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 103i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1625:1"]
#[derive(Clone, Debug)]
struct instructionVar40 {}
impl instructionVar40 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ASRA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 71i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1634:1"]
#[derive(Clone, Debug)]
struct instructionVar41 {}
impl instructionVar41 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ASRB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 87i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1691:1"]
#[derive(Clone, Debug)]
struct instructionVar42 {
    rel8: Tablerel8,
}
impl instructionVar42 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BCC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 36i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1696:1"]
#[derive(Clone, Debug)]
struct instructionVar43 {
    opr8a_8: Tableopr8a_8,
    msk8: Tablemsk8,
}
impl instructionVar43 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BCLR"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c39 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 77i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c39(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8, msk8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1706:1"]
#[derive(Clone, Debug)]
struct instructionVar44 {
    opr16a_8: Tableopr16a_8,
    msk8: Tablemsk8,
}
impl instructionVar44 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BCLR"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c39 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 29i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c39(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8, msk8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1716:1"]
#[derive(Clone, Debug)]
struct instructionVar45 {
    indexed1_3: Tableindexed1_3,
    msk8: Tablemsk8,
}
impl instructionVar45 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BCLR"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c41 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 13i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c41(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_3 = if let Some((len, table)) = Tableindexed1_3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_3, msk8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1726:1"]
#[derive(Clone, Debug)]
struct instructionVar46 {
    rel8: Tablerel8,
}
impl instructionVar46 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BCS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 37i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1731:1"]
#[derive(Clone, Debug)]
struct instructionVar47 {
    rel8: Tablerel8,
}
impl instructionVar47 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BEQ"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 39i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1736:1"]
#[derive(Clone, Debug)]
struct instructionVar48 {
    rel8: Tablerel8,
}
impl instructionVar48 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BGE"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 44i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1742:1"]
#[derive(Clone, Debug)]
struct instructionVar49 {}
impl instructionVar49 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("BGND")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1751:1"]
#[derive(Clone, Debug)]
struct instructionVar50 {
    rel8: Tablerel8,
}
impl instructionVar50 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BGT"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 46i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1756:1"]
#[derive(Clone, Debug)]
struct instructionVar51 {
    rel8: Tablerel8,
}
impl instructionVar51 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BHI"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 34i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1763:1"]
#[derive(Clone, Debug)]
struct instructionVar52 {
    iopr8i: Tableiopr8i,
}
impl instructionVar52 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BITA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 133i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1771:1"]
#[derive(Clone, Debug)]
struct instructionVar53 {
    opr8a_8: Tableopr8a_8,
}
impl instructionVar53 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BITA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 149i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1779:1"]
#[derive(Clone, Debug)]
struct instructionVar54 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar54 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BITA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 181i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1787:1"]
#[derive(Clone, Debug)]
struct instructionVar55 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar55 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BITA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 165i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1795:1"]
#[derive(Clone, Debug)]
struct instructionVar56 {
    iopr8i: Tableiopr8i,
}
impl instructionVar56 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BITB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 197i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1803:1"]
#[derive(Clone, Debug)]
struct instructionVar57 {
    opr8a_8: Tableopr8a_8,
}
impl instructionVar57 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BITB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 213i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1811:1"]
#[derive(Clone, Debug)]
struct instructionVar58 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar58 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BITB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 245i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1819:1"]
#[derive(Clone, Debug)]
struct instructionVar59 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar59 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BITB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 229i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1908:1"]
#[derive(Clone, Debug)]
struct instructionVar60 {
    rel8: Tablerel8,
}
impl instructionVar60 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BLE"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 47i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1915:1"]
#[derive(Clone, Debug)]
struct instructionVar61 {
    rel8: Tablerel8,
}
impl instructionVar61 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BLS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 35i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1920:1"]
#[derive(Clone, Debug)]
struct instructionVar62 {
    rel8: Tablerel8,
}
impl instructionVar62 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BLT"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 45i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1925:1"]
#[derive(Clone, Debug)]
struct instructionVar63 {
    rel8: Tablerel8,
}
impl instructionVar63 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BMI"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 43i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1930:1"]
#[derive(Clone, Debug)]
struct instructionVar64 {
    rel8: Tablerel8,
}
impl instructionVar64 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BNE"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 38i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1935:1"]
#[derive(Clone, Debug)]
struct instructionVar65 {
    rel8: Tablerel8,
}
impl instructionVar65 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BPL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 42i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1940:1"]
#[derive(Clone, Debug)]
struct instructionVar66 {
    rel8: Tablerel8,
}
impl instructionVar66 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BRA"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 32i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1945:1"]
#[derive(Clone, Debug)]
struct instructionVar67 {
    opr8a_8: Tableopr8a_8,
    msk8: Tablemsk8,
    rel8: Tablerel8,
}
impl instructionVar67 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BRCLR"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 79i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        let mut block_3_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_3_len = block_3_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_3_len;
        tokens_current =
            &tokens_current[usize::try_from(block_3_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                opr8a_8,
                msk8,
                rel8,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1951:1"]
#[derive(Clone, Debug)]
struct instructionVar68 {
    opr16a_8: Tableopr16a_8,
    msk8: Tablemsk8,
    rel8: Tablerel8,
}
impl instructionVar68 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BRCLR"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 31i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        let mut block_3_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_3_len = block_3_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_3_len;
        tokens_current =
            &tokens_current[usize::try_from(block_3_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                opr16a_8,
                msk8,
                rel8,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1957:1"]
#[derive(Clone, Debug)]
struct instructionVar69 {
    indexed1_3: Tableindexed1_3,
    msk8: Tablemsk8,
    rel8: Tablerel8,
}
impl instructionVar69 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BRCLR"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 15i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_3 = if let Some((len, table)) = Tableindexed1_3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        let mut block_3_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_3_len = block_3_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_3_len;
        tokens_current =
            &tokens_current[usize::try_from(block_3_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed1_3,
                msk8,
                rel8,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1966:1"]
#[derive(Clone, Debug)]
struct instructionVar70 {
    SkipNextInstr: TableSkipNextInstr,
}
impl instructionVar70 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BRN"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.SkipNextInstr.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 33i64 {
            return None;
        }
        let SkipNextInstr = if let Some((len, table)) =
            TableSkipNextInstr::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SkipNextInstr }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1971:1"]
#[derive(Clone, Debug)]
struct instructionVar71 {
    opr8a_8: Tableopr8a_8,
    msk8: Tablemsk8,
    rel8: Tablerel8,
}
impl instructionVar71 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BRSET"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 78i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        let mut block_3_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_3_len = block_3_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_3_len;
        tokens_current =
            &tokens_current[usize::try_from(block_3_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                opr8a_8,
                msk8,
                rel8,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1977:1"]
#[derive(Clone, Debug)]
struct instructionVar72 {
    opr16a_8: Tableopr16a_8,
    msk8: Tablemsk8,
    rel8: Tablerel8,
}
impl instructionVar72 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BRSET"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 30i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        let mut block_3_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_3_len = block_3_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_3_len;
        tokens_current =
            &tokens_current[usize::try_from(block_3_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                opr16a_8,
                msk8,
                rel8,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1983:1"]
#[derive(Clone, Debug)]
struct instructionVar73 {
    indexed1_3: Tableindexed1_3,
    msk8: Tablemsk8,
    rel8: Tablerel8,
}
impl instructionVar73 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BRSET"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 14i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_3 = if let Some((len, table)) = Tableindexed1_3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        let mut block_3_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_3_len = block_3_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_3_len;
        tokens_current =
            &tokens_current[usize::try_from(block_3_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed1_3,
                msk8,
                rel8,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1989:1"]
#[derive(Clone, Debug)]
struct instructionVar74 {
    opr8a_8: Tableopr8a_8,
    msk8: Tablemsk8,
}
impl instructionVar74 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BSET"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 76i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8, msk8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1998:1"]
#[derive(Clone, Debug)]
struct instructionVar75 {
    opr16a_8: Tableopr16a_8,
    msk8: Tablemsk8,
}
impl instructionVar75 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BSET"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 28i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8, msk8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2007:1"]
#[derive(Clone, Debug)]
struct instructionVar76 {
    indexed1_3: Tableindexed1_3,
    msk8: Tablemsk8,
}
impl instructionVar76 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("BSET"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.msk8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 12i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_3 = if let Some((len, table)) = Tableindexed1_3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_3, msk8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2016:1"]
#[derive(Clone, Debug)]
struct instructionVar77 {
    rel8: Tablerel8,
}
impl instructionVar77 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BSR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 7i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2061:1"]
#[derive(Clone, Debug)]
struct instructionVar78 {
    rel8: Tablerel8,
}
impl instructionVar78 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BVC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 40i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2066:1"]
#[derive(Clone, Debug)]
struct instructionVar79 {
    rel8: Tablerel8,
}
impl instructionVar79 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BVS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 41i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2080:1"]
#[derive(Clone, Debug)]
struct instructionVar80 {
    CallDest: TableCallDest,
}
impl instructionVar80 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CALL"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.CallDest.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 74i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let CallDest = if let Some((len, table)) = TableCallDest::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CallDest }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2096:1"]
#[derive(Clone, Debug)]
struct instructionVar81 {
    indexed2_3: Tableindexed2_3,
    page: Tablepage,
}
impl instructionVar81 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CALL"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.page.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c44 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 75i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c44(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_3 = if let Some((len, table)) = Tableindexed2_3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let page = if let Some((len, table)) =
            Tablepage::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_3, page }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2113:1"]
#[derive(Clone, Debug)]
struct instructionVar82 {
    indexed0_2: Tableindexed0_2,
}
impl instructionVar82 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CALL"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed0_2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c38 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 75i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c38(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed0_2 = if let Some((len, table)) = Tableindexed0_2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed0_2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2133:1"]
#[derive(Clone, Debug)]
struct instructionVar83 {}
impl instructionVar83 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("CBA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c25 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if context_instance.register().read_Prefix18_disassembly() != 1i64 {
                return None;
            }
            if token_parser.TokenFieldop8().disassembly() != 23i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c25(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2142:1"]
#[derive(Clone, Debug)]
struct instructionVar84 {}
impl instructionVar84 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("CLC")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 4350i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2147:1"]
#[derive(Clone, Debug)]
struct instructionVar85 {}
impl instructionVar85 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("CLI")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 4335i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2152:1"]
#[derive(Clone, Debug)]
struct instructionVar86 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar86 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CLR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 121i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2161:1"]
#[derive(Clone, Debug)]
struct instructionVar87 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar87 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CLR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 105i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2170:1"]
#[derive(Clone, Debug)]
struct instructionVar88 {}
impl instructionVar88 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("CLRA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 135i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2179:1"]
#[derive(Clone, Debug)]
struct instructionVar89 {}
impl instructionVar89 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("CLRB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 199i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2232:1"]
#[derive(Clone, Debug)]
struct instructionVar90 {}
impl instructionVar90 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("CLV")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 4349i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2237:1"]
#[derive(Clone, Debug)]
struct instructionVar91 {
    iopr8i: Tableiopr8i,
}
impl instructionVar91 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 129i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2247:1"]
#[derive(Clone, Debug)]
struct instructionVar92 {
    opr8a_8: Tableopr8a_8,
}
impl instructionVar92 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 145i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2257:1"]
#[derive(Clone, Debug)]
struct instructionVar93 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar93 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 177i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2267:1"]
#[derive(Clone, Debug)]
struct instructionVar94 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar94 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 161i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2277:1"]
#[derive(Clone, Debug)]
struct instructionVar95 {
    iopr8i: Tableiopr8i,
}
impl instructionVar95 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 193i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2287:1"]
#[derive(Clone, Debug)]
struct instructionVar96 {
    opr8a_8: Tableopr8a_8,
}
impl instructionVar96 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 209i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2297:1"]
#[derive(Clone, Debug)]
struct instructionVar97 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar97 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 241i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2307:1"]
#[derive(Clone, Debug)]
struct instructionVar98 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar98 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 225i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2317:1"]
#[derive(Clone, Debug)]
struct instructionVar99 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar99 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("COM"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 113i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2327:1"]
#[derive(Clone, Debug)]
struct instructionVar100 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar100 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("COM"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 97i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2337:1"]
#[derive(Clone, Debug)]
struct instructionVar101 {}
impl instructionVar101 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("COMA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 65i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2346:1"]
#[derive(Clone, Debug)]
struct instructionVar102 {}
impl instructionVar102 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("COMB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 81i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2401:1"]
#[derive(Clone, Debug)]
struct instructionVar103 {
    iopr16i: Tableiopr16i,
}
impl instructionVar103 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 140i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr16i = if let Some((len, table)) = Tableiopr16i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2411:1"]
#[derive(Clone, Debug)]
struct instructionVar104 {
    opr8a_16: Tableopr8a_16,
}
impl instructionVar104 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 156i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2421:1"]
#[derive(Clone, Debug)]
struct instructionVar105 {
    opr16a_16: Tableopr16a_16,
}
impl instructionVar105 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 188i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2431:1"]
#[derive(Clone, Debug)]
struct instructionVar106 {
    indexed2_5: Tableindexed2_5,
}
impl instructionVar106 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 172i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2635:1"]
#[derive(Clone, Debug)]
struct instructionVar107 {
    SkipNext2Bytes: TableSkipNext2Bytes,
}
impl instructionVar107 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_loc: i64 = 0;
        calc_loc = (i64::try_from(inst_next).unwrap() & 16777215i64);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("CPS"),
            DisplayElement::Literal(" "),
            DisplayElement::Number(true, calc_loc),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_loc: i64 = 0;
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c43 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 143i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c43(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let SkipNext2Bytes = if let Some((len, table)) =
            TableSkipNext2Bytes::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SkipNext2Bytes }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2647:1"]
#[derive(Clone, Debug)]
struct instructionVar108 {
    opr8a_16: Tableopr8a_16,
}
impl instructionVar108 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 159i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2657:1"]
#[derive(Clone, Debug)]
struct instructionVar109 {
    SkipNext2Bytes: TableSkipNext2Bytes,
}
impl instructionVar109 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_loc: i64 = 0;
        calc_loc = (i64::try_from(inst_next).unwrap() & 16777215i64);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("CPS"),
            DisplayElement::Literal(" "),
            DisplayElement::Number(true, calc_loc),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_loc: i64 = 0;
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c43 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 191i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c43(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let SkipNext2Bytes = if let Some((len, table)) =
            TableSkipNext2Bytes::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SkipNext2Bytes }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2670:1"]
#[derive(Clone, Debug)]
struct instructionVar110 {
    indexed2_5: Tableindexed2_5,
}
impl instructionVar110 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 175i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2680:1"]
#[derive(Clone, Debug)]
struct instructionVar111 {
    iopr16i: Tableiopr16i,
}
impl instructionVar111 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPX"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 142i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr16i = if let Some((len, table)) = Tableiopr16i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2690:1"]
#[derive(Clone, Debug)]
struct instructionVar112 {
    opr8a_16: Tableopr8a_16,
}
impl instructionVar112 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPX"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 158i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2700:1"]
#[derive(Clone, Debug)]
struct instructionVar113 {
    opr16a_16: Tableopr16a_16,
}
impl instructionVar113 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPX"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 190i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2710:1"]
#[derive(Clone, Debug)]
struct instructionVar114 {
    indexed2_5: Tableindexed2_5,
}
impl instructionVar114 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPX"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 174i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2720:1"]
#[derive(Clone, Debug)]
struct instructionVar115 {
    iopr16i: Tableiopr16i,
}
impl instructionVar115 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPY"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 141i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr16i = if let Some((len, table)) = Tableiopr16i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2730:1"]
#[derive(Clone, Debug)]
struct instructionVar116 {
    opr8a_16: Tableopr8a_16,
}
impl instructionVar116 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPY"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 157i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2740:1"]
#[derive(Clone, Debug)]
struct instructionVar117 {
    opr16a_16: Tableopr16a_16,
}
impl instructionVar117 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPY"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 189i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2750:1"]
#[derive(Clone, Debug)]
struct instructionVar118 {
    indexed2_5: Tableindexed2_5,
}
impl instructionVar118 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("CPY"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 173i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2760:1"]
#[derive(Clone, Debug)]
struct instructionVar119 {}
impl instructionVar119 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("DAA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 7i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2769:1"]
#[derive(Clone, Debug)]
struct instructionVar120 {
    byte9_8: TokenField_byte9_8,
    rel9: Tablerel9,
}
impl instructionVar120 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("DBEQ"),
            DisplayElement::Literal(" "),
            self.byte9_8.display(),
            DisplayElement::Literal(", "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 0i64 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let byte9_8 = token_parser.TokenFieldbyte9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, byte9_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2775:1"]
#[derive(Clone, Debug)]
struct instructionVar121 {
    word9_8: TokenField_word9_8,
    rel9: Tablerel9,
}
impl instructionVar121 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("DBEQ"),
            DisplayElement::Literal(" "),
            self.word9_8.display(),
            DisplayElement::Literal(", "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 1i64 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let word9_8 = token_parser.TokenFieldword9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, word9_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2781:1"]
#[derive(Clone, Debug)]
struct instructionVar122 {
    byte9_8: TokenField_byte9_8,
    rel9: Tablerel9,
}
impl instructionVar122 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("DBNE"),
            DisplayElement::Literal(" "),
            self.byte9_8.display(),
            DisplayElement::Literal(", "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 0i64 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let byte9_8 = token_parser.TokenFieldbyte9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, byte9_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2787:1"]
#[derive(Clone, Debug)]
struct instructionVar123 {
    word9_8: TokenField_word9_8,
    rel9: Tablerel9,
}
impl instructionVar123 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("DBNE"),
            DisplayElement::Literal(" "),
            self.word9_8.display(),
            DisplayElement::Literal(", "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 1i64 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let word9_8 = token_parser.TokenFieldword9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, word9_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2793:1"]
#[derive(Clone, Debug)]
struct instructionVar124 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar124 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("DEC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 115i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2803:1"]
#[derive(Clone, Debug)]
struct instructionVar125 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar125 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("DEC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 99i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2813:1"]
#[derive(Clone, Debug)]
struct instructionVar126 {}
impl instructionVar126 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("DECA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 67i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2822:1"]
#[derive(Clone, Debug)]
struct instructionVar127 {}
impl instructionVar127 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("DECB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 83i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2877:1"]
#[derive(Clone, Debug)]
struct instructionVar128 {}
impl instructionVar128 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("DES")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 7071i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2882:1"]
#[derive(Clone, Debug)]
struct instructionVar129 {}
impl instructionVar129 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("DEX")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 9i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2888:1"]
#[derive(Clone, Debug)]
struct instructionVar130 {}
impl instructionVar130 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("DEY")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 3i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2894:1"]
#[derive(Clone, Debug)]
struct instructionVar131 {}
impl instructionVar131 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("EDIV")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 17i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2907:1"]
#[derive(Clone, Debug)]
struct instructionVar132 {}
impl instructionVar132 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("EDIVS")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 20i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2920:1"]
#[derive(Clone, Debug)]
struct instructionVar133 {
    opr16a: Tableopr16a,
}
impl instructionVar133 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EMACS"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 18i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a = if let Some((len, table)) = Tableopr16a::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2934:1"]
#[derive(Clone, Debug)]
struct instructionVar134 {
    indexed2_5: Tableindexed2_5,
}
impl instructionVar134 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EMAXD"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 26i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2947:1"]
#[derive(Clone, Debug)]
struct instructionVar135 {
    indexed2_5: Tableindexed2_5,
}
impl instructionVar135 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EMAXM"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 30i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2960:1"]
#[derive(Clone, Debug)]
struct instructionVar136 {
    indexed2_5: Tableindexed2_5,
}
impl instructionVar136 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EMIND"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 27i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2973:1"]
#[derive(Clone, Debug)]
struct instructionVar137 {
    indexed2_5: Tableindexed2_5,
}
impl instructionVar137 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EMINM"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 31i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2986:1"]
#[derive(Clone, Debug)]
struct instructionVar138 {}
impl instructionVar138 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("EMUL")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 19i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2996:1"]
#[derive(Clone, Debug)]
struct instructionVar139 {}
impl instructionVar139 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("EMULS")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 19i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3006:1"]
#[derive(Clone, Debug)]
struct instructionVar140 {
    iopr8i: Tableiopr8i,
}
impl instructionVar140 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EORA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 136i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3015:1"]
#[derive(Clone, Debug)]
struct instructionVar141 {
    opr8a_8: Tableopr8a_8,
}
impl instructionVar141 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EORA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 152i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3024:1"]
#[derive(Clone, Debug)]
struct instructionVar142 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar142 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EORA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 184i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3033:1"]
#[derive(Clone, Debug)]
struct instructionVar143 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar143 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EORA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 168i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3042:1"]
#[derive(Clone, Debug)]
struct instructionVar144 {
    iopr8i: Tableiopr8i,
}
impl instructionVar144 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EORB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 200i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3051:1"]
#[derive(Clone, Debug)]
struct instructionVar145 {
    opr8a_8: Tableopr8a_8,
}
impl instructionVar145 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EORB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 216i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3060:1"]
#[derive(Clone, Debug)]
struct instructionVar146 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar146 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EORB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 248i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3069:1"]
#[derive(Clone, Debug)]
struct instructionVar147 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar147 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("EORB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 232i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3166:1"]
#[derive(Clone, Debug)]
struct instructionVar148 {
    indexed2_1: Tableindexed2_1,
}
impl instructionVar148 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ETBL"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 63i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_1 = if let Some((len, table)) = Tableindexed2_1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3175:1"]
#[derive(Clone, Debug)]
struct instructionVar149 {}
impl instructionVar149 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::D),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c29 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c29(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 0i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c89 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 12i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c89(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 8i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c89 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 12i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c89(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3189:1"]
#[derive(Clone, Debug)]
struct instructionVar150 {}
impl instructionVar150 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::D),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c29 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c29(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 1i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c89 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 12i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c89(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 9i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c89 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 12i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c89(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3202:1"]
#[derive(Clone, Debug)]
struct instructionVar151 {}
impl instructionVar151 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::A),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::D),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c29 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c29(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 4i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 8i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 12i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 8i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3214:1"]
#[derive(Clone, Debug)]
struct instructionVar152 {}
impl instructionVar152 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::B),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::D),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c29 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c29(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 4i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c38 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 9i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c38(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 12i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c38 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 9i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c38(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3226:1"]
#[derive(Clone, Debug)]
struct instructionVar153 {}
impl instructionVar153 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::CCRH),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c32 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c32(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c5 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 8i64 {
                    return None;
                }
                let mut sub_pattern_c55 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldcolumns7_4().disassembly()
                            != 10i64
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c55(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c5(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3238:1"]
#[derive(Clone, Debug)]
struct instructionVar154 {}
impl instructionVar154 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::A),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::CCRH),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c32 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c32(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c5 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 10i64 {
                    return None;
                }
                let mut sub_pattern_c21 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldcolumns7_4().disassembly()
                            != 8i64
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c21(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c5(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3250:1"]
#[derive(Clone, Debug)]
struct instructionVar155 {}
impl instructionVar155 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::CCRW),
            DisplayElement::Literal(", "),
            DisplayElement::Literal("CCRW"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c37 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c37(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c5 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 10i64 {
                    return None;
                }
                let mut sub_pattern_c55 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldcolumns7_4().disassembly()
                            != 10i64
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c55(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c5(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3259:1"]
#[derive(Clone, Debug)]
struct instructionVar156 {
    bytes_ABCl_6_4: TokenField_bytes_ABCl_6_4,
    bytes_ABCl_2_0: TokenField_bytes_ABCl_2_0,
}
impl instructionVar156 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.bytes_ABCl_6_4.display(),
            DisplayElement::Literal(", "),
            self.bytes_ABCl_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 0i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 8i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 9i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 1i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 8i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 9i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 8i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 8i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 9i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 9i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 8i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 9i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABCl_6_4 = token_parser.TokenFieldbytes_ABCl_6_4();
        let bytes_ABCl_2_0 = token_parser.TokenFieldbytes_ABCl_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_ABCl_6_4,
                bytes_ABCl_2_0,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3274:1"]
#[derive(Clone, Debug)]
struct instructionVar157 {
    bytes_ABCl_6_4: TokenField_bytes_ABCl_6_4,
}
impl instructionVar157 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.bytes_ABCl_6_4.display(),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::CCR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c44 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c44(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 2i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 8i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 9i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 10i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c38 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 9i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c38(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABCl_6_4 = token_parser.TokenFieldbytes_ABCl_6_4();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { bytes_ABCl_6_4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3287:1"]
#[derive(Clone, Debug)]
struct instructionVar158 {
    bytes_ABCl_2_0: TokenField_bytes_ABCl_2_0,
}
impl instructionVar158 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::CCR),
            DisplayElement::Literal(", "),
            self.bytes_ABCl_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c44 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c44(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 0i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c55 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c55(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 1i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c55 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c55(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 2i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c55 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c55(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 9i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c55 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c55(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABCl_2_0 = token_parser.TokenFieldbytes_ABCl_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { bytes_ABCl_2_0 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3302:1"]
#[derive(Clone, Debug)]
struct instructionVar159 {
    bytes_T3l_XlYlSl_6_4: TokenField_bytes_T3l_XlYlSl_6_4,
}
impl instructionVar159 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.bytes_T3l_XlYlSl_6_4.display(),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c5 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 0i64 {
                    return None;
                }
                let mut sub_pattern_c72 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 =
                            |tokens_param: &[u8], context_param: &mut T| {
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 11i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 13i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 14i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 15i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                None
                            };
                        let ((), (), block_0_len) =
                            block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c72(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c5(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_T3l_XlYlSl_6_4 =
            token_parser.TokenFieldbytes_T3l_XlYlSl_6_4();
        let words_T3_XYS_6_4 = token_parser.TokenFieldwords_T3_XYS_6_4();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_T3l_XlYlSl_6_4,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3313:1"]
#[derive(Clone, Debug)]
struct instructionVar160 {
    bytes_T3h_XhYhSh_6_4: TokenField_bytes_T3h_XhYhSh_6_4,
}
impl instructionVar160 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.bytes_T3h_XhYhSh_6_4.display(),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c5 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 8i64 {
                    return None;
                }
                let mut sub_pattern_c72 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 =
                            |tokens_param: &[u8], context_param: &mut T| {
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 11i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 13i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 14i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 15i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                None
                            };
                        let ((), (), block_0_len) =
                            block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c72(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c5(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_T3h_XhYhSh_6_4 =
            token_parser.TokenFieldbytes_T3h_XhYhSh_6_4();
        let words_T3_XYS_6_4 = token_parser.TokenFieldwords_T3_XYS_6_4();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_T3h_XhYhSh_6_4,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3324:1"]
#[derive(Clone, Debug)]
struct instructionVar161 {
    bytes_T3l_XlYlSl_6_4: TokenField_bytes_T3l_XlYlSl_6_4,
}
impl instructionVar161 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.bytes_T3l_XlYlSl_6_4.display(),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c5 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 1i64 {
                    return None;
                }
                let mut sub_pattern_c72 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 =
                            |tokens_param: &[u8], context_param: &mut T| {
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 11i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 13i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 14i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 15i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                None
                            };
                        let ((), (), block_0_len) =
                            block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c72(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c5(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_T3l_XlYlSl_6_4 =
            token_parser.TokenFieldbytes_T3l_XlYlSl_6_4();
        let words_T3_XYS_6_4 = token_parser.TokenFieldwords_T3_XYS_6_4();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_T3l_XlYlSl_6_4,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3335:1"]
#[derive(Clone, Debug)]
struct instructionVar162 {
    bytes_T3l_XlYlSl_6_4: TokenField_bytes_T3l_XlYlSl_6_4,
}
impl instructionVar162 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.bytes_T3l_XlYlSl_6_4.display(),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c5 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 9i64 {
                    return None;
                }
                let mut sub_pattern_c72 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 =
                            |tokens_param: &[u8], context_param: &mut T| {
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 11i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 13i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 14i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 15i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                None
                            };
                        let ((), (), block_0_len) =
                            block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c72(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c5(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_T3l_XlYlSl_6_4 =
            token_parser.TokenFieldbytes_T3l_XlYlSl_6_4();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_T3l_XlYlSl_6_4,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3346:1"]
#[derive(Clone, Debug)]
struct instructionVar163 {
    bytes_T3lDlXlYlSl_6_4: TokenField_bytes_T3lDlXlYlSl_6_4,
}
impl instructionVar163 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.bytes_T3lDlXlYlSl_6_4.display(),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::CCR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c5 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 2i64 {
                    return None;
                }
                let mut sub_pattern_c72 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 =
                            |tokens_param: &[u8], context_param: &mut T| {
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 11i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 12i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 13i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 14i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 15i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                None
                            };
                        let ((), (), block_0_len) =
                            block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c72(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c5(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_T3lDlXlYlSl_6_4 =
            token_parser.TokenFieldbytes_T3lDlXlYlSl_6_4();
        let words_T3DXYS_6_4 = token_parser.TokenFieldwords_T3DXYS_6_4();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_T3lDlXlYlSl_6_4,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3358:1"]
#[derive(Clone, Debug)]
struct instructionVar164 {
    words_T3DXYS_6_4: TokenField_words_T3DXYS_6_4,
}
impl instructionVar164 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.words_T3DXYS_6_4.display(),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::CCRW),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c5 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 10i64 {
                    return None;
                }
                let mut sub_pattern_c72 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 =
                            |tokens_param: &[u8], context_param: &mut T| {
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 11i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 12i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 13i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 14i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 15i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                None
                            };
                        let ((), (), block_0_len) =
                            block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c72(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c5(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let words_T3DXYS_6_4 = token_parser.TokenFieldwords_T3DXYS_6_4();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { words_T3DXYS_6_4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3370:1"]
#[derive(Clone, Debug)]
struct instructionVar165 {}
impl instructionVar165 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::D),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::TMP1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c32 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c32(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c5 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 11i64 {
                    return None;
                }
                let mut sub_pattern_c89 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldcolumns7_4().disassembly()
                            != 12i64
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c89(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c5(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3382:1"]
#[derive(Clone, Debug)]
struct instructionVar166 {}
impl instructionVar166 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::TMP1),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::D),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c32 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c32(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c5 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 12i64 {
                    return None;
                }
                let mut sub_pattern_c72 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldcolumns7_4().disassembly()
                            != 11i64
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c72(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c5(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3393:1"]
#[derive(Clone, Debug)]
struct instructionVar167 {
    words_T3DXYS_6_4: TokenField_words_T3DXYS_6_4,
    words_T2DXYS_2_0: TokenField_words_T2DXYS_2_0,
}
impl instructionVar167 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.words_T3DXYS_6_4.display(),
            DisplayElement::Literal(", "),
            self.words_T2DXYS_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c59 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c59(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 3i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c72 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 11i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 12i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 13i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 14i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 15i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c72(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 4i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c72 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 11i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 12i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 13i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 14i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 15i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c72(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 5i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c72 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 11i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 13i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 14i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 15i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c72(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 6i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c72 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 11i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 13i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 14i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 15i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c72(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 7i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c72 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 11i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 12i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 13i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 14i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 15i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c72(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 11i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c72 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 11i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 13i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 14i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 15i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c72(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 12i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c89 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 12i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 13i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 14i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 15i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c89(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 13i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c72 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 11i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 12i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 13i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 14i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 15i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c72(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 14i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c72 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 11i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 12i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 13i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 14i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 15i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c72(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 15i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c72 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 11i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 12i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 13i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 14i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 15i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c72(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let words_T3DXYS_6_4 = token_parser.TokenFieldwords_T3DXYS_6_4();
        let words_T2DXYS_2_0 = token_parser.TokenFieldwords_T2DXYS_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                words_T3DXYS_6_4,
                words_T2DXYS_2_0,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3416:1"]
#[derive(Clone, Debug)]
struct instructionVar168 {
    bytes_ABCl_6_4: TokenField_bytes_ABCl_6_4,
    words_T2DXYS_2_0: TokenField_words_T2DXYS_2_0,
}
impl instructionVar168 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.bytes_ABCl_6_4.display(),
            DisplayElement::Literal(", "),
            self.words_T2DXYS_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c57 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c57(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 3i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 8i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 9i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 5i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 8i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 9i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 6i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 8i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 9i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 7i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 8i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 9i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABCl_6_4 = token_parser.TokenFieldbytes_ABCl_6_4();
        let words_T2DXYS_2_0 = token_parser.TokenFieldwords_T2DXYS_2_0();
        let bytes_T2lDlXlYlSl_2_0 =
            token_parser.TokenFieldbytes_T2lDlXlYlSl_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_ABCl_6_4,
                words_T2DXYS_2_0,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3431:1"]
#[derive(Clone, Debug)]
struct instructionVar169 {
    bytes_ABCl_6_4: TokenField_bytes_ABCl_6_4,
    bytes_T2hDhXhYhSh_2_0: TokenField_bytes_T2hDhXhYhSh_2_0,
}
impl instructionVar169 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.bytes_ABCl_6_4.display(),
            DisplayElement::Literal(", "),
            self.bytes_T2hDhXhYhSh_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c62 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c62(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 11i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 8i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 13i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 8i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 14i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 8i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 15i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 8i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABCl_6_4 = token_parser.TokenFieldbytes_ABCl_6_4();
        let bytes_T2hDhXhYhSh_2_0 =
            token_parser.TokenFieldbytes_T2hDhXhYhSh_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_ABCl_6_4,
                bytes_T2hDhXhYhSh_2_0,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3447:1"]
#[derive(Clone, Debug)]
struct instructionVar170 {
    bytes_ABCl_6_4: TokenField_bytes_ABCl_6_4,
    bytes_T2lDlXlYlSl_2_0: TokenField_bytes_T2lDlXlYlSl_2_0,
}
impl instructionVar170 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            self.bytes_ABCl_6_4.display(),
            DisplayElement::Literal(", "),
            self.bytes_T2lDlXlYlSl_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c62 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c62(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 11i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c38 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 9i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c38(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 13i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c38 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 9i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c38(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 14i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c38 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 9i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c38(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 15i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c38 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 9i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c38(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABCl_6_4 = token_parser.TokenFieldbytes_ABCl_6_4();
        let bytes_T2lDlXlYlSl_2_0 =
            token_parser.TokenFieldbytes_T2lDlXlYlSl_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_ABCl_6_4,
                bytes_T2lDlXlYlSl_2_0,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3462:1"]
#[derive(Clone, Debug)]
struct instructionVar171 {
    words_T2DXYS_2_0: TokenField_words_T2DXYS_2_0,
}
impl instructionVar171 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::CCR),
            DisplayElement::Literal(", "),
            self.words_T2DXYS_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 3i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c55 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c55(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 4i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c55 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c55(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 5i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c55 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c55(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 6i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c55 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c55(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 7i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c55 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c55(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let words_T2DXYS_2_0 = token_parser.TokenFieldwords_T2DXYS_2_0();
        let bytes_T2lDlXlYlSl_2_0 =
            token_parser.TokenFieldbytes_T2lDlXlYlSl_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { words_T2DXYS_2_0 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3477:1"]
#[derive(Clone, Debug)]
struct instructionVar172 {
    words_T2DXYS_2_0: TokenField_words_T2DXYS_2_0,
}
impl instructionVar172 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("EXG"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::CCRW),
            DisplayElement::Literal(", "),
            self.words_T2DXYS_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 11i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c55 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c55(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 12i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c55 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c55(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 13i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c55 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c55(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 14i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c55 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c55(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 15i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c55 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 10i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c55(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let words_T2DXYS_2_0 = token_parser.TokenFieldwords_T2DXYS_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { words_T2DXYS_2_0 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3492:1"]
#[derive(Clone, Debug)]
struct instructionVar173 {}
impl instructionVar173 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FDIV")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 17i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3553:1"]
#[derive(Clone, Debug)]
struct instructionVar174 {
    byte9_8: TokenField_byte9_8,
    rel9: Tablerel9,
}
impl instructionVar174 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("IBEQ"),
            DisplayElement::Literal(" "),
            self.byte9_8.display(),
            DisplayElement::Literal(", "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 0i64 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let byte9_8 = token_parser.TokenFieldbyte9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, byte9_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3559:1"]
#[derive(Clone, Debug)]
struct instructionVar175 {
    word9_8: TokenField_word9_8,
    rel9: Tablerel9,
}
impl instructionVar175 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("IBEQ"),
            DisplayElement::Literal(" "),
            self.word9_8.display(),
            DisplayElement::Literal(", "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 1i64 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let word9_8 = token_parser.TokenFieldword9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, word9_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3565:1"]
#[derive(Clone, Debug)]
struct instructionVar176 {
    byte9_8: TokenField_byte9_8,
    rel9: Tablerel9,
}
impl instructionVar176 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("IBNE"),
            DisplayElement::Literal(" "),
            self.byte9_8.display(),
            DisplayElement::Literal(", "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 5i64 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 0i64 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let byte9_8 = token_parser.TokenFieldbyte9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, byte9_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3571:1"]
#[derive(Clone, Debug)]
struct instructionVar177 {
    word9_8: TokenField_word9_8,
    rel9: Tablerel9,
}
impl instructionVar177 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("IBNE"),
            DisplayElement::Literal(" "),
            self.word9_8.display(),
            DisplayElement::Literal(", "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 5i64 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 1i64 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let word9_8 = token_parser.TokenFieldword9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, word9_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3577:1"]
#[derive(Clone, Debug)]
struct instructionVar178 {}
impl instructionVar178 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("IDIV")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 16i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3588:1"]
#[derive(Clone, Debug)]
struct instructionVar179 {}
impl instructionVar179 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("IDIVS")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 21i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3600:1"]
#[derive(Clone, Debug)]
struct instructionVar180 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar180 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("INC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 114i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3610:1"]
#[derive(Clone, Debug)]
struct instructionVar181 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar181 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("INC"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 98i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3620:1"]
#[derive(Clone, Debug)]
struct instructionVar182 {}
impl instructionVar182 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("INCA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 66i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3629:1"]
#[derive(Clone, Debug)]
struct instructionVar183 {}
impl instructionVar183 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("INCB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 82i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3684:1"]
#[derive(Clone, Debug)]
struct instructionVar184 {}
impl instructionVar184 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("INS")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 7041i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3689:1"]
#[derive(Clone, Debug)]
struct instructionVar185 {}
impl instructionVar185 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("INX")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 8i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3695:1"]
#[derive(Clone, Debug)]
struct instructionVar186 {}
impl instructionVar186 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("INY")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 2i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3701:1"]
#[derive(Clone, Debug)]
struct instructionVar187 {
    opr16a: Tableopr16a,
}
impl instructionVar187 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JMP"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c45 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 6i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c45(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a = if let Some((len, table)) = Tableopr16a::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3706:1"]
#[derive(Clone, Debug)]
struct instructionVar188 {
    indexedA_5: TableindexedA_5,
}
impl instructionVar188 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JMP"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexedA_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 5i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexedA_5 = if let Some((len, table)) = TableindexedA_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexedA_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3711:1"]
#[derive(Clone, Debug)]
struct instructionVar189 {
    opr8a: Tableopr8a,
}
impl instructionVar189 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JSR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c44 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 23i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c44(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a = if let Some((len, table)) =
            Tableopr8a::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3719:1"]
#[derive(Clone, Debug)]
struct instructionVar190 {
    opr16a: Tableopr16a,
}
impl instructionVar190 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JSR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c43 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 22i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c43(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a = if let Some((len, table)) = Tableopr16a::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3727:1"]
#[derive(Clone, Debug)]
struct instructionVar191 {
    indexedA_5: TableindexedA_5,
}
impl instructionVar191 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("JSR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexedA_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 21i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexedA_5 = if let Some((len, table)) = TableindexedA_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexedA_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3735:1"]
#[derive(Clone, Debug)]
struct instructionVar192 {
    rel16: Tablerel16,
}
impl instructionVar192 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBCC"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 36i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3740:1"]
#[derive(Clone, Debug)]
struct instructionVar193 {
    rel16: Tablerel16,
}
impl instructionVar193 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBCS"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 37i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3745:1"]
#[derive(Clone, Debug)]
struct instructionVar194 {
    rel16: Tablerel16,
}
impl instructionVar194 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBEQ"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 39i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3750:1"]
#[derive(Clone, Debug)]
struct instructionVar195 {
    rel16: Tablerel16,
}
impl instructionVar195 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBGE"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 44i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3755:1"]
#[derive(Clone, Debug)]
struct instructionVar196 {
    rel16: Tablerel16,
}
impl instructionVar196 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBGT"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 46i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3760:1"]
#[derive(Clone, Debug)]
struct instructionVar197 {
    rel16: Tablerel16,
}
impl instructionVar197 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBHI"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 34i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3767:1"]
#[derive(Clone, Debug)]
struct instructionVar198 {
    rel16: Tablerel16,
}
impl instructionVar198 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBLE"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 47i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3774:1"]
#[derive(Clone, Debug)]
struct instructionVar199 {
    rel16: Tablerel16,
}
impl instructionVar199 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBLS"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 35i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3779:1"]
#[derive(Clone, Debug)]
struct instructionVar200 {
    rel16: Tablerel16,
}
impl instructionVar200 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBLT"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 45i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3784:1"]
#[derive(Clone, Debug)]
struct instructionVar201 {
    rel16: Tablerel16,
}
impl instructionVar201 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBMI"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 43i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3789:1"]
#[derive(Clone, Debug)]
struct instructionVar202 {
    rel16: Tablerel16,
}
impl instructionVar202 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBNE"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 38i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3794:1"]
#[derive(Clone, Debug)]
struct instructionVar203 {
    rel16: Tablerel16,
}
impl instructionVar203 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBPL"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 42i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3799:1"]
#[derive(Clone, Debug)]
struct instructionVar204 {
    rel16: Tablerel16,
}
impl instructionVar204 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBRA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 32i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3805:1"]
#[derive(Clone, Debug)]
struct instructionVar205 {
    rel16: Tablerel16,
}
impl instructionVar205 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBRN"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 33i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3809:1"]
#[derive(Clone, Debug)]
struct instructionVar206 {
    rel16: Tablerel16,
}
impl instructionVar206 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBVC"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 40i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3814:1"]
#[derive(Clone, Debug)]
struct instructionVar207 {
    rel16: Tablerel16,
}
impl instructionVar207 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LBVS"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 41i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3819:1"]
#[derive(Clone, Debug)]
struct instructionVar208 {
    iopr8i: Tableiopr8i,
}
impl instructionVar208 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LDAA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 134i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3830:1"]
#[derive(Clone, Debug)]
struct instructionVar209 {
    GPaged: TableGPaged,
    opr8a_8: Tableopr8a_8,
}
impl instructionVar209 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LDAA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 150i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3839:1"]
#[derive(Clone, Debug)]
struct instructionVar210 {
    GPaged: TableGPaged,
    opr16a_8: Tableopr16a_8,
}
impl instructionVar210 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LDAA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 182i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3848:1"]
#[derive(Clone, Debug)]
struct instructionVar211 {
    GPaged: TableGPaged,
    indexed1_5: Tableindexed1_5,
}
impl instructionVar211 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LDAA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c57 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 166i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c57(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3857:1"]
#[derive(Clone, Debug)]
struct instructionVar212 {
    iopr8i: Tableiopr8i,
}
impl instructionVar212 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LDAB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 198i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3865:1"]
#[derive(Clone, Debug)]
struct instructionVar213 {
    GPaged: TableGPaged,
    opr8a_8: Tableopr8a_8,
}
impl instructionVar213 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LDAB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 214i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3874:1"]
#[derive(Clone, Debug)]
struct instructionVar214 {
    GPaged: TableGPaged,
    opr16a_8: Tableopr16a_8,
}
impl instructionVar214 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LDAB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 246i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3883:1"]
#[derive(Clone, Debug)]
struct instructionVar215 {
    GPaged: TableGPaged,
    indexed1_5: Tableindexed1_5,
}
impl instructionVar215 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LDAB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c57 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 230i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c57(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3892:1"]
#[derive(Clone, Debug)]
struct instructionVar216 {
    iopr16i: Tableiopr16i,
}
impl instructionVar216 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 204i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr16i = if let Some((len, table)) = Tableiopr16i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3900:1"]
#[derive(Clone, Debug)]
struct instructionVar217 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar217 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 220i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3909:1"]
#[derive(Clone, Debug)]
struct instructionVar218 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar218 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 252i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3918:1"]
#[derive(Clone, Debug)]
struct instructionVar219 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar219 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c56 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 236i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c56(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3930:1"]
#[derive(Clone, Debug)]
struct instructionVar220 {
    iopr16i: Tableiopr16i,
}
impl instructionVar220 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 207i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr16i = if let Some((len, table)) = Tableiopr16i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3938:1"]
#[derive(Clone, Debug)]
struct instructionVar221 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar221 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 223i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3947:1"]
#[derive(Clone, Debug)]
struct instructionVar222 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar222 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 255i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3956:1"]
#[derive(Clone, Debug)]
struct instructionVar223 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar223 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c56 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 239i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c56(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3965:1"]
#[derive(Clone, Debug)]
struct instructionVar224 {
    iopr16i: Tableiopr16i,
}
impl instructionVar224 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDX"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 206i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr16i = if let Some((len, table)) = Tableiopr16i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3973:1"]
#[derive(Clone, Debug)]
struct instructionVar225 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar225 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDX"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 222i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3982:1"]
#[derive(Clone, Debug)]
struct instructionVar226 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar226 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDX"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 254i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3991:1"]
#[derive(Clone, Debug)]
struct instructionVar227 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar227 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDX"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c56 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 238i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c56(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4000:1"]
#[derive(Clone, Debug)]
struct instructionVar228 {
    iopr16i: Tableiopr16i,
}
impl instructionVar228 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDY"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 205i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr16i = if let Some((len, table)) = Tableiopr16i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4008:1"]
#[derive(Clone, Debug)]
struct instructionVar229 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar229 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDY"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 221i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4017:1"]
#[derive(Clone, Debug)]
struct instructionVar230 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar230 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDY"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 253i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4026:1"]
#[derive(Clone, Debug)]
struct instructionVar231 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar231 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDY"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c56 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 237i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c56(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4035:1"]
#[derive(Clone, Debug)]
struct instructionVar232 {
    indexed0_3: Tableindexed0_3,
}
impl instructionVar232 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LEAS"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed0_3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 27i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed0_3 = if let Some((len, table)) = Tableindexed0_3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed0_3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4040:1"]
#[derive(Clone, Debug)]
struct instructionVar233 {
    indexed0_3: Tableindexed0_3,
}
impl instructionVar233 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LEAX"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed0_3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 26i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed0_3 = if let Some((len, table)) = Tableindexed0_3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed0_3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4045:1"]
#[derive(Clone, Debug)]
struct instructionVar234 {
    indexed0_3: Tableindexed0_3,
}
impl instructionVar234 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LEAY"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed0_3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 25i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed0_3 = if let Some((len, table)) = Tableindexed0_3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed0_3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4060:1"]
#[derive(Clone, Debug)]
struct instructionVar235 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar235 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LSR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 116i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4071:1"]
#[derive(Clone, Debug)]
struct instructionVar236 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar236 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LSR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 100i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4082:1"]
#[derive(Clone, Debug)]
struct instructionVar237 {}
impl instructionVar237 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("LSRA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 68i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4091:1"]
#[derive(Clone, Debug)]
struct instructionVar238 {}
impl instructionVar238 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("LSRB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 84i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4100:1"]
#[derive(Clone, Debug)]
struct instructionVar239 {}
impl instructionVar239 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("LSRD")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 73i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4157:1"]
#[derive(Clone, Debug)]
struct instructionVar240 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar240 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MAXA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 24i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4171:1"]
#[derive(Clone, Debug)]
struct instructionVar241 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar241 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MAXM"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 28i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4185:1"]
#[derive(Clone, Debug)]
struct instructionVar242 {}
impl instructionVar242 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("MEM")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4193:1"]
#[derive(Clone, Debug)]
struct instructionVar243 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar243 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MINA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 25i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4207:1"]
#[derive(Clone, Debug)]
struct instructionVar244 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar244 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MINM"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 29i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4221:1"]
#[derive(Clone, Debug)]
struct instructionVar245 {
    iopr8i: Tableiopr8i,
    opr16a_8: Tableopr16a_8,
}
impl instructionVar245 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 11i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i, opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4232:1"]
#[derive(Clone, Debug)]
struct instructionVar246 {
    indexed1_1: Tableindexed1_1,
    iopr8i: Tableiopr8i,
}
impl instructionVar246 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.indexed1_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 8i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_1 = if let Some((len, table)) = Tableindexed1_1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_1, iopr8i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4238:1"]
#[derive(Clone, Debug)]
struct instructionVar247 {
    opr16a_8: Tableopr16a_8,
    op2_opr16a_8: Tableop2_opr16a_8,
}
impl instructionVar247 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.op2_opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 12i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let op2_opr16a_8 = if let Some((len, table)) = Tableop2_opr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                opr16a_8,
                op2_opr16a_8,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4252:1"]
#[derive(Clone, Debug)]
struct instructionVar248 {
    indexed1_1: Tableindexed1_1,
    opr16a_8: Tableopr16a_8,
}
impl instructionVar248 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.indexed1_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 9i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_1 = if let Some((len, table)) = Tableindexed1_1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed1_1,
                opr16a_8,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4264:1"]
#[derive(Clone, Debug)]
struct instructionVar249 {
    indexed1_1: Tableindexed1_1,
    opr16a_8: Tableopr16a_8,
}
impl instructionVar249 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 13i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_1 = if let Some((len, table)) = Tableindexed1_1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed1_1,
                opr16a_8,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4281:1"]
#[derive(Clone, Debug)]
struct instructionVar250 {
    indexed1_1: Tableindexed1_1,
    op2_indexed1_1: Tableop2_indexed1_1,
}
impl instructionVar250 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.op2_indexed1_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 10i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_1 = if let Some((len, table)) = Tableindexed1_1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let op2_indexed1_1 = if let Some((len, table)) =
            Tableop2_indexed1_1::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed1_1,
                op2_indexed1_1,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4292:1"]
#[derive(Clone, Debug)]
struct instructionVar251 {
    iopr16i: Tableiopr16i,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar251 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVW"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr16i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 3i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr16i = if let Some((len, table)) = Tableiopr16i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i, opr16a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4303:1"]
#[derive(Clone, Debug)]
struct instructionVar252 {
    indexed2_1: Tableindexed2_1,
    iopr16i: Tableiopr16i,
}
impl instructionVar252 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVW"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr16i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.indexed2_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_1 = if let Some((len, table)) = Tableindexed2_1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let iopr16i = if let Some((len, table)) = Tableiopr16i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed2_1,
                iopr16i,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4309:1"]
#[derive(Clone, Debug)]
struct instructionVar253 {
    opr16a_16: Tableopr16a_16,
    op2_opr16a_16: Tableop2_opr16a_16,
}
impl instructionVar253 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVW"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.op2_opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let op2_opr16a_16 = if let Some((len, table)) =
            Tableop2_opr16a_16::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                opr16a_16,
                op2_opr16a_16,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4325:1"]
#[derive(Clone, Debug)]
struct instructionVar254 {
    indexed2_1: Tableindexed2_1,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar254 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVW"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.indexed2_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_1 = if let Some((len, table)) = Tableindexed2_1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed2_1,
                opr16a_16,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4337:1"]
#[derive(Clone, Debug)]
struct instructionVar255 {
    indexed2_1: Tableindexed2_1,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar255 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVW"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 5i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_1 = if let Some((len, table)) = Tableindexed2_1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed2_1,
                opr16a_16,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4354:1"]
#[derive(Clone, Debug)]
struct instructionVar256 {
    indexed2_1: Tableindexed2_1,
    op2_indexed2_1: Tableop2_indexed2_1,
}
impl instructionVar256 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MOVW"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.op2_indexed2_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 2i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_1 = if let Some((len, table)) = Tableindexed2_1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0u64 as u32;
        let op2_indexed2_1 = if let Some((len, table)) =
            Tableop2_indexed2_1::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_2_len = block_2_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current =
            &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed2_1,
                op2_indexed2_1,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4366:1"]
#[derive(Clone, Debug)]
struct instructionVar257 {}
impl instructionVar257 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("MUL")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 18i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4372:1"]
#[derive(Clone, Debug)]
struct instructionVar258 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar258 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("NEG"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 112i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4383:1"]
#[derive(Clone, Debug)]
struct instructionVar259 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar259 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("NEG"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 96i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4394:1"]
#[derive(Clone, Debug)]
struct instructionVar260 {}
impl instructionVar260 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("NEGA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 64i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4404:1"]
#[derive(Clone, Debug)]
struct instructionVar261 {}
impl instructionVar261 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("NEGB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 80i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4464:1"]
#[derive(Clone, Debug)]
struct instructionVar262 {}
impl instructionVar262 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("NOP")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 167i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4468:1"]
#[derive(Clone, Debug)]
struct instructionVar263 {
    iopr8i: Tableiopr8i,
}
impl instructionVar263 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ORAA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 138i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4476:1"]
#[derive(Clone, Debug)]
struct instructionVar264 {
    opr8a_8: Tableopr8a_8,
}
impl instructionVar264 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ORAA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 154i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4484:1"]
#[derive(Clone, Debug)]
struct instructionVar265 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar265 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ORAA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 186i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4492:1"]
#[derive(Clone, Debug)]
struct instructionVar266 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar266 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ORAA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 170i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4500:1"]
#[derive(Clone, Debug)]
struct instructionVar267 {
    iopr8i: Tableiopr8i,
}
impl instructionVar267 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ORAB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 202i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4508:1"]
#[derive(Clone, Debug)]
struct instructionVar268 {
    opr8a_8: Tableopr8a_8,
}
impl instructionVar268 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ORAB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 218i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4516:1"]
#[derive(Clone, Debug)]
struct instructionVar269 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar269 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ORAB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 250i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4524:1"]
#[derive(Clone, Debug)]
struct instructionVar270 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar270 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ORAB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 234i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4532:1"]
#[derive(Clone, Debug)]
struct instructionVar271 {
    iopr8i: Tableiopr8i,
}
impl instructionVar271 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ORCC"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 20i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4617:1"]
#[derive(Clone, Debug)]
struct instructionVar272 {}
impl instructionVar272 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PSHA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 54i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4622:1"]
#[derive(Clone, Debug)]
struct instructionVar273 {}
impl instructionVar273 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PSHB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 55i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4627:1"]
#[derive(Clone, Debug)]
struct instructionVar274 {}
impl instructionVar274 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PSHC")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 57i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4639:1"]
#[derive(Clone, Debug)]
struct instructionVar275 {}
impl instructionVar275 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PSHD")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 59i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4644:1"]
#[derive(Clone, Debug)]
struct instructionVar276 {}
impl instructionVar276 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PSHX")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 52i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4649:1"]
#[derive(Clone, Debug)]
struct instructionVar277 {}
impl instructionVar277 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PSHY")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 53i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4654:1"]
#[derive(Clone, Debug)]
struct instructionVar278 {}
impl instructionVar278 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PULA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 50i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4659:1"]
#[derive(Clone, Debug)]
struct instructionVar279 {}
impl instructionVar279 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PULB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 51i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4664:1"]
#[derive(Clone, Debug)]
struct instructionVar280 {}
impl instructionVar280 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PULC")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 56i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4676:1"]
#[derive(Clone, Debug)]
struct instructionVar281 {}
impl instructionVar281 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PULD")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 58i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4681:1"]
#[derive(Clone, Debug)]
struct instructionVar282 {}
impl instructionVar282 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PULX")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 48i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4686:1"]
#[derive(Clone, Debug)]
struct instructionVar283 {}
impl instructionVar283 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PULY")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 49i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4691:1"]
#[derive(Clone, Debug)]
struct instructionVar284 {}
impl instructionVar284 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("REV")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 58i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4699:1"]
#[derive(Clone, Debug)]
struct instructionVar285 {}
impl instructionVar285 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("REVW")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 59i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4709:1"]
#[derive(Clone, Debug)]
struct instructionVar286 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar286 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ROL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 117i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4722:1"]
#[derive(Clone, Debug)]
struct instructionVar287 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar287 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ROL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 101i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4735:1"]
#[derive(Clone, Debug)]
struct instructionVar288 {}
impl instructionVar288 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ROLA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 69i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4746:1"]
#[derive(Clone, Debug)]
struct instructionVar289 {}
impl instructionVar289 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ROLB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 85i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4813:1"]
#[derive(Clone, Debug)]
struct instructionVar290 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar290 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ROR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 118i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4826:1"]
#[derive(Clone, Debug)]
struct instructionVar291 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar291 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ROR"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 102i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4839:1"]
#[derive(Clone, Debug)]
struct instructionVar292 {}
impl instructionVar292 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("RORA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 70i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4850:1"]
#[derive(Clone, Debug)]
struct instructionVar293 {}
impl instructionVar293 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("RORB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 86i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4918:1"]
#[derive(Clone, Debug)]
struct instructionVar294 {}
impl instructionVar294 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("RTC")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 10i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4929:1"]
#[derive(Clone, Debug)]
struct instructionVar295 {}
impl instructionVar295 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("RTI")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 11i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4942:1"]
#[derive(Clone, Debug)]
struct instructionVar296 {}
impl instructionVar296 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("RTS")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 61i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4950:1"]
#[derive(Clone, Debug)]
struct instructionVar297 {}
impl instructionVar297 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("SBA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        let mut sub_pattern_c40 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 22i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c40(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4957:1"]
#[derive(Clone, Debug)]
struct instructionVar298 {
    iopr8i: Tableiopr8i,
}
impl instructionVar298 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SBCA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 130i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4966:1"]
#[derive(Clone, Debug)]
struct instructionVar299 {
    opr8a_8: Tableopr8a_8,
}
impl instructionVar299 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SBCA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 146i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4975:1"]
#[derive(Clone, Debug)]
struct instructionVar300 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar300 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SBCA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 178i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4984:1"]
#[derive(Clone, Debug)]
struct instructionVar301 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar301 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SBCA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 162i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:4993:1"]
#[derive(Clone, Debug)]
struct instructionVar302 {
    iopr8i: Tableiopr8i,
}
impl instructionVar302 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SBCB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 194i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5002:1"]
#[derive(Clone, Debug)]
struct instructionVar303 {
    opr8a_8: Tableopr8a_8,
}
impl instructionVar303 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SBCB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 210i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5011:1"]
#[derive(Clone, Debug)]
struct instructionVar304 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar304 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SBCB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 242i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5020:1"]
#[derive(Clone, Debug)]
struct instructionVar305 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar305 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SBCB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 226i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5161:1"]
#[derive(Clone, Debug)]
struct instructionVar306 {}
impl instructionVar306 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("SEC")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 5121i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5166:1"]
#[derive(Clone, Debug)]
struct instructionVar307 {}
impl instructionVar307 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("SEI")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 5136i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5171:1"]
#[derive(Clone, Debug)]
struct instructionVar308 {}
impl instructionVar308 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("SEV")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 5122i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5226:1"]
#[derive(Clone, Debug)]
struct instructionVar309 {
    abc5_4: TokenField_abc5_4,
    dxys2_0: TokenField_dxys2_0,
}
impl instructionVar309 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("SEX"),
            DisplayElement::Literal("  "),
            self.abc5_4.display(),
            DisplayElement::Literal(", "),
            self.dxys2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 183i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 3i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 0i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 1i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 2i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 4i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 0i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 1i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 2i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 5i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 0i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 1i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 2i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 6i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 0i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 1i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 2i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 7i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 0i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 1i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 2i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let abc5_4 = token_parser.TokenFieldabc5_4();
        let dxys2_0 = token_parser.TokenFielddxys2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { abc5_4, dxys2_0 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5239:1"]
#[derive(Clone, Debug)]
struct instructionVar310 {
    GPaged: TableGPaged,
    opr8a_8: Tableopr8a_8,
}
impl instructionVar310 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("STAA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 90i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5248:1"]
#[derive(Clone, Debug)]
struct instructionVar311 {
    GPaged: TableGPaged,
    opr16a_8: Tableopr16a_8,
}
impl instructionVar311 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("STAA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 122i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5257:1"]
#[derive(Clone, Debug)]
struct instructionVar312 {
    GPaged: TableGPaged,
    indexed1_5: Tableindexed1_5,
}
impl instructionVar312 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("STAA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c57 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 106i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c57(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5266:1"]
#[derive(Clone, Debug)]
struct instructionVar313 {
    GPaged: TableGPaged,
    opr8a_8: Tableopr8a_8,
}
impl instructionVar313 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("STAB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 91i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5275:1"]
#[derive(Clone, Debug)]
struct instructionVar314 {
    GPaged: TableGPaged,
    opr16a_8: Tableopr16a_8,
}
impl instructionVar314 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("STAB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 123i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5284:1"]
#[derive(Clone, Debug)]
struct instructionVar315 {
    GPaged: TableGPaged,
    indexed1_5: Tableindexed1_5,
}
impl instructionVar315 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("STAB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c57 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 107i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c57(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5293:1"]
#[derive(Clone, Debug)]
struct instructionVar316 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar316 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 92i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5302:1"]
#[derive(Clone, Debug)]
struct instructionVar317 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar317 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 124i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5311:1"]
#[derive(Clone, Debug)]
struct instructionVar318 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar318 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STD"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c56 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 108i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c56(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5320:1"]
#[derive(Clone, Debug)]
struct instructionVar319 {}
impl instructionVar319 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("STOP")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 62i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5334:1"]
#[derive(Clone, Debug)]
struct instructionVar320 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar320 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 95i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5343:1"]
#[derive(Clone, Debug)]
struct instructionVar321 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar321 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 127i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5352:1"]
#[derive(Clone, Debug)]
struct instructionVar322 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar322 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STS"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c56 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 111i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c56(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5361:1"]
#[derive(Clone, Debug)]
struct instructionVar323 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar323 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STX"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 94i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5370:1"]
#[derive(Clone, Debug)]
struct instructionVar324 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar324 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STX"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 126i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5379:1"]
#[derive(Clone, Debug)]
struct instructionVar325 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar325 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STX"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c56 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 110i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c56(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5388:1"]
#[derive(Clone, Debug)]
struct instructionVar326 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar326 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STY"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 93i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5397:1"]
#[derive(Clone, Debug)]
struct instructionVar327 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar327 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STY"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 125i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5406:1"]
#[derive(Clone, Debug)]
struct instructionVar328 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar328 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.GPaged.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STY"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let tmp = context_instance.register().read_Prefix18_disassembly();
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        let GPaged = if let Some((len, table)) = TableGPaged::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c56 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 109i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c56(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5415:1"]
#[derive(Clone, Debug)]
struct instructionVar329 {
    iopr8i: Tableiopr8i,
}
impl instructionVar329 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 128i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5424:1"]
#[derive(Clone, Debug)]
struct instructionVar330 {
    opr8a_8: Tableopr8a_8,
}
impl instructionVar330 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 144i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5433:1"]
#[derive(Clone, Debug)]
struct instructionVar331 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar331 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 176i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5442:1"]
#[derive(Clone, Debug)]
struct instructionVar332 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar332 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 160i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5451:1"]
#[derive(Clone, Debug)]
struct instructionVar333 {
    iopr8i: Tableiopr8i,
}
impl instructionVar333 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr8i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 192i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr8i = if let Some((len, table)) = Tableiopr8i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5460:1"]
#[derive(Clone, Debug)]
struct instructionVar334 {
    opr8a_8: Tableopr8a_8,
}
impl instructionVar334 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 208i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_8 = if let Some((len, table)) = Tableopr8a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5469:1"]
#[derive(Clone, Debug)]
struct instructionVar335 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar335 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 240i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5478:1"]
#[derive(Clone, Debug)]
struct instructionVar336 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar336 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBB"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 224i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5487:1"]
#[derive(Clone, Debug)]
struct instructionVar337 {
    iopr16i: Tableiopr16i,
}
impl instructionVar337 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBD"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.iopr16i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 131i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let iopr16i = if let Some((len, table)) = Tableiopr16i::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5496:1"]
#[derive(Clone, Debug)]
struct instructionVar338 {
    opr8a_16: Tableopr8a_16,
}
impl instructionVar338 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBD"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 147i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr8a_16 = if let Some((len, table)) = Tableopr8a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5505:1"]
#[derive(Clone, Debug)]
struct instructionVar339 {
    opr16a_16: Tableopr16a_16,
}
impl instructionVar339 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBD"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 179i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5514:1"]
#[derive(Clone, Debug)]
struct instructionVar340 {
    indexed2_5: Tableindexed2_5,
}
impl instructionVar340 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBD"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 163i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed2_5 = if let Some((len, table)) = Tableindexed2_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5611:1"]
#[derive(Clone, Debug)]
struct instructionVar341 {}
impl instructionVar341 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("SWI")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 63i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5627:1"]
#[derive(Clone, Debug)]
struct instructionVar342 {}
impl instructionVar342 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("TAB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 14i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5635:1"]
#[derive(Clone, Debug)]
struct instructionVar343 {}
impl instructionVar343 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("TAP")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 46850i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5640:1"]
#[derive(Clone, Debug)]
struct instructionVar344 {}
impl instructionVar344 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("TBA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 15i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5648:1"]
#[derive(Clone, Debug)]
struct instructionVar345 {
    byte9_8: TokenField_byte9_8,
    rel9: Tablerel9,
}
impl instructionVar345 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("TBEQ"),
            DisplayElement::Literal(" "),
            self.byte9_8.display(),
            DisplayElement::Literal(", "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 0i64 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let byte9_8 = token_parser.TokenFieldbyte9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, byte9_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5653:1"]
#[derive(Clone, Debug)]
struct instructionVar346 {
    word9_8: TokenField_word9_8,
    rel9: Tablerel9,
}
impl instructionVar346 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("TBEQ"),
            DisplayElement::Literal(" "),
            self.word9_8.display(),
            DisplayElement::Literal(", "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 1i64 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let word9_8 = token_parser.TokenFieldword9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, word9_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5658:1"]
#[derive(Clone, Debug)]
struct instructionVar347 {
    indexed1_3: Tableindexed1_3,
}
impl instructionVar347 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("TBL"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 61i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_3 = if let Some((len, table)) = Tableindexed1_3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5668:1"]
#[derive(Clone, Debug)]
struct instructionVar348 {
    byte9_8: TokenField_byte9_8,
    rel9: Tablerel9,
}
impl instructionVar348 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("TBNE"),
            DisplayElement::Literal(" "),
            self.byte9_8.display(),
            DisplayElement::Literal(", "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 0i64 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let byte9_8 = token_parser.TokenFieldbyte9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, byte9_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5673:1"]
#[derive(Clone, Debug)]
struct instructionVar349 {
    word9_8: TokenField_word9_8,
    rel9: Tablerel9,
}
impl instructionVar349 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("TBNE"),
            DisplayElement::Literal(" "),
            self.word9_8.display(),
            DisplayElement::Literal(", "),
        ];
        display.extend_from_slice(&extend);
        self.rel9.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 4i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldop15_13().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldsize10_10().disassembly() != 1i64 {
            return None;
        }
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let word9_8 = token_parser.TokenFieldword9_8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, word9_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5678:1"]
#[derive(Clone, Debug)]
struct instructionVar350 {
    bytes_ABClT3lBXlYlSl_6_4: TokenField_bytes_ABClT3lBXlYlSl_6_4,
    bytes_ABCl_2_0: TokenField_bytes_ABCl_2_0,
}
impl instructionVar350 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("TFR"),
            DisplayElement::Literal(" "),
            self.bytes_ABClT3lBXlYlSl_6_4.display(),
            DisplayElement::Literal(", "),
            self.bytes_ABCl_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c65 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c65(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 0i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 0i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 1i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 1i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 0i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 1i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 2i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 8i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 0i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 1i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 9i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 0i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 1i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 2i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABClT3lBXlYlSl_6_4 =
            token_parser.TokenFieldbytes_ABClT3lBXlYlSl_6_4();
        let bytes_ABCl_2_0 = token_parser.TokenFieldbytes_ABCl_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_ABClT3lBXlYlSl_6_4,
                bytes_ABCl_2_0,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5692:1"]
#[derive(Clone, Debug)]
struct instructionVar351 {
    bytes_ABClT3lBXlYlSl_6_4: TokenField_bytes_ABClT3lBXlYlSl_6_4,
}
impl instructionVar351 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("TFR"),
            DisplayElement::Literal(" "),
            self.bytes_ABClT3lBXlYlSl_6_4.display(),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::CCR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 2i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c38 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 1i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 2i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c38(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 10i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c38 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 1i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c38(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABClT3lBXlYlSl_6_4 =
            token_parser.TokenFieldbytes_ABClT3lBXlYlSl_6_4();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_ABClT3lBXlYlSl_6_4,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5704:1"]
#[derive(Clone, Debug)]
struct instructionVar352 {
    bytes_ABChT3hBXhYhSh_6_4: TokenField_bytes_ABChT3hBXhYhSh_6_4,
}
impl instructionVar352 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("TFR"),
            DisplayElement::Literal(" "),
            self.bytes_ABChT3hBXhYhSh_6_4.display(),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c52 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c52(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c5 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 8i64 {
                    return None;
                }
                let mut sub_pattern_c55 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 =
                            |tokens_param: &[u8], context_param: &mut T| {
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 2i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 3i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 5i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 6i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 7i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                None
                            };
                        let ((), (), block_0_len) =
                            block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c55(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c5(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABChT3hBXhYhSh_6_4 =
            token_parser.TokenFieldbytes_ABChT3hBXhYhSh_6_4();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_ABChT3hBXhYhSh_6_4,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5713:1"]
#[derive(Clone, Debug)]
struct instructionVar353 {}
impl instructionVar353 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("TFR"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::A),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::CCRH),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c32 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c32(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c5 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 10i64 {
                    return None;
                }
                let mut sub_pattern_c21 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldcolumns7_4().disassembly()
                            != 0i64
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c21(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c5(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5722:1"]
#[derive(Clone, Debug)]
struct instructionVar354 {
    words_CT3DXYS_6_4: TokenField_words_CT3DXYS_6_4,
}
impl instructionVar354 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("TFR"),
            DisplayElement::Literal(" "),
            self.words_CT3DXYS_6_4.display(),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::CCRW),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c5 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 10i64 {
                    return None;
                }
                let mut sub_pattern_c55 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 =
                            |tokens_param: &[u8], context_param: &mut T| {
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 2i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 3i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 4i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 5i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 6i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens_param)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    == 7i64
                                {
                                    return Some((
                                        (),
                                        (),
                                        u32::try_from(1u64).unwrap(),
                                    ));
                                }
                                None
                            };
                        let ((), (), block_0_len) =
                            block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c55(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c5(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let words_CT3DXYS_6_4 = token_parser.TokenFieldwords_CT3DXYS_6_4();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { words_CT3DXYS_6_4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5731:1"]
#[derive(Clone, Debug)]
struct instructionVar355 {
    words_T3DXYS_6_4: TokenField_words_T3DXYS_6_4,
    words_T2DXYS_2_0: TokenField_words_T2DXYS_2_0,
}
impl instructionVar355 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("TFR"),
            DisplayElement::Literal(" "),
            self.words_T3DXYS_6_4.display(),
            DisplayElement::Literal(", "),
            self.words_T2DXYS_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c59 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c59(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 3i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c72 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c72(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 4i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c72 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c72(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 5i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c72 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c72(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 6i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c72 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c72(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 7i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c72 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c72(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 11i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c72 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c72(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 12i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c89 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c89(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 13i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c72 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c72(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 14i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c72 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c72(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 15i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c72 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let block_0 = | tokens_param : & [u8] , context_param : & mut T | { let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 3i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 4i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 5i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 6i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } let token_parser = < TokenParser < 1usize >> :: new (tokens_param) ? ; if token_parser . TokenFieldcolumns7_4 () . disassembly () == 7i64 { return Some ((() , () , u32 :: try_from (1u64) . unwrap () ,)) ; } None } ;
                                let ((), (), block_0_len) =
                                    block_0(tokens, &mut context_instance)?;
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c72(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let words_T3DXYS_6_4 = token_parser.TokenFieldwords_T3DXYS_6_4();
        let words_T2DXYS_2_0 = token_parser.TokenFieldwords_T2DXYS_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                words_T3DXYS_6_4,
                words_T2DXYS_2_0,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5754:1"]
#[derive(Clone, Debug)]
struct instructionVar356 {}
impl instructionVar356 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("TFR"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::D),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::TMP1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c32 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c32(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c5 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 11i64 {
                    return None;
                }
                let mut sub_pattern_c89 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldcolumns7_4().disassembly()
                            != 4i64
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c89(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c5(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5763:1"]
#[derive(Clone, Debug)]
struct instructionVar357 {}
impl instructionVar357 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("TFR"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::TMP1),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::D),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c32 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c32(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 0u64 as u32;
            let mut sub_pattern_c5 = |tokens: &[u8], context_param: &mut T| {
                let mut pattern_len = 0 as u32;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1u64 as u32;
                let token_parser = <TokenParser<1usize>>::new(tokens)?;
                if token_parser.TokenFieldrows3_0().disassembly() != 12i64 {
                    return None;
                }
                let mut sub_pattern_c72 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldcolumns7_4().disassembly()
                            != 3i64
                        {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let ((), (), sub_len) =
                    sub_pattern_c72(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c5(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5772:1"]
#[derive(Clone, Debug)]
struct instructionVar358 {
    words_T2DXYS_2_0: TokenField_words_T2DXYS_2_0,
}
impl instructionVar358 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("TFR"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::CCRW),
            DisplayElement::Literal(", "),
            self.words_T2DXYS_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 11i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c55 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 2i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c55(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 12i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c55 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 2i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c55(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 13i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c55 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 2i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c55(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 14i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c55 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 2i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c55(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 15i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c55 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 2i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c55(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let words_T2DXYS_2_0 = token_parser.TokenFieldwords_T2DXYS_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { words_T2DXYS_2_0 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5785:1"]
#[derive(Clone, Debug)]
struct instructionVar359 {
    bytes_T2h_XhYhSh_2_0: TokenField_bytes_T2h_XhYhSh_2_0,
}
impl instructionVar359 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("TFR"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::A),
            DisplayElement::Literal(", "),
            self.bytes_T2h_XhYhSh_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 11i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 0i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 13i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 0i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 14i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 0i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 15i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c21 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 0i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c21(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_T2h_XhYhSh_2_0 =
            token_parser.TokenFieldbytes_T2h_XhYhSh_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_T2h_XhYhSh_2_0,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5798:1"]
#[derive(Clone, Debug)]
struct instructionVar360 {
    bytes_T2l_XlYlSl_2_0: TokenField_bytes_T2l_XlYlSl_2_0,
}
impl instructionVar360 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("TFR"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::A),
            DisplayElement::Literal(", "),
            self.bytes_T2l_XlYlSl_2_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 183i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 11i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c38 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 1i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c38(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 13i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c38 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 1i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c38(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 14i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c38 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 1i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c38(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c5 =
                    |tokens: &[u8], context_param: &mut T| {
                        let mut pattern_len = 0 as u32;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1u64 as u32;
                        let token_parser = <TokenParser<1usize>>::new(tokens)?;
                        if token_parser.TokenFieldrows3_0().disassembly()
                            != 15i64
                        {
                            return None;
                        }
                        let mut sub_pattern_c38 =
                            |tokens: &[u8], context_param: &mut T| {
                                let mut pattern_len = 0 as u32;
                                let mut context_instance =
                                    context_param.clone();
                                let mut tokens = tokens;
                                let mut block_0_len = 1u64 as u32;
                                let token_parser =
                                    <TokenParser<1usize>>::new(tokens)?;
                                if token_parser
                                    .TokenFieldcolumns7_4()
                                    .disassembly()
                                    != 1i64
                                {
                                    return None;
                                }
                                pattern_len += block_0_len;
                                tokens = &tokens
                                    [usize::try_from(block_0_len).unwrap()..];
                                *context_param = context_instance;
                                Some(((), (), pattern_len))
                            };
                        let ((), (), sub_len) =
                            sub_pattern_c38(tokens, &mut context_instance)?;
                        block_0_len = block_0_len.max(sub_len);
                        pattern_len += block_0_len;
                        tokens =
                            &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c5(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_T2l_XlYlSl_2_0 =
            token_parser.TokenFieldbytes_T2l_XlYlSl_2_0();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_T2l_XlYlSl_2_0,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5811:1"]
#[derive(Clone, Debug)]
struct instructionVar361 {}
impl instructionVar361 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("TPA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 46880i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5817:1"]
#[derive(Clone, Debug)]
struct instructionVar362 {
    trapnum: TokenField_trapnum,
}
impl instructionVar362 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("TRAP"),
            DisplayElement::Literal(" "),
            self.trapnum.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 48i64 {
            return None;
        }
        let trapnum = token_parser.TokenFieldtrapnum();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { trapnum }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5833:1"]
#[derive(Clone, Debug)]
struct instructionVar363 {
    opr16a_8: Tableopr16a_8,
}
impl instructionVar363 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("TST"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 247i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5842:1"]
#[derive(Clone, Debug)]
struct instructionVar364 {
    indexed1_5: Tableindexed1_5,
}
impl instructionVar364 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("TST"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldop8().disassembly() != 231i64 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let indexed1_5 = if let Some((len, table)) = Tableindexed1_5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5851:1"]
#[derive(Clone, Debug)]
struct instructionVar365 {}
impl instructionVar365 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("TSTA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 151i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5858:1"]
#[derive(Clone, Debug)]
struct instructionVar366 {}
impl instructionVar366 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("TSTB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 215i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5888:1"]
#[derive(Clone, Debug)]
struct instructionVar367 {}
impl instructionVar367 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("TSTX")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 151i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5896:1"]
#[derive(Clone, Debug)]
struct instructionVar368 {}
impl instructionVar368 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("TSTY")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 215i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5903:1"]
#[derive(Clone, Debug)]
struct instructionVar369 {}
impl instructionVar369 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("TSX")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 46965i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5908:1"]
#[derive(Clone, Debug)]
struct instructionVar370 {}
impl instructionVar370 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("TSY")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 46966i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5913:1"]
#[derive(Clone, Debug)]
struct instructionVar371 {}
impl instructionVar371 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("TXS")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 46935i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5918:1"]
#[derive(Clone, Debug)]
struct instructionVar372 {}
impl instructionVar372 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("TYS")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 46951i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5923:1"]
#[derive(Clone, Debug)]
struct instructionVar373 {}
impl instructionVar373 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("WAI")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 62i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5936:1"]
#[derive(Clone, Debug)]
struct instructionVar374 {}
impl instructionVar374 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("WAV")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 60i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5949:1"]
#[derive(Clone, Debug)]
struct instructionVar375 {}
impl instructionVar375 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("WAVR")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop8().disassembly() != 60i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5954:1"]
#[derive(Clone, Debug)]
struct instructionVar376 {}
impl instructionVar376 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("XGDX")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 47045i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:5961:1"]
#[derive(Clone, Debug)]
struct instructionVar377 {}
impl instructionVar377 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("XGDY")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldop16().disassembly() != 47046i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tableinstruction {
    Var0(instructionVar0),
    Var1(instructionVar1),
    Var2(instructionVar2),
    Var3(instructionVar3),
    Var4(instructionVar4),
    Var5(instructionVar5),
    Var6(instructionVar6),
    Var7(instructionVar7),
    Var8(instructionVar8),
    Var9(instructionVar9),
    Var10(instructionVar10),
    Var11(instructionVar11),
    Var12(instructionVar12),
    Var13(instructionVar13),
    Var14(instructionVar14),
    Var15(instructionVar15),
    Var16(instructionVar16),
    Var17(instructionVar17),
    Var18(instructionVar18),
    Var19(instructionVar19),
    Var20(instructionVar20),
    Var21(instructionVar21),
    Var22(instructionVar22),
    Var23(instructionVar23),
    Var24(instructionVar24),
    Var25(instructionVar25),
    Var26(instructionVar26),
    Var27(instructionVar27),
    Var28(instructionVar28),
    Var29(instructionVar29),
    Var30(instructionVar30),
    Var31(instructionVar31),
    Var32(instructionVar32),
    Var33(instructionVar33),
    Var34(instructionVar34),
    Var35(instructionVar35),
    Var36(instructionVar36),
    Var37(instructionVar37),
    Var38(instructionVar38),
    Var39(instructionVar39),
    Var40(instructionVar40),
    Var41(instructionVar41),
    Var42(instructionVar42),
    Var43(instructionVar43),
    Var44(instructionVar44),
    Var45(instructionVar45),
    Var46(instructionVar46),
    Var47(instructionVar47),
    Var48(instructionVar48),
    Var49(instructionVar49),
    Var50(instructionVar50),
    Var51(instructionVar51),
    Var52(instructionVar52),
    Var53(instructionVar53),
    Var54(instructionVar54),
    Var55(instructionVar55),
    Var56(instructionVar56),
    Var57(instructionVar57),
    Var58(instructionVar58),
    Var59(instructionVar59),
    Var60(instructionVar60),
    Var61(instructionVar61),
    Var62(instructionVar62),
    Var63(instructionVar63),
    Var64(instructionVar64),
    Var65(instructionVar65),
    Var66(instructionVar66),
    Var67(instructionVar67),
    Var68(instructionVar68),
    Var69(instructionVar69),
    Var70(instructionVar70),
    Var71(instructionVar71),
    Var72(instructionVar72),
    Var73(instructionVar73),
    Var74(instructionVar74),
    Var75(instructionVar75),
    Var76(instructionVar76),
    Var77(instructionVar77),
    Var78(instructionVar78),
    Var79(instructionVar79),
    Var80(instructionVar80),
    Var81(instructionVar81),
    Var82(instructionVar82),
    Var83(instructionVar83),
    Var84(instructionVar84),
    Var85(instructionVar85),
    Var86(instructionVar86),
    Var87(instructionVar87),
    Var88(instructionVar88),
    Var89(instructionVar89),
    Var90(instructionVar90),
    Var91(instructionVar91),
    Var92(instructionVar92),
    Var93(instructionVar93),
    Var94(instructionVar94),
    Var95(instructionVar95),
    Var96(instructionVar96),
    Var97(instructionVar97),
    Var98(instructionVar98),
    Var99(instructionVar99),
    Var100(instructionVar100),
    Var101(instructionVar101),
    Var102(instructionVar102),
    Var103(instructionVar103),
    Var104(instructionVar104),
    Var105(instructionVar105),
    Var106(instructionVar106),
    Var107(instructionVar107),
    Var108(instructionVar108),
    Var109(instructionVar109),
    Var110(instructionVar110),
    Var111(instructionVar111),
    Var112(instructionVar112),
    Var113(instructionVar113),
    Var114(instructionVar114),
    Var115(instructionVar115),
    Var116(instructionVar116),
    Var117(instructionVar117),
    Var118(instructionVar118),
    Var119(instructionVar119),
    Var120(instructionVar120),
    Var121(instructionVar121),
    Var122(instructionVar122),
    Var123(instructionVar123),
    Var124(instructionVar124),
    Var125(instructionVar125),
    Var126(instructionVar126),
    Var127(instructionVar127),
    Var128(instructionVar128),
    Var129(instructionVar129),
    Var130(instructionVar130),
    Var131(instructionVar131),
    Var132(instructionVar132),
    Var133(instructionVar133),
    Var134(instructionVar134),
    Var135(instructionVar135),
    Var136(instructionVar136),
    Var137(instructionVar137),
    Var138(instructionVar138),
    Var139(instructionVar139),
    Var140(instructionVar140),
    Var141(instructionVar141),
    Var142(instructionVar142),
    Var143(instructionVar143),
    Var144(instructionVar144),
    Var145(instructionVar145),
    Var146(instructionVar146),
    Var147(instructionVar147),
    Var148(instructionVar148),
    Var149(instructionVar149),
    Var150(instructionVar150),
    Var151(instructionVar151),
    Var152(instructionVar152),
    Var153(instructionVar153),
    Var154(instructionVar154),
    Var155(instructionVar155),
    Var156(instructionVar156),
    Var157(instructionVar157),
    Var158(instructionVar158),
    Var159(instructionVar159),
    Var160(instructionVar160),
    Var161(instructionVar161),
    Var162(instructionVar162),
    Var163(instructionVar163),
    Var164(instructionVar164),
    Var165(instructionVar165),
    Var166(instructionVar166),
    Var167(instructionVar167),
    Var168(instructionVar168),
    Var169(instructionVar169),
    Var170(instructionVar170),
    Var171(instructionVar171),
    Var172(instructionVar172),
    Var173(instructionVar173),
    Var174(instructionVar174),
    Var175(instructionVar175),
    Var176(instructionVar176),
    Var177(instructionVar177),
    Var178(instructionVar178),
    Var179(instructionVar179),
    Var180(instructionVar180),
    Var181(instructionVar181),
    Var182(instructionVar182),
    Var183(instructionVar183),
    Var184(instructionVar184),
    Var185(instructionVar185),
    Var186(instructionVar186),
    Var187(instructionVar187),
    Var188(instructionVar188),
    Var189(instructionVar189),
    Var190(instructionVar190),
    Var191(instructionVar191),
    Var192(instructionVar192),
    Var193(instructionVar193),
    Var194(instructionVar194),
    Var195(instructionVar195),
    Var196(instructionVar196),
    Var197(instructionVar197),
    Var198(instructionVar198),
    Var199(instructionVar199),
    Var200(instructionVar200),
    Var201(instructionVar201),
    Var202(instructionVar202),
    Var203(instructionVar203),
    Var204(instructionVar204),
    Var205(instructionVar205),
    Var206(instructionVar206),
    Var207(instructionVar207),
    Var208(instructionVar208),
    Var209(instructionVar209),
    Var210(instructionVar210),
    Var211(instructionVar211),
    Var212(instructionVar212),
    Var213(instructionVar213),
    Var214(instructionVar214),
    Var215(instructionVar215),
    Var216(instructionVar216),
    Var217(instructionVar217),
    Var218(instructionVar218),
    Var219(instructionVar219),
    Var220(instructionVar220),
    Var221(instructionVar221),
    Var222(instructionVar222),
    Var223(instructionVar223),
    Var224(instructionVar224),
    Var225(instructionVar225),
    Var226(instructionVar226),
    Var227(instructionVar227),
    Var228(instructionVar228),
    Var229(instructionVar229),
    Var230(instructionVar230),
    Var231(instructionVar231),
    Var232(instructionVar232),
    Var233(instructionVar233),
    Var234(instructionVar234),
    Var235(instructionVar235),
    Var236(instructionVar236),
    Var237(instructionVar237),
    Var238(instructionVar238),
    Var239(instructionVar239),
    Var240(instructionVar240),
    Var241(instructionVar241),
    Var242(instructionVar242),
    Var243(instructionVar243),
    Var244(instructionVar244),
    Var245(instructionVar245),
    Var246(instructionVar246),
    Var247(instructionVar247),
    Var248(instructionVar248),
    Var249(instructionVar249),
    Var250(instructionVar250),
    Var251(instructionVar251),
    Var252(instructionVar252),
    Var253(instructionVar253),
    Var254(instructionVar254),
    Var255(instructionVar255),
    Var256(instructionVar256),
    Var257(instructionVar257),
    Var258(instructionVar258),
    Var259(instructionVar259),
    Var260(instructionVar260),
    Var261(instructionVar261),
    Var262(instructionVar262),
    Var263(instructionVar263),
    Var264(instructionVar264),
    Var265(instructionVar265),
    Var266(instructionVar266),
    Var267(instructionVar267),
    Var268(instructionVar268),
    Var269(instructionVar269),
    Var270(instructionVar270),
    Var271(instructionVar271),
    Var272(instructionVar272),
    Var273(instructionVar273),
    Var274(instructionVar274),
    Var275(instructionVar275),
    Var276(instructionVar276),
    Var277(instructionVar277),
    Var278(instructionVar278),
    Var279(instructionVar279),
    Var280(instructionVar280),
    Var281(instructionVar281),
    Var282(instructionVar282),
    Var283(instructionVar283),
    Var284(instructionVar284),
    Var285(instructionVar285),
    Var286(instructionVar286),
    Var287(instructionVar287),
    Var288(instructionVar288),
    Var289(instructionVar289),
    Var290(instructionVar290),
    Var291(instructionVar291),
    Var292(instructionVar292),
    Var293(instructionVar293),
    Var294(instructionVar294),
    Var295(instructionVar295),
    Var296(instructionVar296),
    Var297(instructionVar297),
    Var298(instructionVar298),
    Var299(instructionVar299),
    Var300(instructionVar300),
    Var301(instructionVar301),
    Var302(instructionVar302),
    Var303(instructionVar303),
    Var304(instructionVar304),
    Var305(instructionVar305),
    Var306(instructionVar306),
    Var307(instructionVar307),
    Var308(instructionVar308),
    Var309(instructionVar309),
    Var310(instructionVar310),
    Var311(instructionVar311),
    Var312(instructionVar312),
    Var313(instructionVar313),
    Var314(instructionVar314),
    Var315(instructionVar315),
    Var316(instructionVar316),
    Var317(instructionVar317),
    Var318(instructionVar318),
    Var319(instructionVar319),
    Var320(instructionVar320),
    Var321(instructionVar321),
    Var322(instructionVar322),
    Var323(instructionVar323),
    Var324(instructionVar324),
    Var325(instructionVar325),
    Var326(instructionVar326),
    Var327(instructionVar327),
    Var328(instructionVar328),
    Var329(instructionVar329),
    Var330(instructionVar330),
    Var331(instructionVar331),
    Var332(instructionVar332),
    Var333(instructionVar333),
    Var334(instructionVar334),
    Var335(instructionVar335),
    Var336(instructionVar336),
    Var337(instructionVar337),
    Var338(instructionVar338),
    Var339(instructionVar339),
    Var340(instructionVar340),
    Var341(instructionVar341),
    Var342(instructionVar342),
    Var343(instructionVar343),
    Var344(instructionVar344),
    Var345(instructionVar345),
    Var346(instructionVar346),
    Var347(instructionVar347),
    Var348(instructionVar348),
    Var349(instructionVar349),
    Var350(instructionVar350),
    Var351(instructionVar351),
    Var352(instructionVar352),
    Var353(instructionVar353),
    Var354(instructionVar354),
    Var355(instructionVar355),
    Var356(instructionVar356),
    Var357(instructionVar357),
    Var358(instructionVar358),
    Var359(instructionVar359),
    Var360(instructionVar360),
    Var361(instructionVar361),
    Var362(instructionVar362),
    Var363(instructionVar363),
    Var364(instructionVar364),
    Var365(instructionVar365),
    Var366(instructionVar366),
    Var367(instructionVar367),
    Var368(instructionVar368),
    Var369(instructionVar369),
    Var370(instructionVar370),
    Var371(instructionVar371),
    Var372(instructionVar372),
    Var373(instructionVar373),
    Var374(instructionVar374),
    Var375(instructionVar375),
    Var376(instructionVar376),
    Var377(instructionVar377),
}
impl Tableinstruction {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var18(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var19(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var20(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var21(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var22(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var23(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var24(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var25(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var26(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var27(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var28(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var29(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var30(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var31(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var32(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var33(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var34(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var35(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var36(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var37(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var38(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var39(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var40(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var41(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var42(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var43(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var44(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var45(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var46(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var47(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var48(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var49(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var50(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var51(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var52(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var53(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var54(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var55(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var56(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var57(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var58(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var59(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var60(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var61(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var62(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var63(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var64(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var65(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var66(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var67(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var68(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var69(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var70(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var71(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var72(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var73(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var74(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var75(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var76(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var77(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var78(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var79(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var80(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var81(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var82(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var83(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var84(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var85(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var86(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var87(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var88(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var89(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var90(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var91(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var92(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var93(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var94(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var95(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var96(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var97(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var98(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var99(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var100(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var101(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var102(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var103(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var104(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var105(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var106(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var107(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var108(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var109(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var110(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var111(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var112(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var113(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var114(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var115(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var116(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var117(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var118(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var119(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var120(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var121(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var122(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var123(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var124(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var125(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var126(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var127(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var128(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var129(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var130(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var131(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var132(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var133(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var134(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var135(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var136(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var137(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var138(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var139(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var140(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var141(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var142(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var143(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var144(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var145(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var146(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var147(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var148(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var149(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var150(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var151(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var152(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var153(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var154(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var155(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var156(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var157(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var158(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var159(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var160(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var161(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var162(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var163(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var164(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var165(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var166(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var167(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var168(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var169(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var170(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var171(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var172(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var173(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var174(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var175(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var176(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var177(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var178(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var179(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var180(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var181(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var182(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var183(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var184(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var185(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var186(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var187(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var188(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var189(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var190(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var191(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var192(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var193(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var194(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var195(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var196(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var197(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var198(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var199(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var200(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var201(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var202(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var203(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var204(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var205(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var206(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var207(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var208(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var209(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var210(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var211(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var212(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var213(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var214(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var215(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var216(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var217(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var218(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var219(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var220(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var221(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var222(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var223(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var224(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var225(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var226(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var227(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var228(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var229(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var230(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var231(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var232(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var233(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var234(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var235(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var236(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var237(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var238(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var239(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var240(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var241(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var242(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var243(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var244(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var245(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var246(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var247(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var248(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var249(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var250(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var251(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var252(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var253(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var254(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var255(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var256(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var257(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var258(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var259(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var260(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var261(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var262(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var263(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var264(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var265(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var266(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var267(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var268(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var269(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var270(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var271(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var272(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var273(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var274(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var275(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var276(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var277(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var278(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var279(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var280(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var281(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var282(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var283(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var284(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var285(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var286(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var287(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var288(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var289(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var290(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var291(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var292(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var293(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var294(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var295(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var296(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var297(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var298(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var299(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var300(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var301(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var302(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var303(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var304(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var305(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var306(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var307(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var308(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var309(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var310(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var311(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var312(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var313(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var314(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var315(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var316(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var317(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var318(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var319(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var320(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var321(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var322(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var323(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var324(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var325(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var326(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var327(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var328(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var329(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var330(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var331(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var332(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var333(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var334(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var335(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var336(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var337(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var338(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var339(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var340(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var341(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var342(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var343(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var344(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var345(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var346(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var347(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var348(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var349(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var350(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var351(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var352(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var353(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var354(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var355(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var356(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var357(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var358(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var359(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var360(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var361(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var362(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var363(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var364(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var365(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var366(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var367(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var368(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var369(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var370(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var371(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var372(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var373(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var374(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var375(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var376(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var377(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = instructionVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar8::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar9::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar10::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar11::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar12::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar13::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar14::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar15::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar16::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var16(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar17::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var17(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar18::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var18(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar19::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var19(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar20::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var20(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar21::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var21(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar22::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var22(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar23::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var23(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar24::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var24(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar25::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var25(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar26::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var26(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar27::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var27(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar28::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var28(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar29::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var29(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar30::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var30(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar31::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var31(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar32::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var32(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar33::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var33(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar34::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var34(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar35::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var35(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar36::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var36(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar37::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var37(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar38::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var38(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar39::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var39(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar40::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var40(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar41::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var41(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar42::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var42(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar43::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var43(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar44::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var44(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar45::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var45(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar46::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var46(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar47::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var47(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar48::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var48(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar49::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var49(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar50::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var50(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar51::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var51(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar52::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var52(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar53::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var53(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar54::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var54(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar55::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var55(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar56::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var56(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar57::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var57(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar58::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var58(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar59::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var59(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar60::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var60(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar61::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var61(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar62::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var62(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar63::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var63(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar64::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var64(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar65::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var65(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar66::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var66(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar67::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var67(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar68::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var68(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar69::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var69(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar70::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var70(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar71::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var71(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar72::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var72(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar73::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var73(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar74::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var74(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar75::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var75(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar76::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var76(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar77::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var77(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar78::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var78(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar79::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var79(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar80::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var80(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar81::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var81(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar82::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var82(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar83::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var83(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar84::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var84(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar85::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var85(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar86::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var86(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar87::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var87(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar88::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var88(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar89::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var89(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar90::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var90(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar91::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var91(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar92::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var92(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar93::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var93(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar94::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var94(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar95::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var95(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar96::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var96(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar97::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var97(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar98::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var98(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar99::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var99(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar100::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var100(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar101::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var101(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar102::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var102(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar103::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var103(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar104::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var104(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar105::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var105(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar106::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var106(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar107::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var107(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar108::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var108(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar109::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var109(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar110::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var110(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar111::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var111(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar112::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var112(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar113::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var113(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar114::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var114(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar115::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var115(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar116::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var116(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar117::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var117(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar118::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var118(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar119::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var119(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar120::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var120(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar121::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var121(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar122::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var122(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar123::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var123(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar124::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var124(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar125::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var125(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar126::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var126(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar127::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var127(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar128::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var128(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar129::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var129(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar130::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var130(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar131::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var131(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar132::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var132(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar133::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var133(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar134::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var134(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar135::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var135(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar136::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var136(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar137::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var137(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar138::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var138(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar139::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var139(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar140::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var140(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar141::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var141(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar142::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var142(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar143::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var143(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar144::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var144(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar145::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var145(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar146::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var146(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar147::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var147(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar148::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var148(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar149::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var149(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar150::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var150(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar151::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var151(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar152::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var152(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar153::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var153(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar154::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var154(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar155::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var155(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar156::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var156(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar157::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var157(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar158::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var158(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar159::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var159(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar160::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var160(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar161::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var161(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar162::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var162(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar163::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var163(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar164::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var164(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar165::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var165(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar166::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var166(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar167::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var167(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar168::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var168(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar169::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var169(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar170::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var170(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar171::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var171(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar172::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var172(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar173::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var173(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar174::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var174(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar175::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var175(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar176::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var176(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar177::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var177(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar178::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var178(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar179::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var179(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar180::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var180(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar181::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var181(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar182::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var182(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar183::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var183(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar184::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var184(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar185::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var185(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar186::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var186(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar187::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var187(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar188::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var188(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar189::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var189(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar190::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var190(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar191::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var191(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar192::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var192(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar193::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var193(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar194::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var194(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar195::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var195(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar196::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var196(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar197::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var197(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar198::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var198(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar199::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var199(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar200::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var200(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar201::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var201(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar202::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var202(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar203::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var203(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar204::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var204(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar205::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var205(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar206::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var206(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar207::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var207(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar208::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var208(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar209::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var209(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar210::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var210(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar211::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var211(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar212::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var212(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar213::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var213(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar214::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var214(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar215::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var215(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar216::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var216(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar217::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var217(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar218::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var218(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar219::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var219(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar220::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var220(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar221::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var221(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar222::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var222(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar223::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var223(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar224::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var224(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar225::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var225(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar226::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var226(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar227::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var227(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar228::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var228(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar229::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var229(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar230::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var230(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar231::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var231(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar232::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var232(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar233::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var233(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar234::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var234(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar235::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var235(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar236::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var236(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar237::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var237(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar238::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var238(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar239::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var239(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar240::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var240(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar241::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var241(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar242::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var242(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar243::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var243(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar244::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var244(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar245::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var245(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar246::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var246(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar247::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var247(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar248::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var248(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar249::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var249(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar250::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var250(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar251::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var251(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar252::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var252(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar253::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var253(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar254::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var254(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar255::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var255(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar256::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var256(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar257::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var257(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar258::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var258(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar259::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var259(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar260::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var260(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar261::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var261(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar262::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var262(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar263::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var263(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar264::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var264(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar265::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var265(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar266::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var266(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar267::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var267(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar268::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var268(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar269::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var269(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar270::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var270(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar271::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var271(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar272::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var272(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar273::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var273(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar274::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var274(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar275::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var275(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar276::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var276(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar277::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var277(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar278::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var278(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar279::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var279(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar280::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var280(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar281::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var281(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar282::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var282(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar283::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var283(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar284::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var284(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar285::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var285(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar286::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var286(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar287::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var287(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar288::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var288(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar289::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var289(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar290::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var290(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar291::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var291(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar292::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var292(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar293::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var293(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar294::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var294(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar295::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var295(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar296::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var296(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar297::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var297(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar298::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var298(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar299::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var299(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar300::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var300(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar301::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var301(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar302::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var302(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar303::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var303(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar304::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var304(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar305::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var305(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar306::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var306(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar307::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var307(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar308::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var308(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar309::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var309(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar310::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var310(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar311::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var311(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar312::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var312(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar313::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var313(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar314::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var314(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar315::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var315(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar316::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var316(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar317::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var317(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar318::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var318(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar319::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var319(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar320::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var320(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar321::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var321(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar322::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var322(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar323::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var323(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar324::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var324(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar325::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var325(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar326::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var326(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar327::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var327(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar328::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var328(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar329::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var329(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar330::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var330(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar331::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var331(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar332::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var332(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar333::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var333(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar334::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var334(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar335::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var335(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar336::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var336(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar337::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var337(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar338::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var338(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar339::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var339(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar340::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var340(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar341::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var341(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar342::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var342(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar343::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var343(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar344::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var344(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar345::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var345(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar346::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var346(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar347::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var347(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar348::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var348(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar349::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var349(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar350::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var350(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar351::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var351(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar352::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var352(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar353::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var353(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar354::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var354(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar355::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var355(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar356::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var356(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar357::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var357(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar358::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var358(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar359::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var359(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar360::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var360(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar361::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var361(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar362::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var362(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar363::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var363(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar364::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var364(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar365::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var365(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar366::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var366(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar367::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var367(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar368::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var368(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar369::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var369(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar370::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var370(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar371::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var371(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar372::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var372(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar373::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var373(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar374::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var374(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar375::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var375(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar376::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var376(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar377::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var377(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:409:1"]
#[derive(Clone, Debug)]
struct opr16aVar0 {
    imm16: TokenField_imm16,
}
impl opr16aVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 0i64 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:410:1"]
#[derive(Clone, Debug)]
struct opr16aVar1 {
    imm16: TokenField_imm16,
}
impl opr16aVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 1i64 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:411:1"]
#[derive(Clone, Debug)]
struct opr16aVar2 {
    imm16: TokenField_imm16,
}
impl opr16aVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 2i64 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:412:1"]
#[derive(Clone, Debug)]
struct opr16aVar3 {
    imm16: TokenField_imm16,
}
impl opr16aVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 3i64 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:414:1"]
#[derive(Clone, Debug)]
struct opr16aVar4 {
    imm16: TokenField_imm16,
}
impl opr16aVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 4i64 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:415:1"]
#[derive(Clone, Debug)]
struct opr16aVar5 {
    imm16: TokenField_imm16,
}
impl opr16aVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 5i64 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:416:1"]
#[derive(Clone, Debug)]
struct opr16aVar6 {
    imm16: TokenField_imm16,
}
impl opr16aVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 6i64 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:417:1"]
#[derive(Clone, Debug)]
struct opr16aVar7 {
    imm16: TokenField_imm16,
}
impl opr16aVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 7i64 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:419:1"]
#[derive(Clone, Debug)]
struct opr16aVar8 {
    imm16: TokenField_imm16,
}
impl opr16aVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 8i64 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:420:1"]
#[derive(Clone, Debug)]
struct opr16aVar9 {
    imm16: TokenField_imm16,
}
impl opr16aVar9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 9i64 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:421:1"]
#[derive(Clone, Debug)]
struct opr16aVar10 {
    imm16: TokenField_imm16,
}
impl opr16aVar10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 10i64 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:422:1"]
#[derive(Clone, Debug)]
struct opr16aVar11 {
    imm16: TokenField_imm16,
}
impl opr16aVar11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 11i64 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:424:1"]
#[derive(Clone, Debug)]
struct opr16aVar12 {
    imm16: TokenField_imm16,
}
impl opr16aVar12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 12i64 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:425:1"]
#[derive(Clone, Debug)]
struct opr16aVar13 {
    imm16: TokenField_imm16,
}
impl opr16aVar13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 13i64 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:426:1"]
#[derive(Clone, Debug)]
struct opr16aVar14 {
    imm16: TokenField_imm16,
}
impl opr16aVar14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 14i64 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:427:1"]
#[derive(Clone, Debug)]
struct opr16aVar15 {
    imm16: TokenField_imm16,
}
impl opr16aVar15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if token_parser.TokenFieldimm16p().disassembly() != 15i64 {
            return None;
        }
        let imm16 = token_parser.TokenFieldimm16();
        let imm16pv = token_parser.TokenFieldimm16pv();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[derive(Clone, Debug)]
enum Tableopr16a {
    Var0(opr16aVar0),
    Var1(opr16aVar1),
    Var2(opr16aVar2),
    Var3(opr16aVar3),
    Var4(opr16aVar4),
    Var5(opr16aVar5),
    Var6(opr16aVar6),
    Var7(opr16aVar7),
    Var8(opr16aVar8),
    Var9(opr16aVar9),
    Var10(opr16aVar10),
    Var11(opr16aVar11),
    Var12(opr16aVar12),
    Var13(opr16aVar13),
    Var14(opr16aVar14),
    Var15(opr16aVar15),
}
impl Tableopr16a {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            opr16aVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar12::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar13::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar14::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) =
            opr16aVar15::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:429:1"]
#[derive(Clone, Debug)]
struct pageVar0 {
    imm8: TokenField_imm8,
}
impl pageVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm8.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let imm8 = token_parser.TokenFieldimm8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablepage {
    Var0(pageVar0),
}
impl Tablepage {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            pageVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:431:1"]
#[derive(Clone, Debug)]
struct PageDestVar0 {
    opr16a: Tableopr16a,
    page: Tablepage,
}
impl PageDestVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.opr16a.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let opr16a = if let Some((len, table)) = Tableopr16a::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0u64 as u32;
        let page = if let Some((len, table)) =
            Tablepage::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a, page }))
    }
}
#[derive(Clone, Debug)]
enum TablePageDest {
    Var0(PageDestVar0),
}
impl TablePageDest {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            PageDestVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:437:1"]
#[derive(Clone, Debug)]
struct opr8aVar0 {
    imm8: TokenField_imm8,
}
impl opr8aVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm8.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let imm8 = token_parser.TokenFieldimm8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm8 }))
    }
}
#[derive(Clone, Debug)]
enum Tableopr8a {
    Var0(opr8aVar0),
}
impl Tableopr8a {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            opr8aVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:439:1"]
#[derive(Clone, Debug)]
struct opr8a_8Var0 {
    imm8: TokenField_imm8,
}
impl opr8a_8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm8.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_UseGPAGE_disassembly() != 0i64 {
            return None;
        }
        let imm8 = token_parser.TokenFieldimm8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm8 }))
    }
}
#[derive(Clone, Debug)]
enum Tableopr8a_8 {
    Var0(opr8a_8Var0),
}
impl Tableopr8a_8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            opr8a_8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:440:1"]
#[derive(Clone, Debug)]
struct opr8a_16Var0 {
    imm8: TokenField_imm8,
}
impl opr8a_16Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm8.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if context_instance.register().read_UseGPAGE_disassembly() != 0i64 {
            return None;
        }
        let imm8 = token_parser.TokenFieldimm8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm8 }))
    }
}
#[derive(Clone, Debug)]
enum Tableopr8a_16 {
    Var0(opr8a_16Var0),
}
impl Tableopr8a_16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            opr8a_16Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:442:1"]
#[derive(Clone, Debug)]
struct opr16a_8Var0 {
    opr16a: Tableopr16a,
}
impl opr16a_8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.opr16a.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let opr16a = if let Some((len, table)) = Tableopr16a::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a }))
    }
}
#[derive(Clone, Debug)]
enum Tableopr16a_8 {
    Var0(opr16a_8Var0),
}
impl Tableopr16a_8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            opr16a_8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:443:1"]
#[derive(Clone, Debug)]
struct opr16a_16Var0 {
    opr16a: Tableopr16a,
}
impl opr16a_16Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.opr16a.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let opr16a = if let Some((len, table)) = Tableopr16a::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a }))
    }
}
#[derive(Clone, Debug)]
enum Tableopr16a_16 {
    Var0(opr16a_16Var0),
}
impl Tableopr16a_16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            opr16a_16Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:445:1"]
#[derive(Clone, Debug)]
struct iopr8iVar0 {
    imm8: TokenField_imm8,
}
impl iopr8iVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.imm8.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let imm8 = token_parser.TokenFieldimm8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm8 }))
    }
}
#[derive(Clone, Debug)]
enum Tableiopr8i {
    Var0(iopr8iVar0),
}
impl Tableiopr8i {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            iopr8iVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:446:1"]
#[derive(Clone, Debug)]
struct iopr16iVar0 {
    imm16: TokenField_imm16,
}
impl iopr16iVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.imm16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let imm16 = token_parser.TokenFieldimm16();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[derive(Clone, Debug)]
enum Tableiopr16i {
    Var0(iopr16iVar0),
}
impl Tableiopr16i {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            iopr16iVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:447:1"]
#[derive(Clone, Debug)]
struct msk8Var0 {
    imm8: TokenField_imm8,
}
impl msk8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.imm8.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let imm8 = token_parser.TokenFieldimm8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablemsk8 {
    Var0(msk8Var0),
}
impl Tablemsk8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            msk8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:467:1"]
#[derive(Clone, Debug)]
struct IDX_aVar0 {
    rr7_6: TokenField_rr7_6,
}
impl IDX_aVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("0,"), self.rr7_6.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb5_5().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldnn4_0().disassembly() != 0i64 {
            return None;
        }
        let rr7_6 = token_parser.TokenFieldrr7_6();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr7_6 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_a {
    Var0(IDX_aVar0),
}
impl TableIDX_a {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_aVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:471:1"]
#[derive(Clone, Debug)]
struct IDX_bVar0 {
    nn4_0: TokenField_nn4_0,
    rr7_6: TokenField_rr7_6,
}
impl IDX_bVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            self.nn4_0.display(),
            DisplayElement::Literal(", "),
            self.rr7_6.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb5_5().disassembly() != 0i64 {
            return None;
        }
        let rr7_6 = token_parser.TokenFieldrr7_6();
        let nn4_0 = token_parser.TokenFieldnn4_0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr7_6, nn4_0 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_b {
    Var0(IDX_bVar0),
}
impl TableIDX_b {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_bVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:479:1"]
#[derive(Clone, Debug)]
struct IDX_cVar0 {
    nn3_0: TokenField_nn3_0,
    rr7_6a: TokenField_rr7_6a,
}
impl IDX_cVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            self.nn3_0.display(),
            DisplayElement::Literal(", -"),
            self.rr7_6a.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldp4_4().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFielddecrement3_3().disassembly() != 1i64 {
            return None;
        }
        let mut sub_pattern_c28 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 1i64 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 3i64 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 5i64 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c28(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let rr7_6a = token_parser.TokenFieldrr7_6a();
        let nn3_0 = token_parser.TokenFieldnn3_0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr7_6a, nn3_0 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_c {
    Var0(IDX_cVar0),
}
impl TableIDX_c {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_cVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:483:1"]
#[derive(Clone, Debug)]
struct IDX_dVar0 {
    nn3_0: TokenField_nn3_0,
    rr7_6a: TokenField_rr7_6a,
}
impl IDX_dVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            self.nn3_0.display(),
            DisplayElement::Literal(", +"),
            self.rr7_6a.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldp4_4().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFielddecrement3_3().disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c28 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 1i64 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 3i64 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 5i64 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c28(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let rr7_6a = token_parser.TokenFieldrr7_6a();
        let nn3_0 = token_parser.TokenFieldnn3_0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr7_6a, nn3_0 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_d {
    Var0(IDX_dVar0),
}
impl TableIDX_d {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_dVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:487:1"]
#[derive(Clone, Debug)]
struct IDX_eVar0 {
    nn3_0: TokenField_nn3_0,
    rr7_6a: TokenField_rr7_6a,
}
impl IDX_eVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            self.nn3_0.display(),
            DisplayElement::Literal(", "),
            self.rr7_6a.display(),
            DisplayElement::Literal("-"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldp4_4().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFielddecrement3_3().disassembly() != 1i64 {
            return None;
        }
        let mut sub_pattern_c28 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 1i64 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 3i64 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 5i64 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c28(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let rr7_6a = token_parser.TokenFieldrr7_6a();
        let nn3_0 = token_parser.TokenFieldnn3_0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr7_6a, nn3_0 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_e {
    Var0(IDX_eVar0),
}
impl TableIDX_e {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_eVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:491:1"]
#[derive(Clone, Debug)]
struct IDX_fVar0 {
    nn3_0: TokenField_nn3_0,
    rr7_6a: TokenField_rr7_6a,
}
impl IDX_fVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            self.nn3_0.display(),
            DisplayElement::Literal(", "),
            self.rr7_6a.display(),
            DisplayElement::Literal("+"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldp4_4().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFielddecrement3_3().disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c28 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 1i64 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 3i64 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                let token_parser = <TokenParser<1usize>>::new(tokens_param)?;
                if token_parser.TokenFieldxb7_5().disassembly() == 5i64 {
                    return Some(((), (), u32::try_from(1u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c28(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let rr7_6a = token_parser.TokenFieldrr7_6a();
        let nn3_0 = token_parser.TokenFieldnn3_0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr7_6a, nn3_0 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_f {
    Var0(IDX_fVar0),
}
impl TableIDX_f {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_fVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:499:1"]
#[derive(Clone, Debug)]
struct IDX_gVar0 {
    aa0_0: TokenField_aa0_0,
}
impl IDX_gVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            self.aa0_0.display(),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::PC),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb7_5().disassembly() != 7i64 {
            return None;
        }
        if token_parser.TokenFieldrr4_3().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldxb2_1().disassembly() != 2i64 {
            return None;
        }
        let aa0_0 = token_parser.TokenFieldaa0_0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { aa0_0 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:497:1"]
#[derive(Clone, Debug)]
struct IDX_gVar1 {
    aa0_0: TokenField_aa0_0,
    rr4_3: TokenField_rr4_3,
}
impl IDX_gVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            self.aa0_0.display(),
            DisplayElement::Literal(", "),
            self.rr4_3.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb7_5().disassembly() != 7i64 {
            return None;
        }
        if token_parser.TokenFieldxb2_1().disassembly() != 2i64 {
            return None;
        }
        let rr4_3 = token_parser.TokenFieldrr4_3();
        let aa0_0 = token_parser.TokenFieldaa0_0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr4_3, aa0_0 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_g {
    Var0(IDX_gVar0),
    Var1(IDX_gVar1),
}
impl TableIDX_g {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_gVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            IDX_gVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:505:1"]
#[derive(Clone, Debug)]
struct IDX_hVar0 {}
impl IDX_hVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Register(Register::D),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::PC),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb7_5().disassembly() != 7i64 {
            return None;
        }
        if token_parser.TokenFieldrr4_3().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldxb2_0().disassembly() != 6i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:503:1"]
#[derive(Clone, Debug)]
struct IDX_hVar1 {
    rr4_3: TokenField_rr4_3,
}
impl IDX_hVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Register(Register::D),
            DisplayElement::Literal(", "),
            self.rr4_3.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb7_5().disassembly() != 7i64 {
            return None;
        }
        if token_parser.TokenFieldxb2_0().disassembly() != 6i64 {
            return None;
        }
        let rr4_3 = token_parser.TokenFieldrr4_3();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr4_3 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_h {
    Var0(IDX_hVar0),
    Var1(IDX_hVar1),
}
impl TableIDX_h {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_hVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            IDX_hVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:519:1"]
#[derive(Clone, Debug)]
struct IDX_iVar0 {
    ss0_0: TokenField_ss0_0,
    imm8: TokenField_imm8,
    IDX_i_PCRel: TableIDX_i_PCRel,
}
impl IDX_iVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_opr9: i64 = 0;
        calc_opr9 = (self
            .ss0_0
            .disassembly()
            .checked_shl(u32::try_from(8i64).unwrap())
            .unwrap_or(0)
            | self.imm8.disassembly());
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Number(true, calc_opr9),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::PC),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_opr9: i64 = 0;
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        calc_opr9 = (token_parser
            .TokenFieldss0_0()
            .disassembly()
            .checked_shl(u32::try_from(8i64).unwrap())
            .unwrap_or(0)
            | token_parser.TokenFieldimm8().disassembly());
        let mut sub_pattern_c23 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            if token_parser.TokenFieldxb7_5().disassembly() != 7i64 {
                return None;
            }
            if token_parser.TokenFieldrr4_3().disassembly() != 3i64 {
                return None;
            }
            if token_parser.TokenFieldxb2_2().disassembly() != 0i64 {
                return None;
            }
            if token_parser.TokenFieldz1_1().disassembly() != 0i64 {
                return None;
            }
            let ss0_0 = token_parser.TokenFieldss0_0();
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            let imm8 = token_parser.TokenFieldimm8();
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (ss0_0, imm8), pattern_len))
        };
        let ((), (ss0_0, imm8), sub_len) =
            sub_pattern_c23(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let IDX_i_PCRel = if let Some((len, table)) = TableIDX_i_PCRel::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                IDX_i_PCRel,
                ss0_0,
                imm8,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:515:1"]
#[derive(Clone, Debug)]
struct IDX_iVar1 {
    rr4_3: TokenField_rr4_3,
    ss0_0: TokenField_ss0_0,
    imm8: TokenField_imm8,
}
impl IDX_iVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_opr9: i64 = 0;
        calc_opr9 = (self
            .ss0_0
            .disassembly()
            .checked_shl(u32::try_from(8i64).unwrap())
            .unwrap_or(0)
            | self.imm8.disassembly());
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Number(true, calc_opr9),
            DisplayElement::Literal(", "),
            self.rr4_3.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_opr9: i64 = 0;
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb7_5().disassembly() != 7i64 {
            return None;
        }
        if token_parser.TokenFieldxb2_2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldz1_1().disassembly() != 0i64 {
            return None;
        }
        let rr4_3 = token_parser.TokenFieldrr4_3();
        let ss0_0 = token_parser.TokenFieldss0_0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        calc_opr9 = (token_parser
            .TokenFieldss0_0()
            .disassembly()
            .checked_shl(u32::try_from(8i64).unwrap())
            .unwrap_or(0)
            | token_parser.TokenFieldimm8().disassembly());
        let imm8 = token_parser.TokenFieldimm8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr4_3, ss0_0, imm8 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_i {
    Var0(IDX_iVar0),
    Var1(IDX_iVar1),
}
impl TableIDX_i {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_iVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            IDX_iVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:518:1"]
#[derive(Clone, Debug)]
struct IDX_i_PCRelVar0 {
    ss0_0: TokenField_ss0_0,
    imm8: TokenField_imm8,
}
impl IDX_i_PCRelVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_target: i64 = 0;
        calc_target = i64::try_from(inst_next).unwrap().wrapping_add(
            (self
                .ss0_0
                .disassembly()
                .checked_shl(u32::try_from(8i64).unwrap())
                .unwrap_or(0)
                | self.imm8.disassembly()),
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_target)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_target: i64 = 0;
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let ss0_0 = token_parser.TokenFieldss0_0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let imm8 = token_parser.TokenFieldimm8();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ss0_0, imm8 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_i_PCRel {
    Var0(IDX_i_PCRelVar0),
}
impl TableIDX_i_PCRel {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = IDX_i_PCRelVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:533:1"]
#[derive(Clone, Debug)]
struct IDX_kVar0 {
    simm16: TokenField_simm16,
    IDX_k_PCRel: TableIDX_k_PCRel,
}
impl IDX_kVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            self.simm16.display(),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::PC),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb7_5().disassembly() != 7i64 {
            return None;
        }
        if token_parser.TokenFieldrr4_3().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldxb2_2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldz1_1().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFields0_0().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let IDX_k_PCRel = if let Some((len, table)) = TableIDX_k_PCRel::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let simm16 = token_parser.TokenFieldsimm16();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                IDX_k_PCRel,
                simm16,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:529:1"]
#[derive(Clone, Debug)]
struct IDX_kVar1 {
    simm16: TokenField_simm16,
    rr4_3: TokenField_rr4_3,
}
impl IDX_kVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            self.simm16.display(),
            DisplayElement::Literal(", "),
            self.rr4_3.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb7_5().disassembly() != 7i64 {
            return None;
        }
        if token_parser.TokenFieldxb2_2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldz1_1().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFields0_0().disassembly() != 0i64 {
            return None;
        }
        let rr4_3 = token_parser.TokenFieldrr4_3();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let simm16 = token_parser.TokenFieldsimm16();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr4_3, simm16 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_k {
    Var0(IDX_kVar0),
    Var1(IDX_kVar1),
}
impl TableIDX_k {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_kVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            IDX_kVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:532:1"]
#[derive(Clone, Debug)]
struct IDX_k_PCRelVar0 {
    simm16: TokenField_simm16,
}
impl IDX_k_PCRelVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_target: i64 = 0;
        calc_target = i64::try_from(inst_next)
            .unwrap()
            .wrapping_add(self.simm16.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_target)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_target: i64 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let simm16 = token_parser.TokenFieldsimm16();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { simm16 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_k_PCRel {
    Var0(IDX_k_PCRelVar0),
}
impl TableIDX_k_PCRel {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = IDX_k_PCRelVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:548:1"]
#[derive(Clone, Debug)]
struct IDX_lVar0 {
    simm16: TokenField_simm16,
    IDX_l_PCRel: TableIDX_l_PCRel,
}
impl IDX_lVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("["),
            self.simm16.display(),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::PC),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb7_5().disassembly() != 7i64 {
            return None;
        }
        if token_parser.TokenFieldrr4_3().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldxb2_2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldz1_1().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFields0_0().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let IDX_l_PCRel = if let Some((len, table)) = TableIDX_l_PCRel::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_1_len = block_1_len.max(len as u32);
            table
        } else {
            return None;
        };
        let simm16 = token_parser.TokenFieldsimm16();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                IDX_l_PCRel,
                simm16,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:544:1"]
#[derive(Clone, Debug)]
struct IDX_lVar1 {
    simm16: TokenField_simm16,
    rr4_3: TokenField_rr4_3,
}
impl IDX_lVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("["),
            self.simm16.display(),
            DisplayElement::Literal(", "),
            self.rr4_3.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb7_5().disassembly() != 7i64 {
            return None;
        }
        if token_parser.TokenFieldxb2_2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldz1_1().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFields0_0().disassembly() != 1i64 {
            return None;
        }
        let rr4_3 = token_parser.TokenFieldrr4_3();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let simm16 = token_parser.TokenFieldsimm16();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr4_3, simm16 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_l {
    Var0(IDX_lVar0),
    Var1(IDX_lVar1),
}
impl TableIDX_l {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_lVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            IDX_lVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:547:1"]
#[derive(Clone, Debug)]
struct IDX_l_PCRelVar0 {
    simm16: TokenField_simm16,
}
impl IDX_l_PCRelVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_target: i64 = 0;
        calc_target = i64::try_from(inst_next)
            .unwrap()
            .wrapping_add(self.simm16.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_target)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_target: i64 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let simm16 = token_parser.TokenFieldsimm16();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { simm16 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_l_PCRel {
    Var0(IDX_l_PCRelVar0),
}
impl TableIDX_l_PCRel {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = IDX_l_PCRelVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:561:1"]
#[derive(Clone, Debug)]
struct IDX_mVar0 {}
impl IDX_mVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("["),
            DisplayElement::Register(Register::D),
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::PC),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb7_5().disassembly() != 7i64 {
            return None;
        }
        if token_parser.TokenFieldrr4_3().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldxb2_0().disassembly() != 7i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:558:1"]
#[derive(Clone, Debug)]
struct IDX_mVar1 {
    rr4_3: TokenField_rr4_3,
}
impl IDX_mVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("["),
            DisplayElement::Register(Register::D),
            DisplayElement::Literal(", "),
            self.rr4_3.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        if token_parser.TokenFieldxb7_5().disassembly() != 7i64 {
            return None;
        }
        if token_parser.TokenFieldxb2_0().disassembly() != 7i64 {
            return None;
        }
        let rr4_3 = token_parser.TokenFieldrr4_3();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr4_3 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_m {
    Var0(IDX_mVar0),
    Var1(IDX_mVar1),
}
impl TableIDX_m {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            IDX_mVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            IDX_mVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:569:1"]
#[derive(Clone, Debug)]
struct indexed3Var0 {
    IDX_a: TableIDX_a,
}
impl indexed3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_a.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_a = if let Some((len, table)) =
            TableIDX_a::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_a }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:570:1"]
#[derive(Clone, Debug)]
struct indexed3Var1 {
    IDX_b: TableIDX_b,
}
impl indexed3Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_b.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_b = if let Some((len, table)) =
            TableIDX_b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_b }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:571:1"]
#[derive(Clone, Debug)]
struct indexed3Var2 {
    IDX_c: TableIDX_c,
}
impl indexed3Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_c.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_c = if let Some((len, table)) =
            TableIDX_c::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_c }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:572:1"]
#[derive(Clone, Debug)]
struct indexed3Var3 {
    IDX_d: TableIDX_d,
}
impl indexed3Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_d.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_d = if let Some((len, table)) =
            TableIDX_d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_d }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:573:1"]
#[derive(Clone, Debug)]
struct indexed3Var4 {
    IDX_e: TableIDX_e,
}
impl indexed3Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_e.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_e = if let Some((len, table)) =
            TableIDX_e::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_e }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:574:1"]
#[derive(Clone, Debug)]
struct indexed3Var5 {
    IDX_f: TableIDX_f,
}
impl indexed3Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_f.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_f = if let Some((len, table)) =
            TableIDX_f::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_f }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:575:1"]
#[derive(Clone, Debug)]
struct indexed3Var6 {
    IDX_g: TableIDX_g,
}
impl indexed3Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_g.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_g = if let Some((len, table)) =
            TableIDX_g::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_g }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:576:1"]
#[derive(Clone, Debug)]
struct indexed3Var7 {
    IDX_h: TableIDX_h,
}
impl indexed3Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_h.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_h = if let Some((len, table)) =
            TableIDX_h::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_h }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:577:1"]
#[derive(Clone, Debug)]
struct indexed3Var8 {
    IDX_i: TableIDX_i,
}
impl indexed3Var8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_i = if let Some((len, table)) =
            TableIDX_i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:578:1"]
#[derive(Clone, Debug)]
struct indexed3Var9 {
    IDX_k: TableIDX_k,
}
impl indexed3Var9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_k.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_k = if let Some((len, table)) =
            TableIDX_k::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_k }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed3 {
    Var0(indexed3Var0),
    Var1(indexed3Var1),
    Var2(indexed3Var2),
    Var3(indexed3Var3),
    Var4(indexed3Var4),
    Var5(indexed3Var5),
    Var6(indexed3Var6),
    Var7(indexed3Var7),
    Var8(indexed3Var8),
    Var9(indexed3Var9),
}
impl Tableindexed3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            indexed3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed3Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed3Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed3Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed3Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed3Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed3Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed3Var7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed3Var8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed3Var9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:596:1"]
#[derive(Clone, Debug)]
struct indexed2Var0 {
    IDX_l: TableIDX_l,
}
impl indexed2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_l.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_l = if let Some((len, table)) =
            TableIDX_l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_l }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:597:1"]
#[derive(Clone, Debug)]
struct indexed2Var1 {
    IDX_m: TableIDX_m,
}
impl indexed2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_m.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_m = if let Some((len, table)) =
            TableIDX_m::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_m }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed2 {
    Var0(indexed2Var0),
    Var1(indexed2Var1),
}
impl Tableindexed2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            indexed2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:603:1"]
#[derive(Clone, Debug)]
struct indexed5Var0 {
    IDX_a: TableIDX_a,
}
impl indexed5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_a.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_a = if let Some((len, table)) =
            TableIDX_a::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_a }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:604:1"]
#[derive(Clone, Debug)]
struct indexed5Var1 {
    IDX_b: TableIDX_b,
}
impl indexed5Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_b.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_b = if let Some((len, table)) =
            TableIDX_b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_b }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:605:1"]
#[derive(Clone, Debug)]
struct indexed5Var2 {
    IDX_c: TableIDX_c,
}
impl indexed5Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_c.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_c = if let Some((len, table)) =
            TableIDX_c::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_c }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:606:1"]
#[derive(Clone, Debug)]
struct indexed5Var3 {
    IDX_d: TableIDX_d,
}
impl indexed5Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_d.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_d = if let Some((len, table)) =
            TableIDX_d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_d }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:607:1"]
#[derive(Clone, Debug)]
struct indexed5Var4 {
    IDX_e: TableIDX_e,
}
impl indexed5Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_e.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_e = if let Some((len, table)) =
            TableIDX_e::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_e }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:608:1"]
#[derive(Clone, Debug)]
struct indexed5Var5 {
    IDX_f: TableIDX_f,
}
impl indexed5Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_f.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_f = if let Some((len, table)) =
            TableIDX_f::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_f }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:609:1"]
#[derive(Clone, Debug)]
struct indexed5Var6 {
    IDX_g: TableIDX_g,
}
impl indexed5Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_g.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_g = if let Some((len, table)) =
            TableIDX_g::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_g }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:610:1"]
#[derive(Clone, Debug)]
struct indexed5Var7 {
    IDX_h: TableIDX_h,
}
impl indexed5Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_h.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_h = if let Some((len, table)) =
            TableIDX_h::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_h }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:611:1"]
#[derive(Clone, Debug)]
struct indexed5Var8 {
    IDX_i: TableIDX_i,
}
impl indexed5Var8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_i.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_i = if let Some((len, table)) =
            TableIDX_i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_i }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:612:1"]
#[derive(Clone, Debug)]
struct indexed5Var9 {
    IDX_k: TableIDX_k,
}
impl indexed5Var9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_k.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_k = if let Some((len, table)) =
            TableIDX_k::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_k }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:613:1"]
#[derive(Clone, Debug)]
struct indexed5Var10 {
    IDX_l: TableIDX_l,
}
impl indexed5Var10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_l.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_l = if let Some((len, table)) =
            TableIDX_l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_l }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:614:1"]
#[derive(Clone, Debug)]
struct indexed5Var11 {
    IDX_m: TableIDX_m,
}
impl indexed5Var11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_m.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_m = if let Some((len, table)) =
            TableIDX_m::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_m }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed5 {
    Var0(indexed5Var0),
    Var1(indexed5Var1),
    Var2(indexed5Var2),
    Var3(indexed5Var3),
    Var4(indexed5Var4),
    Var5(indexed5Var5),
    Var6(indexed5Var6),
    Var7(indexed5Var7),
    Var8(indexed5Var8),
    Var9(indexed5Var9),
    Var10(indexed5Var10),
    Var11(indexed5Var11),
}
impl Tableindexed5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            indexed5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed5Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed5Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed5Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed5Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed5Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed5Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed5Var7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed5Var8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed5Var9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed5Var10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed5Var11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:619:1"]
#[derive(Clone, Debug)]
struct indexed1Var0 {
    IDX_a: TableIDX_a,
}
impl indexed1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_a.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_a = if let Some((len, table)) =
            TableIDX_a::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_a }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:620:1"]
#[derive(Clone, Debug)]
struct indexed1Var1 {
    IDX_b: TableIDX_b,
}
impl indexed1Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_b.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_b = if let Some((len, table)) =
            TableIDX_b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_b }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:621:1"]
#[derive(Clone, Debug)]
struct indexed1Var2 {
    IDX_c: TableIDX_c,
}
impl indexed1Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_c.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_c = if let Some((len, table)) =
            TableIDX_c::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_c }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:622:1"]
#[derive(Clone, Debug)]
struct indexed1Var3 {
    IDX_d: TableIDX_d,
}
impl indexed1Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_d.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_d = if let Some((len, table)) =
            TableIDX_d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_d }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:623:1"]
#[derive(Clone, Debug)]
struct indexed1Var4 {
    IDX_e: TableIDX_e,
}
impl indexed1Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_e.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_e = if let Some((len, table)) =
            TableIDX_e::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_e }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:624:1"]
#[derive(Clone, Debug)]
struct indexed1Var5 {
    IDX_f: TableIDX_f,
}
impl indexed1Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_f.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_f = if let Some((len, table)) =
            TableIDX_f::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_f }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:625:1"]
#[derive(Clone, Debug)]
struct indexed1Var6 {
    IDX_g: TableIDX_g,
}
impl indexed1Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_g.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_g = if let Some((len, table)) =
            TableIDX_g::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_g }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:626:1"]
#[derive(Clone, Debug)]
struct indexed1Var7 {
    IDX_h: TableIDX_h,
}
impl indexed1Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.IDX_h.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let IDX_h = if let Some((len, table)) =
            TableIDX_h::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_h }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed1 {
    Var0(indexed1Var0),
    Var1(indexed1Var1),
    Var2(indexed1Var2),
    Var3(indexed1Var3),
    Var4(indexed1Var4),
    Var5(indexed1Var5),
    Var6(indexed1Var6),
    Var7(indexed1Var7),
}
impl Tableindexed1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            indexed1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed1Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed1Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed1Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed1Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed1Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed1Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexed1Var7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:640:1"]
#[derive(Clone, Debug)]
struct indexed1_1Var0 {
    indexed1: Tableindexed1,
}
impl indexed1_1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.indexed1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let indexed1 = if let Some((len, table)) = Tableindexed1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed1_1 {
    Var0(indexed1_1Var0),
}
impl Tableindexed1_1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexed1_1Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:648:1"]
#[derive(Clone, Debug)]
struct indexed2_1Var0 {
    indexed1: Tableindexed1,
}
impl indexed2_1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.indexed1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let indexed1 = if let Some((len, table)) = Tableindexed1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed2_1 {
    Var0(indexed2_1Var0),
}
impl Tableindexed2_1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexed2_1Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:660:1"]
#[derive(Clone, Debug)]
struct indexed0_2Var0 {
    indexed2: Tableindexed2,
}
impl indexed0_2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.indexed2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let indexed2 = if let Some((len, table)) = Tableindexed2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed0_2 {
    Var0(indexed0_2Var0),
}
impl Tableindexed0_2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexed0_2Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:666:1"]
#[derive(Clone, Debug)]
struct indexed0_3Var0 {
    indexed3: Tableindexed3,
}
impl indexed0_3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.indexed3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let indexed3 = if let Some((len, table)) = Tableindexed3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed3 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed0_3 {
    Var0(indexed0_3Var0),
}
impl Tableindexed0_3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexed0_3Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:670:1"]
#[derive(Clone, Debug)]
struct indexed1_3Var0 {
    indexed3: Tableindexed3,
}
impl indexed1_3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.indexed3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let indexed3 = if let Some((len, table)) = Tableindexed3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed3 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed1_3 {
    Var0(indexed1_3Var0),
}
impl Tableindexed1_3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexed1_3Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:682:1"]
#[derive(Clone, Debug)]
struct indexed2_3Var0 {
    indexed3: Tableindexed3,
}
impl indexed2_3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.indexed3.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let indexed3 = if let Some((len, table)) = Tableindexed3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed3 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed2_3 {
    Var0(indexed2_3Var0),
}
impl Tableindexed2_3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexed2_3Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:690:1"]
#[derive(Clone, Debug)]
struct indexedA_5Var0 {
    indexed5: Tableindexed5,
}
impl indexedA_5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.indexed5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_UseGPAGE_disassembly() != 0i64 {
            return None;
        }
        let indexed5 = if let Some((len, table)) = Tableindexed5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed5 }))
    }
}
#[derive(Clone, Debug)]
enum TableindexedA_5 {
    Var0(indexedA_5Var0),
}
impl TableindexedA_5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexedA_5Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:709:1"]
#[derive(Clone, Debug)]
struct indexed1_5Var0 {
    indexed5: Tableindexed5,
}
impl indexed1_5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.indexed5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_UseGPAGE_disassembly() != 0i64 {
            return None;
        }
        let indexed5 = if let Some((len, table)) = Tableindexed5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed5 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed1_5 {
    Var0(indexed1_5Var0),
}
impl Tableindexed1_5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexed1_5Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:728:1"]
#[derive(Clone, Debug)]
struct indexed2_5Var0 {
    indexed5: Tableindexed5,
}
impl indexed2_5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.indexed5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_UseGPAGE_disassembly() != 0i64 {
            return None;
        }
        let indexed5 = if let Some((len, table)) = Tableindexed5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed5 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed2_5 {
    Var0(indexed2_5Var0),
}
impl Tableindexed2_5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexed2_5Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:747:1"]
#[derive(Clone, Debug)]
struct rel8Var0 {
    rel: TokenField_rel,
}
impl rel8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloc: i64 = 0;
        calc_reloc = i64::try_from(inst_next)
            .unwrap()
            .wrapping_add(self.rel.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloc: i64 = 0;
        let mut block_0_len = 1u64 as u32;
        let token_parser = <TokenParser<1usize>>::new(tokens_current)?;
        let rel = token_parser.TokenFieldrel();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel }))
    }
}
#[derive(Clone, Debug)]
enum Tablerel8 {
    Var0(rel8Var0),
}
impl Tablerel8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            rel8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:750:1"]
#[derive(Clone, Debug)]
struct rel9Var0 {
    sign12_12: TokenField_sign12_12,
    rr7_0: TokenField_rr7_0,
}
impl rel9Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloc: i64 = 0;
        calc_reloc = i64::try_from(inst_next).unwrap().wrapping_add(
            (self
                .sign12_12
                .disassembly()
                .checked_shl(u32::try_from(8i64).unwrap())
                .unwrap_or(0)
                | self.rr7_0.disassembly()),
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloc: i64 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let sign12_12 = token_parser.TokenFieldsign12_12();
        let rr7_0 = token_parser.TokenFieldrr7_0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sign12_12, rr7_0 }))
    }
}
#[derive(Clone, Debug)]
enum Tablerel9 {
    Var0(rel9Var0),
}
impl Tablerel9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            rel9Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:753:1"]
#[derive(Clone, Debug)]
struct rel16Var0 {
    simm16: TokenField_simm16,
}
impl rel16Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloc: i64 = 0;
        calc_reloc = i64::try_from(inst_next)
            .unwrap()
            .wrapping_add(self.simm16.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloc: i64 = 0;
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        let simm16 = token_parser.TokenFieldsimm16();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { simm16 }))
    }
}
#[derive(Clone, Debug)]
enum Tablerel16 {
    Var0(rel16Var0),
}
impl Tablerel16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            rel16Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:756:1"]
#[derive(Clone, Debug)]
struct op2_opr16a_8Var0 {
    opr16a_8: Tableopr16a_8,
}
impl op2_opr16a_8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.opr16a_8.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let opr16a_8 = if let Some((len, table)) = Tableopr16a_8::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[derive(Clone, Debug)]
enum Tableop2_opr16a_8 {
    Var0(op2_opr16a_8Var0),
}
impl Tableop2_opr16a_8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = op2_opr16a_8Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:757:1"]
#[derive(Clone, Debug)]
struct op2_opr16a_16Var0 {
    opr16a_16: Tableopr16a_16,
}
impl op2_opr16a_16Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.opr16a_16.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let opr16a_16 = if let Some((len, table)) = Tableopr16a_16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_16 }))
    }
}
#[derive(Clone, Debug)]
enum Tableop2_opr16a_16 {
    Var0(op2_opr16a_16Var0),
}
impl Tableop2_opr16a_16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = op2_opr16a_16Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:762:1"]
#[derive(Clone, Debug)]
struct op2_indexed1_1Var0 {
    indexed1_1: Tableindexed1_1,
}
impl op2_indexed1_1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.indexed1_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let indexed1_1 = if let Some((len, table)) = Tableindexed1_1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_1 }))
    }
}
#[derive(Clone, Debug)]
enum Tableop2_indexed1_1 {
    Var0(op2_indexed1_1Var0),
}
impl Tableop2_indexed1_1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = op2_indexed1_1Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:768:1"]
#[derive(Clone, Debug)]
struct op2_indexed2_1Var0 {
    indexed2_1: Tableindexed2_1,
}
impl op2_indexed2_1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.indexed2_1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let indexed2_1 = if let Some((len, table)) = Tableindexed2_1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_1 }))
    }
}
#[derive(Clone, Debug)]
enum Tableop2_indexed2_1 {
    Var0(op2_indexed2_1Var0),
}
impl Tableop2_indexed2_1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = op2_indexed2_1Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:1964:1"]
#[derive(Clone, Debug)]
struct SkipNextInstrVar0 {}
impl SkipNextInstrVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_dest: i64 = 0;
        calc_dest = i64::try_from(inst_next).unwrap().wrapping_add(1i64);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_dest)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_dest: i64 = 0;
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSkipNextInstr {
    Var0(SkipNextInstrVar0),
}
impl TableSkipNextInstr {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = SkipNextInstrVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2072:1"]
#[derive(Clone, Debug)]
struct CallDestVar0 {
    imm8: TokenField_imm8,
    PageDest: TablePageDest,
}
impl CallDestVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.PageDest.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(", "), self.imm8.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 2u64 as u32;
        let token_parser = <TokenParser<2usize>>::new(tokens_current)?;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c31 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2u64 as u32;
            let token_parser = <TokenParser<2usize>>::new(tokens)?;
            let imm16 = token_parser.TokenFieldimm16();
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 1u64 as u32;
            let token_parser = <TokenParser<1usize>>::new(tokens)?;
            let imm8 = token_parser.TokenFieldimm8();
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (imm16, imm8), pattern_len))
        };
        let ((), (imm16, imm8), sub_len) =
            sub_pattern_c31(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let PageDest = if let Some((len, table)) = TablePageDest::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PageDest, imm8 }))
    }
}
#[derive(Clone, Debug)]
enum TableCallDest {
    Var0(CallDestVar0),
}
impl TableCallDest {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            CallDestVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:2633:1"]
#[derive(Clone, Debug)]
struct SkipNext2BytesVar0 {}
impl SkipNext2BytesVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_dest: i64 = 0;
        calc_dest = i64::try_from(inst_next).unwrap().wrapping_add(2i64);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_dest)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_dest: i64 = 0;
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSkipNext2Bytes {
    Var0(SkipNext2BytesVar0),
}
impl TableSkipNext2Bytes {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = SkipNext2BytesVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3827:1"]
#[derive(Clone, Debug)]
struct GPagedVar0 {}
impl GPagedVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("G")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc:3828:1"]
#[derive(Clone, Debug)]
struct GPagedVar1 {}
impl GPagedVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_XGATE_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_Prefix18_disassembly() != 0i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_UseGPAGE_disassembly(tmp);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableGPaged {
    Var0(GPagedVar0),
    Var1(GPagedVar1),
}
impl TableGPaged {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            GPagedVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            GPagedVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
pub fn parse_instruction<T>(
    tokens: &[u8],
    context: &mut T,
    inst_start: u32,
    global_set: &mut impl GlobalSetTrait,
) -> Option<(u32, Vec<DisplayElement>)>
where
    T: ContextTrait + Clone,
{
    let (inst_len, instruction) =
        Tableinstruction::parse(tokens, context, inst_start)?;
    let inst_next = inst_start + inst_len;
    let mut display = vec![];
    instruction.display_extend(
        &mut display,
        context,
        inst_start,
        inst_next,
        global_set,
    );
    Some((inst_next, display))
}
