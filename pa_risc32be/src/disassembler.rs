pub type AddrType = u32;
macro_rules! impl_read_to_type {
    ($ unsigned_type : ty , $ signed_type : ty , $ len : literal , $ read_unsigned : ident , $ read_signed : ident , $ write_unsigned : ident , $ write_signed : ident) => {
        const fn $read_unsigned<const BIG_ENDIAN: bool>(
            data: [u8; $len],
            start_bit: usize,
            len_bits: usize,
        ) -> $unsigned_type {
            const TYPE_BITS: usize = <$unsigned_type>::BITS as usize;
            assert!(TYPE_BITS / 8 == $len);
            assert!(len_bits > 0);
            assert!(len_bits + start_bit <= TYPE_BITS);
            let mut data = if BIG_ENDIAN {
                <$unsigned_type>::from_be_bytes(data)
            } else {
                <$unsigned_type>::from_le_bytes(data)
            };
            let value_mask = <$unsigned_type>::MAX >> (TYPE_BITS - len_bits);
            data = data >> start_bit;
            data = data & value_mask;
            data
        }
        const fn $read_signed<const BIG_ENDIAN: bool>(
            data: [u8; $len],
            start_bit: usize,
            len_bits: usize,
        ) -> $signed_type {
            const TYPE_BITS: usize = <$signed_type>::BITS as usize;
            assert!(len_bits > 1);
            assert!(TYPE_BITS / 8 == $len);
            let data = $read_unsigned::<BIG_ENDIAN>(data, start_bit, len_bits);
            let value_mask =
                <$signed_type>::MAX as $unsigned_type >> (TYPE_BITS - len_bits);
            let sign_mask = !value_mask;
            let value_part = data & value_mask;
            let sign_part = data & sign_mask;
            if sign_part != 0 {
                sign_mask as $signed_type | value_part as $signed_type
            } else {
                data as $signed_type
            }
        }
        const fn $write_unsigned<const BIG_ENDIAN: bool>(
            value: $unsigned_type,
            mem: $unsigned_type,
            start_bit: usize,
            len_bits: usize,
        ) -> [u8; $len] {
            const TYPE_BITS: usize = <$unsigned_type>::BITS as usize;
            assert!(len_bits > 0);
            assert!(len_bits + start_bit <= TYPE_BITS);
            let value_max = <$unsigned_type>::MAX >> (TYPE_BITS - len_bits);
            let mask = value_max << start_bit;
            let mut value = value;
            value <<= start_bit;
            value = (mem & !mask) | value;
            if BIG_ENDIAN {
                value.to_be_bytes()
            } else {
                value.to_le_bytes()
            }
        }
        const fn $write_signed<const BIG_ENDIAN: bool>(
            value: $signed_type,
            mem: $signed_type,
            start_bit: usize,
            len_bits: usize,
        ) -> [u8; $len] {
            const TYPE_BITS: usize = <$unsigned_type>::BITS as usize;
            assert!(len_bits > 0);
            assert!(len_bits + start_bit <= TYPE_BITS);
            let value_max = <$signed_type>::MAX >> (TYPE_BITS - len_bits);
            let value_min = <$signed_type>::MIN >> (TYPE_BITS - len_bits);
            let mask = <$unsigned_type>::MAX >> (TYPE_BITS - len_bits);
            let value = value as $unsigned_type & mask;
            let mem = mem as $unsigned_type;
            $write_unsigned::<BIG_ENDIAN>(value, mem, start_bit, len_bits)
        }
    };
}
impl_read_to_type!(u8, i8, 1, read_u8, read_i8, write_u8, write_i8);
impl_read_to_type!(u16, i16, 2, read_u16, read_i16, write_u16, write_i16);
impl_read_to_type!(u32, i32, 4, read_u32, read_i32, write_u32, write_i32);
impl_read_to_type!(u64, i64, 8, read_u64, read_i64, write_u64, write_i64);
impl_read_to_type!(
    u128, i128, 16, read_u128, read_i128, write_u128, write_i128
);
pub trait GlobalSetTrait {
    fn set_phase(&mut self, address: Option<u32>, value: i64);
    fn set_temp1(&mut self, address: Option<u32>, value: i64);
    fn set_nullifyEnable(&mut self, address: Option<u32>, value: i64);
    fn set_branchCouldBeNullified(&mut self, address: Option<u32>, value: i64);
    fn set_branchEnable(&mut self, address: Option<u32>, value: i64);
    fn set_branchType(&mut self, address: Option<u32>, value: i64);
    fn set_branchIsReturn(&mut self, address: Option<u32>, value: i64);
    fn set_padding(&mut self, address: Option<u32>, value: i64);
    fn set_branchImmDest(&mut self, address: Option<u32>, value: i64);
    fn set_temp32(&mut self, address: Option<u32>, value: i64);
}
pub trait MemoryRead {
    type AddressType;
    fn read(&self, addr: Self::AddressType, buf: &mut [u8]);
}
pub trait MemoryWrite {
    type AddressType;
    fn write(&mut self, addr: Self::AddressType, buf: &[u8]);
}
pub trait ContextregisterTrait:
    MemoryRead<AddressType = u32> + MemoryWrite<AddressType = u32>
{
    fn read_phase_raw(&self) -> u8 {
        let mut work_value = [0u8; 1u64 as usize];
        self.read(11u64 as u32, &mut work_value[0..1]);
        let value = read_u8::<true>(work_value, 0u64 as usize, 3u64 as usize);
        u8::try_from(value).unwrap()
    }
    fn write_phase_raw(&mut self, param: u8) {
        let mut mem = [0u8; 1];
        self.read(11u64 as u32, &mut mem[0..1]);
        let mem = u8::from_be_bytes(mem);
        let mem =
            write_u8::<true>(param as u8, mem, 0u64 as usize, 3u64 as usize);
        self.write(11u64 as u32, &mem[0..1]);
    }
    fn read_phase_disassembly(&self) -> i64 {
        i64::try_from(self.read_phase_raw()).unwrap()
    }
    fn write_phase_disassembly(&mut self, param: i64) {
        self.write_phase_raw(param as u8)
    }
    fn read_phase_execution(&self) -> u8 {
        self.read_phase_raw()
    }
    fn write_phase_execution(&mut self, param: u8) {
        self.write_phase_raw(param)
    }
    fn phase_display(&self) -> DisplayElement {
        meaning_number(true, self.read_phase_raw())
    }
    fn read_temp1_raw(&self) -> u8 {
        let mut work_value = [0u8; 1u64 as usize];
        self.read(11u64 as u32, &mut work_value[0..1]);
        let value = read_u8::<true>(work_value, 3u64 as usize, 1u64 as usize);
        u8::try_from(value).unwrap()
    }
    fn write_temp1_raw(&mut self, param: u8) {
        let mut mem = [0u8; 1];
        self.read(11u64 as u32, &mut mem[0..1]);
        let mem = u8::from_be_bytes(mem);
        let mem =
            write_u8::<true>(param as u8, mem, 3u64 as usize, 1u64 as usize);
        self.write(11u64 as u32, &mem[0..1]);
    }
    fn read_temp1_disassembly(&self) -> i64 {
        i64::try_from(self.read_temp1_raw()).unwrap()
    }
    fn write_temp1_disassembly(&mut self, param: i64) {
        self.write_temp1_raw(param as u8)
    }
    fn read_temp1_execution(&self) -> u8 {
        self.read_temp1_raw()
    }
    fn write_temp1_execution(&mut self, param: u8) {
        self.write_temp1_raw(param)
    }
    fn temp1_display(&self) -> DisplayElement {
        meaning_number(true, self.read_temp1_raw())
    }
    fn read_nullifyEnable_raw(&self) -> u8 {
        let mut work_value = [0u8; 1u64 as usize];
        self.read(11u64 as u32, &mut work_value[0..1]);
        let value = read_u8::<true>(work_value, 4u64 as usize, 1u64 as usize);
        u8::try_from(value).unwrap()
    }
    fn write_nullifyEnable_raw(&mut self, param: u8) {
        let mut mem = [0u8; 1];
        self.read(11u64 as u32, &mut mem[0..1]);
        let mem = u8::from_be_bytes(mem);
        let mem =
            write_u8::<true>(param as u8, mem, 4u64 as usize, 1u64 as usize);
        self.write(11u64 as u32, &mem[0..1]);
    }
    fn read_nullifyEnable_disassembly(&self) -> i64 {
        i64::try_from(self.read_nullifyEnable_raw()).unwrap()
    }
    fn write_nullifyEnable_disassembly(&mut self, param: i64) {
        self.write_nullifyEnable_raw(param as u8)
    }
    fn read_nullifyEnable_execution(&self) -> u8 {
        self.read_nullifyEnable_raw()
    }
    fn write_nullifyEnable_execution(&mut self, param: u8) {
        self.write_nullifyEnable_raw(param)
    }
    fn nullifyEnable_display(&self) -> DisplayElement {
        meaning_number(true, self.read_nullifyEnable_raw())
    }
    fn read_branchCouldBeNullified_raw(&self) -> u8 {
        let mut work_value = [0u8; 1u64 as usize];
        self.read(11u64 as u32, &mut work_value[0..1]);
        let value = read_u8::<true>(work_value, 5u64 as usize, 1u64 as usize);
        u8::try_from(value).unwrap()
    }
    fn write_branchCouldBeNullified_raw(&mut self, param: u8) {
        let mut mem = [0u8; 1];
        self.read(11u64 as u32, &mut mem[0..1]);
        let mem = u8::from_be_bytes(mem);
        let mem =
            write_u8::<true>(param as u8, mem, 5u64 as usize, 1u64 as usize);
        self.write(11u64 as u32, &mem[0..1]);
    }
    fn read_branchCouldBeNullified_disassembly(&self) -> i64 {
        i64::try_from(self.read_branchCouldBeNullified_raw()).unwrap()
    }
    fn write_branchCouldBeNullified_disassembly(&mut self, param: i64) {
        self.write_branchCouldBeNullified_raw(param as u8)
    }
    fn read_branchCouldBeNullified_execution(&self) -> u8 {
        self.read_branchCouldBeNullified_raw()
    }
    fn write_branchCouldBeNullified_execution(&mut self, param: u8) {
        self.write_branchCouldBeNullified_raw(param)
    }
    fn branchCouldBeNullified_display(&self) -> DisplayElement {
        meaning_number(true, self.read_branchCouldBeNullified_raw())
    }
    fn read_branchEnable_raw(&self) -> u8 {
        let mut work_value = [0u8; 1u64 as usize];
        self.read(11u64 as u32, &mut work_value[0..1]);
        let value = read_u8::<true>(work_value, 6u64 as usize, 1u64 as usize);
        u8::try_from(value).unwrap()
    }
    fn write_branchEnable_raw(&mut self, param: u8) {
        let mut mem = [0u8; 1];
        self.read(11u64 as u32, &mut mem[0..1]);
        let mem = u8::from_be_bytes(mem);
        let mem =
            write_u8::<true>(param as u8, mem, 6u64 as usize, 1u64 as usize);
        self.write(11u64 as u32, &mem[0..1]);
    }
    fn read_branchEnable_disassembly(&self) -> i64 {
        i64::try_from(self.read_branchEnable_raw()).unwrap()
    }
    fn write_branchEnable_disassembly(&mut self, param: i64) {
        self.write_branchEnable_raw(param as u8)
    }
    fn read_branchEnable_execution(&self) -> u8 {
        self.read_branchEnable_raw()
    }
    fn write_branchEnable_execution(&mut self, param: u8) {
        self.write_branchEnable_raw(param)
    }
    fn branchEnable_display(&self) -> DisplayElement {
        meaning_number(true, self.read_branchEnable_raw())
    }
    fn read_branchType_raw(&self) -> u8 {
        let mut work_value = [0u8; 2u64 as usize];
        self.read(10u64 as u32, &mut work_value[0..2]);
        let value = read_u16::<true>(work_value, 7u64 as usize, 3u64 as usize);
        u8::try_from(value).unwrap()
    }
    fn write_branchType_raw(&mut self, param: u8) {
        let mut mem = [0u8; 2];
        self.read(10u64 as u32, &mut mem[0..2]);
        let mem = u16::from_be_bytes(mem);
        let mem =
            write_u16::<true>(param as u16, mem, 7u64 as usize, 3u64 as usize);
        self.write(10u64 as u32, &mem[0..2]);
    }
    fn read_branchType_disassembly(&self) -> i64 {
        i64::try_from(self.read_branchType_raw()).unwrap()
    }
    fn write_branchType_disassembly(&mut self, param: i64) {
        self.write_branchType_raw(param as u8)
    }
    fn read_branchType_execution(&self) -> u8 {
        self.read_branchType_raw()
    }
    fn write_branchType_execution(&mut self, param: u8) {
        self.write_branchType_raw(param)
    }
    fn branchType_display(&self) -> DisplayElement {
        meaning_number(true, self.read_branchType_raw())
    }
    fn read_branchIsReturn_raw(&self) -> u8 {
        let mut work_value = [0u8; 1u64 as usize];
        self.read(10u64 as u32, &mut work_value[0..1]);
        let value = read_u8::<true>(work_value, 2u64 as usize, 1u64 as usize);
        u8::try_from(value).unwrap()
    }
    fn write_branchIsReturn_raw(&mut self, param: u8) {
        let mut mem = [0u8; 1];
        self.read(10u64 as u32, &mut mem[0..1]);
        let mem = u8::from_be_bytes(mem);
        let mem =
            write_u8::<true>(param as u8, mem, 2u64 as usize, 1u64 as usize);
        self.write(10u64 as u32, &mem[0..1]);
    }
    fn read_branchIsReturn_disassembly(&self) -> i64 {
        i64::try_from(self.read_branchIsReturn_raw()).unwrap()
    }
    fn write_branchIsReturn_disassembly(&mut self, param: i64) {
        self.write_branchIsReturn_raw(param as u8)
    }
    fn read_branchIsReturn_execution(&self) -> u8 {
        self.read_branchIsReturn_raw()
    }
    fn write_branchIsReturn_execution(&mut self, param: u8) {
        self.write_branchIsReturn_raw(param)
    }
    fn branchIsReturn_display(&self) -> DisplayElement {
        meaning_number(true, self.read_branchIsReturn_raw())
    }
    fn read_padding_raw(&self) -> u32 {
        let mut work_value = [0u8; 4u64 as usize];
        self.read(8u64 as u32, &mut work_value[1..4]);
        let value = read_u32::<true>(work_value, 2u64 as usize, 22u64 as usize);
        u32::try_from(value).unwrap()
    }
    fn write_padding_raw(&mut self, param: u32) {
        let mut mem = [0u8; 4];
        self.read(8u64 as u32, &mut mem[1..4]);
        let mem = u32::from_be_bytes(mem);
        let mem =
            write_u32::<true>(param as u32, mem, 2u64 as usize, 22u64 as usize);
        self.write(8u64 as u32, &mem[1..4]);
    }
    fn read_padding_disassembly(&self) -> i64 {
        i64::try_from(self.read_padding_raw()).unwrap()
    }
    fn write_padding_disassembly(&mut self, param: i64) {
        self.write_padding_raw(param as u32)
    }
    fn read_padding_execution(&self) -> u32 {
        self.read_padding_raw()
    }
    fn write_padding_execution(&mut self, param: u32) {
        self.write_padding_raw(param)
    }
    fn padding_display(&self) -> DisplayElement {
        meaning_number(true, self.read_padding_raw())
    }
    fn read_branchImmDest_raw(&self) -> u32 {
        let mut work_value = [0u8; 4u64 as usize];
        self.read(4u64 as u32, &mut work_value[0..4]);
        let value = read_u32::<true>(work_value, 0u64 as usize, 32u64 as usize);
        u32::try_from(value).unwrap()
    }
    fn write_branchImmDest_raw(&mut self, param: u32) {
        let mut mem = [0u8; 4];
        self.read(4u64 as u32, &mut mem[0..4]);
        let mem = u32::from_be_bytes(mem);
        let mem =
            write_u32::<true>(param as u32, mem, 0u64 as usize, 32u64 as usize);
        self.write(4u64 as u32, &mem[0..4]);
    }
    fn read_branchImmDest_disassembly(&self) -> i64 {
        i64::try_from(self.read_branchImmDest_raw()).unwrap()
    }
    fn write_branchImmDest_disassembly(&mut self, param: i64) {
        self.write_branchImmDest_raw(param as u32)
    }
    fn read_branchImmDest_execution(&self) -> u32 {
        self.read_branchImmDest_raw()
    }
    fn write_branchImmDest_execution(&mut self, param: u32) {
        self.write_branchImmDest_raw(param)
    }
    fn branchImmDest_display(&self) -> DisplayElement {
        meaning_number(true, self.read_branchImmDest_raw())
    }
    fn read_temp32_raw(&self) -> u32 {
        let mut work_value = [0u8; 4u64 as usize];
        self.read(0u64 as u32, &mut work_value[0..4]);
        let value = read_u32::<true>(work_value, 0u64 as usize, 32u64 as usize);
        u32::try_from(value).unwrap()
    }
    fn write_temp32_raw(&mut self, param: u32) {
        let mut mem = [0u8; 4];
        self.read(0u64 as u32, &mut mem[0..4]);
        let mem = u32::from_be_bytes(mem);
        let mem =
            write_u32::<true>(param as u32, mem, 0u64 as usize, 32u64 as usize);
        self.write(0u64 as u32, &mem[0..4]);
    }
    fn read_temp32_disassembly(&self) -> i64 {
        i64::try_from(self.read_temp32_raw()).unwrap()
    }
    fn write_temp32_disassembly(&mut self, param: i64) {
        self.write_temp32_raw(param as u32)
    }
    fn read_temp32_execution(&self) -> u32 {
        self.read_temp32_raw()
    }
    fn write_temp32_execution(&mut self, param: u32) {
        self.write_temp32_raw(param)
    }
    fn temp32_display(&self) -> DisplayElement {
        meaning_number(true, self.read_temp32_raw())
    }
}
pub trait ContextTrait {
    type Typeregister: ContextregisterTrait;
    fn register(&self) -> &Self::Typeregister;
    fn register_mut(&mut self) -> &mut Self::Typeregister;
}
#[derive(Debug, Clone, Copy, Default)]
pub struct ContextregisterStruct {
    pub chunk_0x0: [u8; 12u64 as usize],
}
impl ContextregisterTrait for ContextregisterStruct {}
impl MemoryRead for ContextregisterStruct {
    type AddressType = u32;
    fn read(&self, addr: Self::AddressType, buf: &mut [u8]) {
        let addr = <u64>::try_from(addr).unwrap();
        let buf_len = <u64>::try_from(buf.len()).unwrap();
        let addr_end = addr + buf_len;
        match (addr, addr_end) {
            (0u64..=11u64, 0u64..=12u64) => {
                let start = addr - 0u64;
                let end = usize::try_from(start + buf_len).unwrap();
                let start = usize::try_from(start).unwrap();
                buf.copy_from_slice(&self.chunk_0x0[start..end]);
            }
            _ => panic!("undefined mem {}:{}", addr, buf.len()),
        }
    }
}
impl MemoryWrite for ContextregisterStruct {
    type AddressType = u32;
    fn write(&mut self, addr: Self::AddressType, buf: &[u8]) {
        let addr = <u64>::try_from(addr).unwrap();
        let buf_len = <u64>::try_from(buf.len()).unwrap();
        let addr_end = addr + buf_len;
        match (addr, addr_end) {
            (0u64..=11u64, 0u64..=12u64) => {
                let start = addr - 0u64;
                let end = usize::try_from(start + buf_len).unwrap();
                let start = usize::try_from(start).unwrap();
                self.chunk_0x0[start..end].copy_from_slice(buf);
            }
            _ => panic!("undefined mem {}:{}", addr, buf.len()),
        }
    }
}
#[derive(Debug, Clone, Copy, Default)]
pub struct SpacesStruct {
    pub register: ContextregisterStruct,
}
impl ContextTrait for SpacesStruct {
    type Typeregister = ContextregisterStruct;
    fn register(&self) -> &Self::Typeregister {
        &self.register
    }
    fn register_mut(&mut self) -> &mut Self::Typeregister {
        &mut self.register
    }
}
fn meaning_number<T>(hex: bool, num: T) -> DisplayElement
where
    i64: TryFrom<T>,
    <i64 as TryFrom<T>>::Error: core::fmt::Debug,
{
    DisplayElement::Number(hex, i64::try_from(num).unwrap())
}
fn meaning_0_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_0_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_0_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::cr0,
        1 => Register::cr1,
        2 => Register::cr2,
        3 => Register::cr3,
        4 => Register::cr4,
        5 => Register::cr5,
        6 => Register::cr6,
        7 => Register::cr7,
        8 => Register::cr8,
        9 => Register::cr9,
        10 => Register::cr10,
        11 => Register::sar,
        12 => Register::cr12,
        13 => Register::cr13,
        14 => Register::cr14,
        15 => Register::cr15,
        16 => Register::cr16,
        17 => Register::cr17,
        18 => Register::cr18,
        19 => Register::cr19,
        20 => Register::cr20,
        21 => Register::cr21,
        22 => Register::cr22,
        23 => Register::cr23,
        24 => Register::cr24,
        25 => Register::cr25,
        26 => Register::cr26,
        27 => Register::cr27,
        28 => Register::cr28,
        29 => Register::cr29,
        30 => Register::cr30,
        31 => Register::cr31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_2_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_2_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_2_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::fr0,
        1 => Register::fpe23,
        2 => Register::fpe45,
        3 => Register::fpe67,
        4 => Register::fr4,
        5 => Register::fr5,
        6 => Register::fr6,
        7 => Register::fr7,
        8 => Register::fr8,
        9 => Register::fr9,
        10 => Register::fr10,
        11 => Register::fr11,
        12 => Register::fr12,
        13 => Register::fr13,
        14 => Register::fr14,
        15 => Register::fr15,
        16 => Register::fr16,
        17 => Register::fr17,
        18 => Register::fr18,
        19 => Register::fr19,
        20 => Register::fr20,
        21 => Register::fr21,
        22 => Register::fr22,
        23 => Register::fr23,
        24 => Register::fr24,
        25 => Register::fr25,
        26 => Register::fr26,
        27 => Register::fr27,
        28 => Register::fr28,
        29 => Register::fr29,
        30 => Register::fr30,
        31 => Register::fr31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_3_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_3_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_3_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::fr0L,
        1 => Register::fpe2,
        2 => Register::fpe4,
        3 => Register::fpe6,
        4 => Register::fr4L,
        5 => Register::fr5L,
        6 => Register::fr6L,
        7 => Register::fr7L,
        8 => Register::fr8L,
        9 => Register::fr9L,
        10 => Register::fr10L,
        11 => Register::fr11L,
        12 => Register::fr12L,
        13 => Register::fr13L,
        14 => Register::fr14L,
        15 => Register::fr15L,
        16 => Register::fr16L,
        17 => Register::fr17L,
        18 => Register::fr18L,
        19 => Register::fr19L,
        20 => Register::fr20L,
        21 => Register::fr21L,
        22 => Register::fr22L,
        23 => Register::fr23L,
        24 => Register::fr24L,
        25 => Register::fr25L,
        26 => Register::fr26L,
        27 => Register::fr27L,
        28 => Register::fr28L,
        29 => Register::fr29L,
        30 => Register::fr30L,
        31 => Register::fr31L,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_4_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_4_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_4_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::fr16L,
        1 => Register::fr17L,
        2 => Register::fr18L,
        3 => Register::fr19L,
        4 => Register::fr20L,
        5 => Register::fr21L,
        6 => Register::fr22L,
        7 => Register::fr23L,
        8 => Register::fr24L,
        9 => Register::fr25L,
        10 => Register::fr26L,
        11 => Register::fr27L,
        12 => Register::fr28L,
        13 => Register::fr29L,
        14 => Register::fr30L,
        15 => Register::fr31L,
        16 => Register::fr16R,
        17 => Register::fr17R,
        18 => Register::fr18R,
        19 => Register::fr19R,
        20 => Register::fr20R,
        21 => Register::fr21R,
        22 => Register::fr22R,
        23 => Register::fr23R,
        24 => Register::fr24R,
        25 => Register::fr25R,
        26 => Register::fr26R,
        27 => Register::fr27R,
        28 => Register::fr28R,
        29 => Register::fr29R,
        30 => Register::fr30R,
        31 => Register::fr31R,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_5_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_5_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_5_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r0,
        1 => Register::r1,
        2 => Register::rp,
        3 => Register::r3,
        4 => Register::r4,
        5 => Register::r5,
        6 => Register::r6,
        7 => Register::r7,
        8 => Register::r8,
        9 => Register::r9,
        10 => Register::r10,
        11 => Register::r11,
        12 => Register::r12,
        13 => Register::r13,
        14 => Register::r14,
        15 => Register::r15,
        16 => Register::r16,
        17 => Register::r17,
        18 => Register::r18,
        19 => Register::r19,
        20 => Register::r20,
        21 => Register::r21,
        22 => Register::r22,
        23 => Register::r23,
        24 => Register::r24,
        25 => Register::r25,
        26 => Register::r26,
        27 => Register::dp,
        28 => Register::r28,
        29 => Register::r29,
        30 => Register::sp,
        31 => Register::r31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_1_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal("RCTR"),
        1 => DisplayElement::Literal("CR1"),
        2 => DisplayElement::Literal("CR2"),
        3 => DisplayElement::Literal("CR3"),
        4 => DisplayElement::Literal("CR4"),
        5 => DisplayElement::Literal("CR5"),
        6 => DisplayElement::Literal("CR6"),
        7 => DisplayElement::Literal("CR7"),
        8 => DisplayElement::Literal("PID1"),
        9 => DisplayElement::Literal("PID2"),
        10 => DisplayElement::Literal("CCR"),
        11 => DisplayElement::Literal("SAR"),
        12 => DisplayElement::Literal("PID3"),
        13 => DisplayElement::Literal("PID4"),
        14 => DisplayElement::Literal("IVA"),
        15 => DisplayElement::Literal("EIEM"),
        16 => DisplayElement::Literal("ITMR"),
        17 => DisplayElement::Literal("IIASQ"),
        18 => DisplayElement::Literal("IIAOQ"),
        19 => DisplayElement::Literal("IIR"),
        20 => DisplayElement::Literal("ISR"),
        21 => DisplayElement::Literal("IOR"),
        22 => DisplayElement::Literal("IPSW"),
        23 => DisplayElement::Literal("EIRR"),
        24 => DisplayElement::Literal("TMP0"),
        25 => DisplayElement::Literal("TMP1"),
        26 => DisplayElement::Literal("TMP2"),
        27 => DisplayElement::Literal("TMP3"),
        28 => DisplayElement::Literal("TMP4"),
        29 => DisplayElement::Literal("TMP5"),
        30 => DisplayElement::Literal("TMP6"),
        31 => DisplayElement::Literal("TMP7"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_6_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(""),
        1 => DisplayElement::Literal(",="),
        2 => DisplayElement::Literal(",&lt;"),
        3 => DisplayElement::Literal(",OD"),
        4 => DisplayElement::Literal(",TR"),
        5 => DisplayElement::Literal(",&lt;&gt;"),
        6 => DisplayElement::Literal(",&gt;="),
        7 => DisplayElement::Literal(",EV"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_7_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(""),
        2 => DisplayElement::Literal(",SBZ"),
        3 => DisplayElement::Literal(",SHZ"),
        4 => DisplayElement::Literal(",SDC"),
        6 => DisplayElement::Literal(",SBC"),
        7 => DisplayElement::Literal(",SHC"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_8_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(""),
        2 => DisplayElement::Literal(",NBZ"),
        3 => DisplayElement::Literal(",NHZ"),
        4 => DisplayElement::Literal(",NDC"),
        6 => DisplayElement::Literal(",NBC"),
        7 => DisplayElement::Literal(",NHC"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_9_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(""),
        1 => DisplayElement::Literal(",="),
        2 => DisplayElement::Literal(",&lt;"),
        3 => DisplayElement::Literal(",&lt;="),
        7 => DisplayElement::Literal(",OD"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_10_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(""),
        1 => DisplayElement::Literal(",&lt;&gt;"),
        2 => DisplayElement::Literal(",&gt;="),
        3 => DisplayElement::Literal(",&gt;"),
        7 => DisplayElement::Literal(",EV"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_11_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(""),
        1 => DisplayElement::Literal(",="),
        2 => DisplayElement::Literal(",&lt;"),
        3 => DisplayElement::Literal(",&lt;="),
        4 => DisplayElement::Literal(",NUV"),
        5 => DisplayElement::Literal(",ZNV"),
        6 => DisplayElement::Literal(",SV"),
        7 => DisplayElement::Literal(",OD"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_12_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(""),
        1 => DisplayElement::Literal(",&lt;&gt;"),
        2 => DisplayElement::Literal(",&gt;="),
        3 => DisplayElement::Literal(",&gt;"),
        4 => DisplayElement::Literal(",UV"),
        5 => DisplayElement::Literal(",VNZ"),
        6 => DisplayElement::Literal(",NSV"),
        7 => DisplayElement::Literal(",EV"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_13_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(""),
        1 => DisplayElement::Literal(",="),
        2 => DisplayElement::Literal(",&lt;"),
        3 => DisplayElement::Literal(",&lt;="),
        4 => DisplayElement::Literal(",&lt;&lt;"),
        5 => DisplayElement::Literal(",&lt;&lt;="),
        6 => DisplayElement::Literal(",SV"),
        7 => DisplayElement::Literal(",OD"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_14_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(""),
        1 => DisplayElement::Literal(",&lt;&gt;"),
        2 => DisplayElement::Literal(",&gt;="),
        3 => DisplayElement::Literal(",&gt;"),
        4 => DisplayElement::Literal(",&gt;&gt;="),
        5 => DisplayElement::Literal(",&gt;&gt;"),
        6 => DisplayElement::Literal(",NSV"),
        7 => DisplayElement::Literal(",EV"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_15_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(",SGL"),
        1 => DisplayElement::Literal(",DBL"),
        2 => DisplayElement::Literal(",QUAD"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_16_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(",UW"),
        1 => DisplayElement::Literal(",UD"),
        2 => DisplayElement::Literal(",UQ"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_17_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(",SGL"),
        1 => DisplayElement::Literal(",DBL"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_18_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal("none"),
        1 => DisplayElement::Literal("resv"),
        2 => DisplayElement::Literal("sl"),
        3 => DisplayElement::Literal("resv"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_19_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal("none"),
        1 => DisplayElement::Literal("BC"),
        2 => DisplayElement::Literal("SL"),
        3 => DisplayElement::Literal("resv"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_20_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal("none"),
        1 => DisplayElement::Literal("CO"),
        2 => DisplayElement::Literal("resv"),
        3 => DisplayElement::Literal("resv"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_21_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(",DBL"),
        1 => DisplayElement::Literal(",SGL"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_22_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal(""),
        1 => DisplayElement::Literal("ACC"),
        2 => DisplayElement::Literal("REJ"),
        5 => DisplayElement::Literal("ACC8"),
        6 => DisplayElement::Literal("REJ8"),
        9 => DisplayElement::Literal("ACC6"),
        13 => DisplayElement::Literal("ACC4"),
        17 => DisplayElement::Literal("ACC2"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_opfam(u8);
impl TokenField_opfam {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_cr(u8);
impl TokenField_cr {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_crname2(u8);
impl TokenField_crname2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_freg2(u8);
impl TokenField_freg2 {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_freg2sgl(u8);
impl TokenField_freg2sgl {
    fn execution(&self) -> Register {
        meaning_3_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_3_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fr2half(u8);
impl TokenField_fr2half {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fusedr2(u8);
impl TokenField_fusedr2 {
    fn execution(&self) -> Register {
        meaning_4_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_4_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_reg2(u8);
impl TokenField_reg2 {
    fn execution(&self) -> Register {
        meaning_5_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_5_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_b(u8);
impl TokenField_b {
    fn execution(&self) -> Register {
        meaning_5_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_5_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bboffset(u8);
impl TokenField_bboffset {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_crname1(u8);
impl TokenField_crname1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit20(i8);
impl TokenField_bit20 {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpc1sub2(u8);
impl TokenField_fpc1sub2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_highIm10(u16);
impl TokenField_highIm10 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_reg1(u8);
impl TokenField_reg1 {
    fn execution(&self) -> Register {
        meaning_5_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_5_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fusedr1(u8);
impl TokenField_fusedr1 {
    fn execution(&self) -> Register {
        meaning_4_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_4_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_freg1(u8);
impl TokenField_freg1 {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_freg1sgl(u8);
impl TokenField_freg1sgl {
    fn execution(&self) -> Register {
        meaning_3_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_3_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fr1half(u8);
impl TokenField_fr1half {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_r(u8);
impl TokenField_r {
    fn execution(&self) -> Register {
        meaning_5_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_5_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_highIm5(i8);
impl TokenField_highIm5 {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_highIm5less16(u8);
impl TokenField_highIm5less16 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_tr(u8);
impl TokenField_tr {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_x(u8);
impl TokenField_x {
    fn execution(&self) -> Register {
        meaning_5_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_5_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_w1(u8);
impl TokenField_w1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit16(u8);
impl TokenField_bit16 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpc1sub(u8);
impl TokenField_fpc1sub {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_srbit1(u8);
impl TokenField_srbit1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_s(u8);
impl TokenField_s {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_srbit0(u8);
impl TokenField_srbit0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im13(i16);
impl TokenField_im13 {
    fn execution(&self) -> i16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_SEDCondSym(u8);
impl TokenField_SEDCondSym {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_6_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RegUnitCondSym(u8);
impl TokenField_RegUnitCondSym {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_7_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_InvUnitCondSym(u8);
impl TokenField_InvUnitCondSym {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_8_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RegLogicCondSym(u8);
impl TokenField_RegLogicCondSym {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_9_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_InvLogicCondSym(u8);
impl TokenField_InvLogicCondSym {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_10_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RegAddCondSym(u8);
impl TokenField_RegAddCondSym {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_11_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_InvAddCondSym(u8);
impl TokenField_InvAddCondSym {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_12_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RegCSCondSym(u8);
impl TokenField_RegCSCondSym {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_13_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_InvCSCondSym(u8);
impl TokenField_InvCSCondSym {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_14_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_c(u8);
impl TokenField_c {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpsub(u8);
impl TokenField_fpsub {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_srbit2(u8);
impl TokenField_srbit2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpdf(u8);
impl TokenField_fpdf {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_15_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fixeddf(u8);
impl TokenField_fixeddf {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_16_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpdfraw(u8);
impl TokenField_fpdfraw {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fixedsf(u8);
impl TokenField_fixedsf {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_16_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_a(u8);
impl TokenField_a {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_u(u8);
impl TokenField_u {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpr1x(u8);
impl TokenField_fpr1x {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_f(u8);
impl TokenField_f {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fv(u8);
impl TokenField_fv {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_zero(u8);
impl TokenField_zero {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_one(u8);
impl TokenField_one {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_subop1012(u8);
impl TokenField_subop1012 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im15(u16);
impl TokenField_im15 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sopim10(i16);
impl TokenField_sopim10 {
    fn execution(&self) -> i16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sopim5(i8);
impl TokenField_sopim5 {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpta(u8);
impl TokenField_fpta {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fusedta(u8);
impl TokenField_fusedta {
    fn execution(&self) -> Register {
        meaning_4_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_4_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpsf(u8);
impl TokenField_fpsf {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_15_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpsfraw(u8);
impl TokenField_fpsfraw {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpfmt(u8);
impl TokenField_fpfmt {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_15_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpfmt1bit(u8);
impl TokenField_fpfmt1bit {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_17_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit11(u8);
impl TokenField_bit11 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_cc(u8);
impl TokenField_cc {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_ldcc(u8);
impl TokenField_ldcc {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_18_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_stcc(u8);
impl TokenField_stcc {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_19_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_ldcwcc(u8);
impl TokenField_ldcwcc {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_20_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit10(u8);
impl TokenField_bit10 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sopim17(u32);
impl TokenField_sopim17 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_pmuop(u8);
impl TokenField_pmuop {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_specop(u8);
impl TokenField_specop {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpclass(u8);
impl TokenField_fpclass {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit9(u8);
impl TokenField_bit9 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit8(u8);
impl TokenField_bit8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpx(u8);
impl TokenField_fpx {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bits78(u8);
impl TokenField_bits78 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpr2x(u8);
impl TokenField_fpr2x {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpra(u8);
impl TokenField_fpra {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fusedra(u8);
impl TokenField_fusedra {
    fn execution(&self) -> Register {
        meaning_4_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_4_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_ext4(u8);
impl TokenField_ext4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_C(u8);
impl TokenField_C {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_subop(u8);
impl TokenField_subop {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sysopshifted(u8);
impl TokenField_sysopshifted {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sysopshiftedshort(u8);
impl TokenField_sysopshiftedshort {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_op(u8);
impl TokenField_op {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sfu(u8);
impl TokenField_sfu {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fp0czero(u8);
impl TokenField_fp0czero {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fptx(u8);
impl TokenField_fptx {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit6(u8);
impl TokenField_bit6 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sysop(u8);
impl TokenField_sysop {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_i2(u8);
impl TokenField_i2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bits59(u8);
impl TokenField_bits59 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_cp(u8);
impl TokenField_cp {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fusedfmt(u8);
impl TokenField_fusedfmt {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_21_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit5(u8);
impl TokenField_bit5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_m(u8);
impl TokenField_m {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_spn(u8);
impl TokenField_spn {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_w2(u16);
impl TokenField_w2 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_w2_2(u8);
impl TokenField_w2_2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_w2less2(u16);
impl TokenField_w2less2 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_n(u8);
impl TokenField_n {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im26(i32);
impl TokenField_im26 {
    fn execution(&self) -> i32 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sim21(i32);
impl TokenField_sim21 {
    fn execution(&self) -> i32 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sim14(i16);
impl TokenField_sim14 {
    fn execution(&self) -> i16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im21less0(u32);
impl TokenField_im21less0 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im21_1_12(u16);
impl TokenField_im21_1_12 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im21_12_14(u8);
impl TokenField_im21_12_14 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im21_14_16(u8);
impl TokenField_im21_14_16 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im21_16_21(u8);
impl TokenField_im21_16_21 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im14(u16);
impl TokenField_im14 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im14less0(u16);
impl TokenField_im14less0 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im11(i16);
impl TokenField_im11 {
    fn execution(&self) -> i16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im11less0(u16);
impl TokenField_im11less0 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_sim5(i8);
impl TokenField_sim5 {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im5(u8);
impl TokenField_im5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_im5less0(u8);
impl TokenField_im5less0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpcond(u8);
impl TokenField_fpcond {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fptest(u8);
impl TokenField_fptest {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_22_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpt(u8);
impl TokenField_fpt {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fptsgl(u8);
impl TokenField_fptsgl {
    fn execution(&self) -> Register {
        meaning_3_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_3_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fusedrt(u8);
impl TokenField_fusedrt {
    fn execution(&self) -> Register {
        meaning_4_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_4_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fpthalf(u8);
impl TokenField_fpthalf {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_crnamet(u8);
impl TokenField_crnamet {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_t(u8);
impl TokenField_t {
    fn execution(&self) -> Register {
        meaning_5_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_5_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_bit0(u8);
impl TokenField_bit0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_w(u8);
impl TokenField_w {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
struct TokenParser<const LEN: usize>([u8; LEN]);
impl<const LEN: usize> TokenParser<LEN> {
    fn new(data: &[u8]) -> Option<Self> {
        let token_slice: &[u8] = data.get(..LEN)?;
        let token_data = <[u8; LEN]>::try_from(token_slice).unwrap();
        Some(Self(token_data))
    }
    fn TokenFieldopfam(&self) -> TokenField_opfam {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 6u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_opfam(inner_value)
    }
    fn TokenFieldcr(&self) -> TokenField_cr {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_cr(inner_value)
    }
    fn TokenFieldcrname2(&self) -> TokenField_crname2 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_crname2(inner_value)
    }
    fn TokenFieldfreg2(&self) -> TokenField_freg2 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_freg2(inner_value)
    }
    fn TokenFieldfreg2sgl(&self) -> TokenField_freg2sgl {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_freg2sgl(inner_value)
    }
    fn TokenFieldfr2half(&self) -> TokenField_fr2half {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fr2half(inner_value)
    }
    fn TokenFieldfusedr2(&self) -> TokenField_fusedr2 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fusedr2(inner_value)
    }
    fn TokenFieldreg2(&self) -> TokenField_reg2 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_reg2(inner_value)
    }
    fn TokenFieldb(&self) -> TokenField_b {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_b(inner_value)
    }
    fn TokenFieldbboffset(&self) -> TokenField_bboffset {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_bboffset(inner_value)
    }
    fn TokenFieldcrname1(&self) -> TokenField_crname1 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_crname1(inner_value)
    }
    fn TokenFieldbit20(&self) -> TokenField_bit20 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i8::<true>(work_value, 4u64 as usize, 1u64 as usize);
            i8::try_from(value).unwrap()
        };
        TokenField_bit20(inner_value)
    }
    fn TokenFieldfpc1sub2(&self) -> TokenField_fpc1sub2 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fpc1sub2(inner_value)
    }
    fn TokenFieldhighIm10(&self) -> TokenField_highIm10 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 0u64 as usize, 10u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_highIm10(inner_value)
    }
    fn TokenFieldreg1(&self) -> TokenField_reg1 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_reg1(inner_value)
    }
    fn TokenFieldfusedr1(&self) -> TokenField_fusedr1 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fusedr1(inner_value)
    }
    fn TokenFieldfreg1(&self) -> TokenField_freg1 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_freg1(inner_value)
    }
    fn TokenFieldfreg1sgl(&self) -> TokenField_freg1sgl {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_freg1sgl(inner_value)
    }
    fn TokenFieldfr1half(&self) -> TokenField_fr1half {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fr1half(inner_value)
    }
    fn TokenFieldr(&self) -> TokenField_r {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_r(inner_value)
    }
    fn TokenFieldhighIm5(&self) -> TokenField_highIm5 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            i8::try_from(value).unwrap()
        };
        TokenField_highIm5(inner_value)
    }
    fn TokenFieldhighIm5less16(&self) -> TokenField_highIm5less16 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_highIm5less16(inner_value)
    }
    fn TokenFieldtr(&self) -> TokenField_tr {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_tr(inner_value)
    }
    fn TokenFieldx(&self) -> TokenField_x {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_x(inner_value)
    }
    fn TokenFieldw1(&self) -> TokenField_w1 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_w1(inner_value)
    }
    fn TokenFieldbit16(&self) -> TokenField_bit16 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_bit16(inner_value)
    }
    fn TokenFieldfpc1sub(&self) -> TokenField_fpc1sub {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 7u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fpc1sub(inner_value)
    }
    fn TokenFieldsrbit1(&self) -> TokenField_srbit1 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 7u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_srbit1(inner_value)
    }
    fn TokenFields(&self) -> TokenField_s {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 6u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_s(inner_value)
    }
    fn TokenFieldsrbit0(&self) -> TokenField_srbit0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 6u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_srbit0(inner_value)
    }
    fn TokenFieldim13(&self) -> TokenField_im13 {
        let inner_value = {
            let mut work_value = [0u8; 4u64 as usize];
            let work_start = 1u64 as usize;
            let work_end = 4u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i32::<true>(work_value, 5u64 as usize, 13u64 as usize);
            i16::try_from(value).unwrap()
        };
        TokenField_im13(inner_value)
    }
    fn TokenFieldSEDCondSym(&self) -> TokenField_SEDCondSym {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_SEDCondSym(inner_value)
    }
    fn TokenFieldRegUnitCondSym(&self) -> TokenField_RegUnitCondSym {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_RegUnitCondSym(inner_value)
    }
    fn TokenFieldInvUnitCondSym(&self) -> TokenField_InvUnitCondSym {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_InvUnitCondSym(inner_value)
    }
    fn TokenFieldRegLogicCondSym(&self) -> TokenField_RegLogicCondSym {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_RegLogicCondSym(inner_value)
    }
    fn TokenFieldInvLogicCondSym(&self) -> TokenField_InvLogicCondSym {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_InvLogicCondSym(inner_value)
    }
    fn TokenFieldRegAddCondSym(&self) -> TokenField_RegAddCondSym {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_RegAddCondSym(inner_value)
    }
    fn TokenFieldInvAddCondSym(&self) -> TokenField_InvAddCondSym {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_InvAddCondSym(inner_value)
    }
    fn TokenFieldRegCSCondSym(&self) -> TokenField_RegCSCondSym {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_RegCSCondSym(inner_value)
    }
    fn TokenFieldInvCSCondSym(&self) -> TokenField_InvCSCondSym {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_InvCSCondSym(inner_value)
    }
    fn TokenFieldc(&self) -> TokenField_c {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_c(inner_value)
    }
    fn TokenFieldfpsub(&self) -> TokenField_fpsub {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fpsub(inner_value)
    }
    fn TokenFieldsrbit2(&self) -> TokenField_srbit2 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_srbit2(inner_value)
    }
    fn TokenFieldfpdf(&self) -> TokenField_fpdf {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fpdf(inner_value)
    }
    fn TokenFieldfixeddf(&self) -> TokenField_fixeddf {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fixeddf(inner_value)
    }
    fn TokenFieldfpdfraw(&self) -> TokenField_fpdfraw {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fpdfraw(inner_value)
    }
    fn TokenFieldfixedsf(&self) -> TokenField_fixedsf {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fixedsf(inner_value)
    }
    fn TokenFielda(&self) -> TokenField_a {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_a(inner_value)
    }
    fn TokenFieldu(&self) -> TokenField_u {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_u(inner_value)
    }
    fn TokenFieldfpr1x(&self) -> TokenField_fpr1x {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fpr1x(inner_value)
    }
    fn TokenFieldf(&self) -> TokenField_f {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_f(inner_value)
    }
    fn TokenFieldfv(&self) -> TokenField_fv {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fv(inner_value)
    }
    fn TokenFieldzero(&self) -> TokenField_zero {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_zero(inner_value)
    }
    fn TokenFieldone(&self) -> TokenField_one {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_one(inner_value)
    }
    fn TokenFieldsubop1012(&self) -> TokenField_subop1012 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_subop1012(inner_value)
    }
    fn TokenFieldim15(&self) -> TokenField_im15 {
        let inner_value = {
            let mut work_value = [0u8; 4u64 as usize];
            let work_start = 1u64 as usize;
            let work_end = 4u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u32::<true>(work_value, 3u64 as usize, 15u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_im15(inner_value)
    }
    fn TokenFieldsopim10(&self) -> TokenField_sopim10 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i16::<true>(work_value, 3u64 as usize, 10u64 as usize);
            i16::try_from(value).unwrap()
        };
        TokenField_sopim10(inner_value)
    }
    fn TokenFieldsopim5(&self) -> TokenField_sopim5 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            i8::try_from(value).unwrap()
        };
        TokenField_sopim5(inner_value)
    }
    fn TokenFieldfpta(&self) -> TokenField_fpta {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fpta(inner_value)
    }
    fn TokenFieldfusedta(&self) -> TokenField_fusedta {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fusedta(inner_value)
    }
    fn TokenFieldfpsf(&self) -> TokenField_fpsf {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fpsf(inner_value)
    }
    fn TokenFieldfpsfraw(&self) -> TokenField_fpsfraw {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fpsfraw(inner_value)
    }
    fn TokenFieldfpfmt(&self) -> TokenField_fpfmt {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fpfmt(inner_value)
    }
    fn TokenFieldfpfmt1bit(&self) -> TokenField_fpfmt1bit {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fpfmt1bit(inner_value)
    }
    fn TokenFieldbit11(&self) -> TokenField_bit11 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_bit11(inner_value)
    }
    fn TokenFieldcc(&self) -> TokenField_cc {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_cc(inner_value)
    }
    fn TokenFieldldcc(&self) -> TokenField_ldcc {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_ldcc(inner_value)
    }
    fn TokenFieldstcc(&self) -> TokenField_stcc {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_stcc(inner_value)
    }
    fn TokenFieldldcwcc(&self) -> TokenField_ldcwcc {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_ldcwcc(inner_value)
    }
    fn TokenFieldbit10(&self) -> TokenField_bit10 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_bit10(inner_value)
    }
    fn TokenFieldsopim17(&self) -> TokenField_sopim17 {
        let inner_value = {
            let mut work_value = [0u8; 4u64 as usize];
            let work_start = 1u64 as usize;
            let work_end = 4u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u32::<true>(work_value, 1u64 as usize, 17u64 as usize);
            u32::try_from(value).unwrap()
        };
        TokenField_sopim17(inner_value)
    }
    fn TokenFieldpmuop(&self) -> TokenField_pmuop {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_pmuop(inner_value)
    }
    fn TokenFieldspecop(&self) -> TokenField_specop {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_specop(inner_value)
    }
    fn TokenFieldfpclass(&self) -> TokenField_fpclass {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fpclass(inner_value)
    }
    fn TokenFieldbit9(&self) -> TokenField_bit9 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_bit9(inner_value)
    }
    fn TokenFieldbit8(&self) -> TokenField_bit8 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_bit8(inner_value)
    }
    fn TokenFieldfpx(&self) -> TokenField_fpx {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fpx(inner_value)
    }
    fn TokenFieldbits78(&self) -> TokenField_bits78 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 7u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_bits78(inner_value)
    }
    fn TokenFieldfpr2x(&self) -> TokenField_fpr2x {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 7u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fpr2x(inner_value)
    }
    fn TokenFieldfpra(&self) -> TokenField_fpra {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fpra(inner_value)
    }
    fn TokenFieldfusedra(&self) -> TokenField_fusedra {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fusedra(inner_value)
    }
    fn TokenFieldext4(&self) -> TokenField_ext4 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_ext4(inner_value)
    }
    fn TokenFieldC(&self) -> TokenField_C {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_C(inner_value)
    }
    fn TokenFieldsubop(&self) -> TokenField_subop {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_subop(inner_value)
    }
    fn TokenFieldsysopshifted(&self) -> TokenField_sysopshifted {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_sysopshifted(inner_value)
    }
    fn TokenFieldsysopshiftedshort(&self) -> TokenField_sysopshiftedshort {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 7u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_sysopshiftedshort(inner_value)
    }
    fn TokenFieldop(&self) -> TokenField_op {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 6u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_op(inner_value)
    }
    fn TokenFieldsfu(&self) -> TokenField_sfu {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_sfu(inner_value)
    }
    fn TokenFieldfp0czero(&self) -> TokenField_fp0czero {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fp0czero(inner_value)
    }
    fn TokenFieldfptx(&self) -> TokenField_fptx {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 6u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fptx(inner_value)
    }
    fn TokenFieldbit6(&self) -> TokenField_bit6 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 6u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_bit6(inner_value)
    }
    fn TokenFieldsysop(&self) -> TokenField_sysop {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_sysop(inner_value)
    }
    fn TokenFieldi2(&self) -> TokenField_i2 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 7u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_i2(inner_value)
    }
    fn TokenFieldbits59(&self) -> TokenField_bits59 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_bits59(inner_value)
    }
    fn TokenFieldcp(&self) -> TokenField_cp {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_cp(inner_value)
    }
    fn TokenFieldfusedfmt(&self) -> TokenField_fusedfmt {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fusedfmt(inner_value)
    }
    fn TokenFieldbit5(&self) -> TokenField_bit5 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_bit5(inner_value)
    }
    fn TokenFieldm(&self) -> TokenField_m {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_m(inner_value)
    }
    fn TokenFieldspn(&self) -> TokenField_spn {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_spn(inner_value)
    }
    fn TokenFieldw2(&self) -> TokenField_w2 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 2u64 as usize, 11u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_w2(inner_value)
    }
    fn TokenFieldw2_2(&self) -> TokenField_w2_2 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_w2_2(inner_value)
    }
    fn TokenFieldw2less2(&self) -> TokenField_w2less2 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 3u64 as usize, 10u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_w2less2(inner_value)
    }
    fn TokenFieldn(&self) -> TokenField_n {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_n(inner_value)
    }
    fn TokenFieldim26(&self) -> TokenField_im26 {
        let inner_value = {
            let mut work_value = [0u8; 4u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 4u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i32::<true>(work_value, 0u64 as usize, 26u64 as usize);
            i32::try_from(value).unwrap()
        };
        TokenField_im26(inner_value)
    }
    fn TokenFieldsim21(&self) -> TokenField_sim21 {
        let inner_value = {
            let mut work_value = [0u8; 4u64 as usize];
            let work_start = 1u64 as usize;
            let work_end = 4u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i32::<true>(work_value, 0u64 as usize, 21u64 as usize);
            i32::try_from(value).unwrap()
        };
        TokenField_sim21(inner_value)
    }
    fn TokenFieldsim14(&self) -> TokenField_sim14 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i16::<true>(work_value, 0u64 as usize, 14u64 as usize);
            i16::try_from(value).unwrap()
        };
        TokenField_sim14(inner_value)
    }
    fn TokenFieldim21less0(&self) -> TokenField_im21less0 {
        let inner_value = {
            let mut work_value = [0u8; 4u64 as usize];
            let work_start = 1u64 as usize;
            let work_end = 4u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u32::<true>(work_value, 1u64 as usize, 20u64 as usize);
            u32::try_from(value).unwrap()
        };
        TokenField_im21less0(inner_value)
    }
    fn TokenFieldim21_1_12(&self) -> TokenField_im21_1_12 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 1u64 as usize, 11u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_im21_1_12(inner_value)
    }
    fn TokenFieldim21_12_14(&self) -> TokenField_im21_12_14 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_im21_12_14(inner_value)
    }
    fn TokenFieldim21_14_16(&self) -> TokenField_im21_14_16 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 6u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_im21_14_16(inner_value)
    }
    fn TokenFieldim21_16_21(&self) -> TokenField_im21_16_21 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_im21_16_21(inner_value)
    }
    fn TokenFieldim14(&self) -> TokenField_im14 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 0u64 as usize, 14u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_im14(inner_value)
    }
    fn TokenFieldim14less0(&self) -> TokenField_im14less0 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 1u64 as usize, 13u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_im14less0(inner_value)
    }
    fn TokenFieldim11(&self) -> TokenField_im11 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i16::<true>(work_value, 0u64 as usize, 11u64 as usize);
            i16::try_from(value).unwrap()
        };
        TokenField_im11(inner_value)
    }
    fn TokenFieldim11less0(&self) -> TokenField_im11less0 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 1u64 as usize, 11u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_im11less0(inner_value)
    }
    fn TokenFieldsim5(&self) -> TokenField_sim5 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            i8::try_from(value).unwrap()
        };
        TokenField_sim5(inner_value)
    }
    fn TokenFieldim5(&self) -> TokenField_im5 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_im5(inner_value)
    }
    fn TokenFieldim5less0(&self) -> TokenField_im5less0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_im5less0(inner_value)
    }
    fn TokenFieldfpcond(&self) -> TokenField_fpcond {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fpcond(inner_value)
    }
    fn TokenFieldfptest(&self) -> TokenField_fptest {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fptest(inner_value)
    }
    fn TokenFieldfpt(&self) -> TokenField_fpt {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fpt(inner_value)
    }
    fn TokenFieldfptsgl(&self) -> TokenField_fptsgl {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fptsgl(inner_value)
    }
    fn TokenFieldfusedrt(&self) -> TokenField_fusedrt {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fusedrt(inner_value)
    }
    fn TokenFieldfpthalf(&self) -> TokenField_fpthalf {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fpthalf(inner_value)
    }
    fn TokenFieldcrnamet(&self) -> TokenField_crnamet {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_crnamet(inner_value)
    }
    fn TokenFieldt(&self) -> TokenField_t {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_t(inner_value)
    }
    fn TokenFieldbit0(&self) -> TokenField_bit0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_bit0(inner_value)
    }
    fn TokenFieldw(&self) -> TokenField_w {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_w(inner_value)
    }
}
#[derive(Clone, Copy, Debug)]
pub enum Register {
    r0,
    r1,
    rp,
    r3,
    r4,
    r5,
    r6,
    r7,
    r8,
    r9,
    r10,
    r11,
    r12,
    r13,
    r14,
    r15,
    r16,
    r17,
    r18,
    r19,
    r20,
    r21,
    r22,
    r23,
    r24,
    r25,
    r26,
    dp,
    r28,
    r29,
    sp,
    r31,
    fr0,
    fpe23,
    fpe45,
    fpe67,
    fr4,
    fr5,
    fr6,
    fr7,
    fr8,
    fr9,
    fr10,
    fr11,
    fr12,
    fr13,
    fr14,
    fr15,
    fr16,
    fr17,
    fr18,
    fr19,
    fr20,
    fr21,
    fr22,
    fr23,
    fr24,
    fr25,
    fr26,
    fr27,
    fr28,
    fr29,
    fr30,
    fr31,
    fr0R,
    fr0L,
    fpe2,
    fpe3,
    fpe4,
    fpe5,
    fpe6,
    fpe7,
    fr4L,
    fr4R,
    fr5L,
    fr5R,
    fr6L,
    fr6R,
    fr7L,
    fr7R,
    fr8L,
    fr8R,
    fr9L,
    fr9R,
    fr10L,
    fr10R,
    fr11L,
    fr11R,
    fr12L,
    fr12R,
    fr13L,
    fr13R,
    fr14L,
    fr14R,
    fr15L,
    fr15R,
    fr16L,
    fr16R,
    fr17L,
    fr17R,
    fr18L,
    fr18R,
    fr19L,
    fr19R,
    fr20L,
    fr20R,
    fr21L,
    fr21R,
    fr22L,
    fr22R,
    fr23L,
    fr23R,
    fr24L,
    fr24R,
    fr25L,
    fr25R,
    fr26L,
    fr26R,
    fr27L,
    fr27R,
    fr28L,
    fr28R,
    fr29L,
    fr29R,
    fr30L,
    fr30R,
    fr31L,
    fr31R,
    compareBit,
    compareQueue,
    shr0,
    shr1,
    shr2,
    shr3,
    shr4,
    shr5,
    shr6,
    sr0,
    sr1,
    sr2,
    sr3,
    sr4,
    sr5,
    sr6,
    sr7,
    pswY,
    pswZ,
    pswE,
    pswS,
    pswT,
    pswH,
    pswL,
    pswN,
    pswX,
    pswB,
    pswC,
    pswV,
    pswM,
    pswCB,
    pswG,
    pswF,
    pswR,
    pswQ,
    pswP,
    pswD,
    pswI,
    cr0,
    cr1,
    cr2,
    cr3,
    cr4,
    cr5,
    cr6,
    cr7,
    cr8,
    cr9,
    cr10,
    sar,
    cr12,
    cr13,
    cr14,
    cr15,
    cr16,
    cr17,
    cr18,
    cr19,
    cr20,
    cr21,
    cr22,
    cr23,
    cr24,
    cr25,
    cr26,
    cr27,
    cr28,
    cr29,
    cr30,
    cr31,
    iasq_front,
    iasq_back,
    iaoq_front,
    iaoq_back,
    nullifyCond,
    nullifyNextCond,
    branchCond,
    branchExecuted,
    branchIndDest,
    nullifyCondResult,
    contextreg,
}
impl core::fmt::Display for Register {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::r0 => write!(f, "r0"),
            Self::r1 => write!(f, "r1"),
            Self::rp => write!(f, "rp"),
            Self::r3 => write!(f, "r3"),
            Self::r4 => write!(f, "r4"),
            Self::r5 => write!(f, "r5"),
            Self::r6 => write!(f, "r6"),
            Self::r7 => write!(f, "r7"),
            Self::r8 => write!(f, "r8"),
            Self::r9 => write!(f, "r9"),
            Self::r10 => write!(f, "r10"),
            Self::r11 => write!(f, "r11"),
            Self::r12 => write!(f, "r12"),
            Self::r13 => write!(f, "r13"),
            Self::r14 => write!(f, "r14"),
            Self::r15 => write!(f, "r15"),
            Self::r16 => write!(f, "r16"),
            Self::r17 => write!(f, "r17"),
            Self::r18 => write!(f, "r18"),
            Self::r19 => write!(f, "r19"),
            Self::r20 => write!(f, "r20"),
            Self::r21 => write!(f, "r21"),
            Self::r22 => write!(f, "r22"),
            Self::r23 => write!(f, "r23"),
            Self::r24 => write!(f, "r24"),
            Self::r25 => write!(f, "r25"),
            Self::r26 => write!(f, "r26"),
            Self::dp => write!(f, "dp"),
            Self::r28 => write!(f, "r28"),
            Self::r29 => write!(f, "r29"),
            Self::sp => write!(f, "sp"),
            Self::r31 => write!(f, "r31"),
            Self::fr0 => write!(f, "fr0"),
            Self::fpe23 => write!(f, "fpe23"),
            Self::fpe45 => write!(f, "fpe45"),
            Self::fpe67 => write!(f, "fpe67"),
            Self::fr4 => write!(f, "fr4"),
            Self::fr5 => write!(f, "fr5"),
            Self::fr6 => write!(f, "fr6"),
            Self::fr7 => write!(f, "fr7"),
            Self::fr8 => write!(f, "fr8"),
            Self::fr9 => write!(f, "fr9"),
            Self::fr10 => write!(f, "fr10"),
            Self::fr11 => write!(f, "fr11"),
            Self::fr12 => write!(f, "fr12"),
            Self::fr13 => write!(f, "fr13"),
            Self::fr14 => write!(f, "fr14"),
            Self::fr15 => write!(f, "fr15"),
            Self::fr16 => write!(f, "fr16"),
            Self::fr17 => write!(f, "fr17"),
            Self::fr18 => write!(f, "fr18"),
            Self::fr19 => write!(f, "fr19"),
            Self::fr20 => write!(f, "fr20"),
            Self::fr21 => write!(f, "fr21"),
            Self::fr22 => write!(f, "fr22"),
            Self::fr23 => write!(f, "fr23"),
            Self::fr24 => write!(f, "fr24"),
            Self::fr25 => write!(f, "fr25"),
            Self::fr26 => write!(f, "fr26"),
            Self::fr27 => write!(f, "fr27"),
            Self::fr28 => write!(f, "fr28"),
            Self::fr29 => write!(f, "fr29"),
            Self::fr30 => write!(f, "fr30"),
            Self::fr31 => write!(f, "fr31"),
            Self::fr0R => write!(f, "fr0R"),
            Self::fr0L => write!(f, "fr0L"),
            Self::fpe2 => write!(f, "fpe2"),
            Self::fpe3 => write!(f, "fpe3"),
            Self::fpe4 => write!(f, "fpe4"),
            Self::fpe5 => write!(f, "fpe5"),
            Self::fpe6 => write!(f, "fpe6"),
            Self::fpe7 => write!(f, "fpe7"),
            Self::fr4L => write!(f, "fr4L"),
            Self::fr4R => write!(f, "fr4R"),
            Self::fr5L => write!(f, "fr5L"),
            Self::fr5R => write!(f, "fr5R"),
            Self::fr6L => write!(f, "fr6L"),
            Self::fr6R => write!(f, "fr6R"),
            Self::fr7L => write!(f, "fr7L"),
            Self::fr7R => write!(f, "fr7R"),
            Self::fr8L => write!(f, "fr8L"),
            Self::fr8R => write!(f, "fr8R"),
            Self::fr9L => write!(f, "fr9L"),
            Self::fr9R => write!(f, "fr9R"),
            Self::fr10L => write!(f, "fr10L"),
            Self::fr10R => write!(f, "fr10R"),
            Self::fr11L => write!(f, "fr11L"),
            Self::fr11R => write!(f, "fr11R"),
            Self::fr12L => write!(f, "fr12L"),
            Self::fr12R => write!(f, "fr12R"),
            Self::fr13L => write!(f, "fr13L"),
            Self::fr13R => write!(f, "fr13R"),
            Self::fr14L => write!(f, "fr14L"),
            Self::fr14R => write!(f, "fr14R"),
            Self::fr15L => write!(f, "fr15L"),
            Self::fr15R => write!(f, "fr15R"),
            Self::fr16L => write!(f, "fr16L"),
            Self::fr16R => write!(f, "fr16R"),
            Self::fr17L => write!(f, "fr17L"),
            Self::fr17R => write!(f, "fr17R"),
            Self::fr18L => write!(f, "fr18L"),
            Self::fr18R => write!(f, "fr18R"),
            Self::fr19L => write!(f, "fr19L"),
            Self::fr19R => write!(f, "fr19R"),
            Self::fr20L => write!(f, "fr20L"),
            Self::fr20R => write!(f, "fr20R"),
            Self::fr21L => write!(f, "fr21L"),
            Self::fr21R => write!(f, "fr21R"),
            Self::fr22L => write!(f, "fr22L"),
            Self::fr22R => write!(f, "fr22R"),
            Self::fr23L => write!(f, "fr23L"),
            Self::fr23R => write!(f, "fr23R"),
            Self::fr24L => write!(f, "fr24L"),
            Self::fr24R => write!(f, "fr24R"),
            Self::fr25L => write!(f, "fr25L"),
            Self::fr25R => write!(f, "fr25R"),
            Self::fr26L => write!(f, "fr26L"),
            Self::fr26R => write!(f, "fr26R"),
            Self::fr27L => write!(f, "fr27L"),
            Self::fr27R => write!(f, "fr27R"),
            Self::fr28L => write!(f, "fr28L"),
            Self::fr28R => write!(f, "fr28R"),
            Self::fr29L => write!(f, "fr29L"),
            Self::fr29R => write!(f, "fr29R"),
            Self::fr30L => write!(f, "fr30L"),
            Self::fr30R => write!(f, "fr30R"),
            Self::fr31L => write!(f, "fr31L"),
            Self::fr31R => write!(f, "fr31R"),
            Self::compareBit => write!(f, "compareBit"),
            Self::compareQueue => write!(f, "compareQueue"),
            Self::shr0 => write!(f, "shr0"),
            Self::shr1 => write!(f, "shr1"),
            Self::shr2 => write!(f, "shr2"),
            Self::shr3 => write!(f, "shr3"),
            Self::shr4 => write!(f, "shr4"),
            Self::shr5 => write!(f, "shr5"),
            Self::shr6 => write!(f, "shr6"),
            Self::sr0 => write!(f, "sr0"),
            Self::sr1 => write!(f, "sr1"),
            Self::sr2 => write!(f, "sr2"),
            Self::sr3 => write!(f, "sr3"),
            Self::sr4 => write!(f, "sr4"),
            Self::sr5 => write!(f, "sr5"),
            Self::sr6 => write!(f, "sr6"),
            Self::sr7 => write!(f, "sr7"),
            Self::pswY => write!(f, "pswY"),
            Self::pswZ => write!(f, "pswZ"),
            Self::pswE => write!(f, "pswE"),
            Self::pswS => write!(f, "pswS"),
            Self::pswT => write!(f, "pswT"),
            Self::pswH => write!(f, "pswH"),
            Self::pswL => write!(f, "pswL"),
            Self::pswN => write!(f, "pswN"),
            Self::pswX => write!(f, "pswX"),
            Self::pswB => write!(f, "pswB"),
            Self::pswC => write!(f, "pswC"),
            Self::pswV => write!(f, "pswV"),
            Self::pswM => write!(f, "pswM"),
            Self::pswCB => write!(f, "pswCB"),
            Self::pswG => write!(f, "pswG"),
            Self::pswF => write!(f, "pswF"),
            Self::pswR => write!(f, "pswR"),
            Self::pswQ => write!(f, "pswQ"),
            Self::pswP => write!(f, "pswP"),
            Self::pswD => write!(f, "pswD"),
            Self::pswI => write!(f, "pswI"),
            Self::cr0 => write!(f, "cr0"),
            Self::cr1 => write!(f, "cr1"),
            Self::cr2 => write!(f, "cr2"),
            Self::cr3 => write!(f, "cr3"),
            Self::cr4 => write!(f, "cr4"),
            Self::cr5 => write!(f, "cr5"),
            Self::cr6 => write!(f, "cr6"),
            Self::cr7 => write!(f, "cr7"),
            Self::cr8 => write!(f, "cr8"),
            Self::cr9 => write!(f, "cr9"),
            Self::cr10 => write!(f, "cr10"),
            Self::sar => write!(f, "sar"),
            Self::cr12 => write!(f, "cr12"),
            Self::cr13 => write!(f, "cr13"),
            Self::cr14 => write!(f, "cr14"),
            Self::cr15 => write!(f, "cr15"),
            Self::cr16 => write!(f, "cr16"),
            Self::cr17 => write!(f, "cr17"),
            Self::cr18 => write!(f, "cr18"),
            Self::cr19 => write!(f, "cr19"),
            Self::cr20 => write!(f, "cr20"),
            Self::cr21 => write!(f, "cr21"),
            Self::cr22 => write!(f, "cr22"),
            Self::cr23 => write!(f, "cr23"),
            Self::cr24 => write!(f, "cr24"),
            Self::cr25 => write!(f, "cr25"),
            Self::cr26 => write!(f, "cr26"),
            Self::cr27 => write!(f, "cr27"),
            Self::cr28 => write!(f, "cr28"),
            Self::cr29 => write!(f, "cr29"),
            Self::cr30 => write!(f, "cr30"),
            Self::cr31 => write!(f, "cr31"),
            Self::iasq_front => write!(f, "iasq_front"),
            Self::iasq_back => write!(f, "iasq_back"),
            Self::iaoq_front => write!(f, "iaoq_front"),
            Self::iaoq_back => write!(f, "iaoq_back"),
            Self::nullifyCond => write!(f, "nullifyCond"),
            Self::nullifyNextCond => write!(f, "nullifyNextCond"),
            Self::branchCond => write!(f, "branchCond"),
            Self::branchExecuted => write!(f, "branchExecuted"),
            Self::branchIndDest => write!(f, "branchIndDest"),
            Self::nullifyCondResult => write!(f, "nullifyCondResult"),
            Self::contextreg => write!(f, "contextreg"),
        }
    }
}
#[derive(Clone, Copy, Debug)]
pub enum DisplayElement {
    Literal(&'static str),
    Register(Register),
    Number(bool, i64),
}
impl core::fmt::Display for DisplayElement {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Literal(lit) => lit.fmt(f),
            Self::Register(reg) => reg.fmt(f),
            Self::Number(hex, value) => match (*hex, value.is_negative()) {
                (true, true) => write!(f, "-0x{:x}", value.abs()),
                (true, false) => write!(f, "0x{:x}", value),
                (false, _) => value.fmt(f),
            },
        }
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:433:1"]
#[derive(Clone, Debug)]
struct instructionVar0 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 0i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:440:1"]
#[derive(Clone, Debug)]
struct instructionVar1 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 1i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:463:1"]
#[derive(Clone, Debug)]
struct instructionVar2 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 0i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 0i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 1i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:476:1"]
#[derive(Clone, Debug)]
struct instructionVar3 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 0i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 0i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 0i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:487:1"]
#[derive(Clone, Debug)]
struct instructionVar4 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 0i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 1i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 1i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:503:1"]
#[derive(Clone, Debug)]
struct instructionVar5 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 0i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 1i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 0i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:515:1"]
#[derive(Clone, Debug)]
struct instructionVar6 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 0i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 2i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 1i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:531:1"]
#[derive(Clone, Debug)]
struct instructionVar7 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 0i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 2i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 0i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:542:1"]
#[derive(Clone, Debug)]
struct instructionVar8 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 0i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 3i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 1i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:556:1"]
#[derive(Clone, Debug)]
struct instructionVar9 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 0i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 3i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 0i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:571:1"]
#[derive(Clone, Debug)]
struct instructionVar10 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 0i64
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 1i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 4i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:587:1"]
#[derive(Clone, Debug)]
struct instructionVar11 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 0i64
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 0i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 4i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchIsReturn_disassembly()
            != 0i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:595:1"]
#[derive(Clone, Debug)]
struct instructionVar12 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 0i64
        {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 0i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 4i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchIsReturn_disassembly()
            != 1i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:605:1"]
#[derive(Clone, Debug)]
struct instructionVar13 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 0i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 5i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 1i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:618:1"]
#[derive(Clone, Debug)]
struct instructionVar14 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 0i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 5i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 0i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:629:1"]
#[derive(Clone, Debug)]
struct instructionVar15 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 0i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 6i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 1i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:646:1"]
#[derive(Clone, Debug)]
struct instructionVar16 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 0i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 6i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 0i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:660:1"]
#[derive(Clone, Debug)]
struct instructionVar17 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 0i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 7i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 1i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:675:1"]
#[derive(Clone, Debug)]
struct instructionVar18 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar18 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 0i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 7i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 0i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:693:1"]
#[derive(Clone, Debug)]
struct instructionVar19 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar19 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 1i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 0i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 1i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:707:1"]
#[derive(Clone, Debug)]
struct instructionVar20 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar20 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 1i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 0i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 0i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:719:1"]
#[derive(Clone, Debug)]
struct instructionVar21 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 1i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 1i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 1i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:735:1"]
#[derive(Clone, Debug)]
struct instructionVar22 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar22 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 1i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 1i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 0i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:747:1"]
#[derive(Clone, Debug)]
struct instructionVar23 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 1i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 2i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 1i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:763:1"]
#[derive(Clone, Debug)]
struct instructionVar24 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 1i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 2i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 0i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:778:1"]
#[derive(Clone, Debug)]
struct instructionVar25 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar25 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 1i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 3i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 1i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:795:1"]
#[derive(Clone, Debug)]
struct instructionVar26 {
    instruction: Box<Tableinstruction>,
    immediateDest: TableimmediateDest,
}
impl instructionVar26 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 1i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 3i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 0i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        let immediateDest = if let Some((len, table)) =
            TableimmediateDest::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                immediateDest,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:811:1"]
#[derive(Clone, Debug)]
struct instructionVar27 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar27 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 1i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 4i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 1i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:827:1"]
#[derive(Clone, Debug)]
struct instructionVar28 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar28 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 1i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 4i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 0i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:839:1"]
#[derive(Clone, Debug)]
struct instructionVar29 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar29 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 1i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 5i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 1i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:855:1"]
#[derive(Clone, Debug)]
struct instructionVar30 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar30 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 1i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 5i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 0i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:867:1"]
#[derive(Clone, Debug)]
struct instructionVar31 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar31 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 1i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 6i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 1i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:885:1"]
#[derive(Clone, Debug)]
struct instructionVar32 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar32 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 1i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 6i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 0i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:902:1"]
#[derive(Clone, Debug)]
struct instructionVar33 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar33 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 1i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 7i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 1i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:919:1"]
#[derive(Clone, Debug)]
struct instructionVar34 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar34 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_branchEnable_disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_nullifyEnable_disassembly() != 1i64
        {
            return None;
        }
        if context_instance.register().read_branchType_disassembly() != 7i64 {
            return None;
        }
        if context_instance
            .register()
            .read_branchCouldBeNullified_disassembly()
            != 0i64
        {
            return None;
        }
        let tmp = 1i64;
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = Tableinstruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1012:1"]
#[derive(Clone, Debug)]
struct instructionVar35 {}
impl instructionVar35 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("NOP")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldreg1().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldreg2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldt().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfv().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1876:1"]
#[derive(Clone, Debug)]
struct instructionVar36 {}
impl instructionVar36 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("COPR.0.0")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldim26().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1007:1"]
#[derive(Clone, Debug)]
struct instructionVar37 {
    R1: TableR1,
    RT: TableRT,
}
impl instructionVar37 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("COPY"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldreg2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfv().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, RT }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1399:1"]
#[derive(Clone, Debug)]
struct instructionVar38 {}
impl instructionVar38 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("SYNC")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 32i64 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit20().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1400:1"]
#[derive(Clone, Debug)]
struct instructionVar39 {}
impl instructionVar39 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("SYNCDMA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 32i64 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit20().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1359:1"]
#[derive(Clone, Debug)]
struct instructionVar40 {
    R1: TableR1,
}
impl instructionVar40 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MTSM"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 195i64 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1428:1"]
#[derive(Clone, Debug)]
struct instructionVar41 {
    R2: TableR2,
    R1: TableR1,
}
impl instructionVar41 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("IITLBT"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshiftedshort().disassembly() != 32i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 0i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, R1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1327:1"]
#[derive(Clone, Debug)]
struct instructionVar42 {
    highIm10: TokenField_highIm10,
    RT: TableRT,
}
impl instructionVar42 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("SSM"),
            DisplayElement::Literal(" "),
            self.highIm10.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 107i64 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highIm10 = token_parser.TokenFieldhighIm10();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, highIm10 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1343:1"]
#[derive(Clone, Debug)]
struct instructionVar43 {
    highIm10: TokenField_highIm10,
    RT: TableRT,
}
impl instructionVar43 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("RSM"),
            DisplayElement::Literal(" "),
            self.highIm10.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 115i64 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highIm10 = token_parser.TokenFieldhighIm10();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, highIm10 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1665:1"]
#[derive(Clone, Debug)]
struct instructionVar44 {
    fixedsf: TokenField_fixedsf,
    fpdf: TokenField_fpdf,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl instructionVar44 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNVXF"),
            self.fixedsf.display(),
            self.fpdf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpdfraw().disassembly() != 0i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fixedsf = token_parser.TokenFieldfixedsf();
        let fpdf = token_parser.TokenFieldfpdf();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fixedsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1669:1"]
#[derive(Clone, Debug)]
struct instructionVar45 {
    fixedsf: TokenField_fixedsf,
    fpdf: TokenField_fpdf,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl instructionVar45 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNVXF"),
            self.fixedsf.display(),
            self.fpdf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpdfraw().disassembly() != 1i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fixedsf = token_parser.TokenFieldfixedsf();
        let fpdf = token_parser.TokenFieldfpdf();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fixedsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1673:1"]
#[derive(Clone, Debug)]
struct instructionVar46 {
    fixedsf: TokenField_fixedsf,
    fpdf: TokenField_fpdf,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl instructionVar46 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNVXF"),
            self.fixedsf.display(),
            self.fpdf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpdfraw().disassembly() != 0i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fixedsf = token_parser.TokenFieldfixedsf();
        let fpdf = token_parser.TokenFieldfpdf();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fixedsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1677:1"]
#[derive(Clone, Debug)]
struct instructionVar47 {
    fixedsf: TokenField_fixedsf,
    fpdf: TokenField_fpdf,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl instructionVar47 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNVXF"),
            self.fixedsf.display(),
            self.fpdf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpdfraw().disassembly() != 1i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fixedsf = token_parser.TokenFieldfixedsf();
        let fpdf = token_parser.TokenFieldfpdf();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fixedsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:80:1"]
#[derive(Clone, Debug)]
struct instructionVar48 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    loadCC: TableloadCC,
    RX: TableRX,
    SRRB: TableSRRB,
    RB: TableRB,
    RT: TableRT,
}
impl instructionVar48 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("LDWAX")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("),")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 6i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFields().disassembly() != 0i64 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                loadCC,
                RX,
                SRRB,
                RB,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:193:1"]
#[derive(Clone, Debug)]
struct instructionVar49 {
    RB: TableRB,
    R1dst: TableR1dst,
}
impl instructionVar49 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("COPY"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 13i64 {
            return None;
        }
        if token_parser.TokenFieldim14().disassembly() != 0i64 {
            return None;
        }
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RB, R1dst }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1424:1"]
#[derive(Clone, Debug)]
struct instructionVar50 {
    SRRB: TableSRRB,
    R1: TableR1,
    SPCBASE: TableSPCBASE,
}
impl instructionVar50 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("IDTLBA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 65i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i64 {
            return None;
        }
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SRRB, R1, SPCBASE }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1426:1"]
#[derive(Clone, Debug)]
struct instructionVar51 {
    SRRB: TableSRRB,
    R1: TableR1,
    SPCBASE: TableSPCBASE,
}
impl instructionVar51 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("IDTLBP"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 64i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i64 {
            return None;
        }
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SRRB, R1, SPCBASE }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1431:1"]
#[derive(Clone, Debug)]
struct instructionVar52 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
}
impl instructionVar52 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("PDC")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 78i64 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                SRRB,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1432:1"]
#[derive(Clone, Debug)]
struct instructionVar53 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    RB: TableRB,
}
impl instructionVar53 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("PDC")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 78i64 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                SRRB,
                SPCBASE,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1369:1"]
#[derive(Clone, Debug)]
struct instructionVar54 {
    RT: TableRT,
    SRRB: TableSRRB,
    SR: TableSR,
    SRVAL: TableSRVAL,
}
impl instructionVar54 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LDSID"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 133i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR = if let Some((len, table)) =
            TableSR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRVAL = if let Some((len, table)) =
            TableSRVAL::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RT,
                SRRB,
                SR,
                SRVAL,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1402:1"]
#[derive(Clone, Debug)]
struct instructionVar55 {
    SRRB: TableSRRB,
    R1: TableR1,
    RT: TableRT,
    SPCBASE: TableSPCBASE,
}
impl instructionVar55 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("PROBER"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 70i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SRRB,
                R1,
                RT,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1403:1"]
#[derive(Clone, Debug)]
struct instructionVar56 {
    highIm5: TokenField_highIm5,
    SRRB: TableSRRB,
    RT: TableRT,
    SPCBASE: TableSPCBASE,
}
impl instructionVar56 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("PROBERI"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            self.highIm5.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 198i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highIm5 = token_parser.TokenFieldhighIm5();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SRRB,
                RT,
                SPCBASE,
                highIm5,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1404:1"]
#[derive(Clone, Debug)]
struct instructionVar57 {
    SRRB: TableSRRB,
    R1: TableR1,
    RT: TableRT,
    SPCBASE: TableSPCBASE,
}
impl instructionVar57 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("PROBEW"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 71i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SRRB,
                R1,
                RT,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1405:1"]
#[derive(Clone, Debug)]
struct instructionVar58 {
    highIm5: TokenField_highIm5,
    SRRB: TableSRRB,
    RT: TableRT,
    SPCBASE: TableSPCBASE,
}
impl instructionVar58 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("PROBEWI"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            self.highIm5.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 199i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highIm5 = token_parser.TokenFieldhighIm5();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SRRB,
                RT,
                SPCBASE,
                highIm5,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1409:1"]
#[derive(Clone, Debug)]
struct instructionVar59 {
    RX: TableRX,
    SRRB: TableSRRB,
    RT: TableRT,
    SPCBASE: TableSPCBASE,
}
impl instructionVar59 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LCI"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 76i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB,
                RT,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1411:1"]
#[derive(Clone, Debug)]
struct instructionVar60 {
    RX: TableRX,
    SRRB3bit: TableSRRB3bit,
    sysCmplt: TablesysCmplt,
    SPCBASE: TableSPCBASE,
}
impl instructionVar60 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PDTLB")];
        display.extend_from_slice(&extend);
        self.sysCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 72i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) = TableSRRB3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) = TablesysCmplt::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB3bit,
                sysCmplt,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1412:1"]
#[derive(Clone, Debug)]
struct instructionVar61 {
    RX: TableRX,
    SRRB3bit: TableSRRB3bit,
    sysCmplt: TablesysCmplt,
    SPCBASE: TableSPCBASE,
    RB: TableRB,
}
impl instructionVar61 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PDTLB")];
        display.extend_from_slice(&extend);
        self.sysCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 72i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) = TableSRRB3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) = TablesysCmplt::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB3bit,
                sysCmplt,
                SPCBASE,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1414:1"]
#[derive(Clone, Debug)]
struct instructionVar62 {
    RX: TableRX,
    SRRB3bit: TableSRRB3bit,
    sysCmplt: TablesysCmplt,
    SPCBASE: TableSPCBASE,
}
impl instructionVar62 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PITLB")];
        display.extend_from_slice(&extend);
        self.sysCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 8i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) = TableSRRB3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) = TablesysCmplt::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB3bit,
                sysCmplt,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1415:1"]
#[derive(Clone, Debug)]
struct instructionVar63 {
    RX: TableRX,
    SRRB3bit: TableSRRB3bit,
    sysCmplt: TablesysCmplt,
    SPCBASE: TableSPCBASE,
    RB: TableRB,
}
impl instructionVar63 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PITLB")];
        display.extend_from_slice(&extend);
        self.sysCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 8i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) = TableSRRB3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) = TablesysCmplt::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB3bit,
                sysCmplt,
                SPCBASE,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1417:1"]
#[derive(Clone, Debug)]
struct instructionVar64 {
    RX: TableRX,
    SRRB3bit: TableSRRB3bit,
    sysCmplt: TablesysCmplt,
    SPCBASE: TableSPCBASE,
}
impl instructionVar64 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PDTLBE")];
        display.extend_from_slice(&extend);
        self.sysCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 73i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) = TableSRRB3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) = TablesysCmplt::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB3bit,
                sysCmplt,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1418:1"]
#[derive(Clone, Debug)]
struct instructionVar65 {
    RX: TableRX,
    SRRB3bit: TableSRRB3bit,
    sysCmplt: TablesysCmplt,
    SPCBASE: TableSPCBASE,
    RB: TableRB,
}
impl instructionVar65 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PDTLBE")];
        display.extend_from_slice(&extend);
        self.sysCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 73i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) = TableSRRB3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) = TablesysCmplt::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB3bit,
                sysCmplt,
                SPCBASE,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1420:1"]
#[derive(Clone, Debug)]
struct instructionVar66 {
    RX: TableRX,
    SRRB3bit: TableSRRB3bit,
    sysCmplt: TablesysCmplt,
    SPCBASE: TableSPCBASE,
}
impl instructionVar66 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PITLBE")];
        display.extend_from_slice(&extend);
        self.sysCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) = TableSRRB3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) = TablesysCmplt::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB3bit,
                sysCmplt,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1421:1"]
#[derive(Clone, Debug)]
struct instructionVar67 {
    RX: TableRX,
    SRRB3bit: TableSRRB3bit,
    sysCmplt: TablesysCmplt,
    SPCBASE: TableSPCBASE,
    RB: TableRB,
}
impl instructionVar67 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PITLBE")];
        display.extend_from_slice(&extend);
        self.sysCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) = TableSRRB3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let sysCmplt = if let Some((len, table)) = TablesysCmplt::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB3bit,
                sysCmplt,
                SPCBASE,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1434:1"]
#[derive(Clone, Debug)]
struct instructionVar68 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
}
impl instructionVar68 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("FDC")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 74i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                SRRB,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1435:1"]
#[derive(Clone, Debug)]
struct instructionVar69 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    RB: TableRB,
}
impl instructionVar69 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("FDC")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 74i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                SRRB,
                SPCBASE,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1440:1"]
#[derive(Clone, Debug)]
struct instructionVar70 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
}
impl instructionVar70 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FDCE")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 75i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                SRRB,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1441:1"]
#[derive(Clone, Debug)]
struct instructionVar71 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    RB: TableRB,
}
impl instructionVar71 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FDCE")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 75i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                SRRB,
                SPCBASE,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1881:1"]
#[derive(Clone, Debug)]
struct instructionVar72 {}
impl instructionVar72 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PMENB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldbit5().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldpmuop().disassembly() != 3i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1882:1"]
#[derive(Clone, Debug)]
struct instructionVar73 {}
impl instructionVar73 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("PMDIS")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldbit5().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldpmuop().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1407:1"]
#[derive(Clone, Debug)]
struct instructionVar74 {
    sysCmplt: TablesysCmplt,
    RX: TableRX,
    SRRB: TableSRRB,
    RT: TableRT,
    SPCBASE: TableSPCBASE,
}
impl instructionVar74 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("LPA")];
        display.extend_from_slice(&extend);
        self.sysCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshifted().disassembly() != 77i64 {
            return None;
        }
        let sysCmplt = if let Some((len, table)) = TablesysCmplt::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                sysCmplt,
                RX,
                SRRB,
                RT,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1498:1"]
#[derive(Clone, Debug)]
struct instructionVar75 {
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RX: TableRX,
    FPRT64: TableFPRT64,
    SPCBASE: TableSPCBASE,
}
impl instructionVar75 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDD")];
        display.extend_from_slice(&extend);
        self.indexedDoublewordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedDoublewordAccessCmplt,
                loadCC,
                SRRB,
                RX,
                FPRT64,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1503:1"]
#[derive(Clone, Debug)]
struct instructionVar76 {
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RX: TableRX,
    FPRT64: TableFPRT64,
    SPCBASE: TableSPCBASE,
}
impl instructionVar76 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDD")];
        display.extend_from_slice(&extend);
        self.indexedDoublewordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedDoublewordAccessCmplt,
                loadCC,
                SRRB,
                RX,
                FPRT64,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1508:1"]
#[derive(Clone, Debug)]
struct instructionVar77 {
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RX: TableRX,
    RB: TableRB,
    FPRT64: TableFPRT64,
    SPCBASE: TableSPCBASE,
}
impl instructionVar77 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDD")];
        display.extend_from_slice(&extend);
        self.indexedDoublewordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedDoublewordAccessCmplt,
                loadCC,
                SRRB,
                RX,
                RB,
                FPRT64,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1514:1"]
#[derive(Clone, Debug)]
struct instructionVar78 {
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RB: TableRB,
    RX: TableRX,
    FPRT64: TableFPRT64,
    SPCBASE: TableSPCBASE,
}
impl instructionVar78 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDD")];
        display.extend_from_slice(&extend);
        self.indexedDoublewordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedDoublewordAccessCmplt,
                loadCC,
                SRRB,
                RB,
                RX,
                FPRT64,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1592:1"]
#[derive(Clone, Debug)]
struct instructionVar79 {
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
    FPRT64: TableFPRT64,
    highlse5: Tablehighlse5,
}
impl instructionVar79 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDD")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldbit6().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                loadCC,
                SRRB,
                RB,
                SPCBASE,
                FPRT64,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1598:1"]
#[derive(Clone, Debug)]
struct instructionVar80 {
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
    FPRT64: TableFPRT64,
    highlse5: Tablehighlse5,
}
impl instructionVar80 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDD")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldbit6().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                loadCC,
                SRRB,
                RB,
                SPCBASE,
                FPRT64,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1626:1"]
#[derive(Clone, Debug)]
struct instructionVar81 {
    shortDispCmplt: TableshortDispCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
    FPRT64: TableFPRT64,
    highlse5: Tablehighlse5,
}
impl instructionVar81 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTD")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldbit6().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                storeCC,
                SRRB,
                RB,
                SPCBASE,
                FPRT64,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1632:1"]
#[derive(Clone, Debug)]
struct instructionVar82 {
    shortDispCmplt: TableshortDispCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
    FPRT64: TableFPRT64,
    highlse5: Tablehighlse5,
}
impl instructionVar82 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTD")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldbit6().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                storeCC,
                SRRB,
                RB,
                SPCBASE,
                FPRT64,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:144:1"]
#[derive(Clone, Debug)]
struct instructionVar83 {
    storeBytesShortCmplt: TablestoreBytesShortCmplt,
    storeCC: TablestoreCC,
    lse5: Tablelse5,
    SRRB: TableSRRB,
    RR: TableRR,
}
impl instructionVar83 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("STBYS")];
        display.extend_from_slice(&extend);
        self.storeBytesShortCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.lse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        let storeBytesShortCmplt = if let Some((len, table)) =
            TablestoreBytesShortCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                storeBytesShortCmplt,
                storeCC,
                lse5,
                SRRB,
                RR,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:164:1"]
#[derive(Clone, Debug)]
struct instructionVar84 {
    storeBytesShortCmplt: TablestoreBytesShortCmplt,
    storeCC: TablestoreCC,
    lse5: Tablelse5,
    SRRB: TableSRRB,
    RR: TableRR,
}
impl instructionVar84 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("STBYS")];
        display.extend_from_slice(&extend);
        self.storeBytesShortCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.lse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        let storeBytesShortCmplt = if let Some((len, table)) =
            TablestoreBytesShortCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                storeBytesShortCmplt,
                storeCC,
                lse5,
                SRRB,
                RR,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1381:1"]
#[derive(Clone, Debug)]
struct instructionVar85 {
    R1: TableR1,
}
impl instructionVar85 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MTSAR"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 194i64 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldcr().disassembly() != 11i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let crname2 = token_parser.TokenFieldcrname2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1296:1"]
#[derive(Clone, Debug)]
struct instructionVar86 {}
impl instructionVar86 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("RFI")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 96i64 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1307:1"]
#[derive(Clone, Debug)]
struct instructionVar87 {}
impl instructionVar87 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("RFI"),
            DisplayElement::Literal(",R"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 101i64 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1373:1"]
#[derive(Clone, Debug)]
struct instructionVar88 {
    R1: TableR1,
    SR3bit: TableSR3bit,
}
impl instructionVar88 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MTSP"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SR3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 193i64 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, SR3bit }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1377:1"]
#[derive(Clone, Debug)]
struct instructionVar89 {
    crname2: TokenField_crname2,
    R1: TableR1,
}
impl instructionVar89 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MTCTL"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.crname2.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 194i64 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let crname2 = token_parser.TokenFieldcrname2();
        let cr = token_parser.TokenFieldcr();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, crname2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1643:1"]
#[derive(Clone, Debug)]
struct instructionVar90 {
    fpsf: TokenField_fpsf,
    fpdf: TokenField_fpdf,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl instructionVar90 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNV"),
            self.fpsf.display(),
            self.fpdf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit5().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 0i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpsf = token_parser.TokenFieldfpsf();
        let fpdf = token_parser.TokenFieldfpdf();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        let fptsgl = token_parser.TokenFieldfptsgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1651:1"]
#[derive(Clone, Debug)]
struct instructionVar91 {
    fpsf: TokenField_fpsf,
    fpdf: TokenField_fpdf,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl instructionVar91 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNV"),
            self.fpsf.display(),
            self.fpdf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit5().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 1i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpsf = token_parser.TokenFieldfpsf();
        let fpdf = token_parser.TokenFieldfpdf();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        let fptsgl = token_parser.TokenFieldfptsgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1385:1"]
#[derive(Clone, Debug)]
struct instructionVar92 {
    RT: TableRT,
    SR3bit: TableSR3bit,
}
impl instructionVar92 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MFSP"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.SR3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 37i64 {
            return None;
        }
        if token_parser.TokenFieldreg1().disassembly() != 0i64 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, SR3bit }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1389:1"]
#[derive(Clone, Debug)]
struct instructionVar93 {
    crname2: TokenField_crname2,
    RT: TableRT,
}
impl instructionVar93 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("MFCTL"),
            DisplayElement::Literal(" "),
            self.crname2.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 69i64 {
            return None;
        }
        if token_parser.TokenFieldreg1().disassembly() != 0i64 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let crname2 = token_parser.TokenFieldcrname2();
        let cr = token_parser.TokenFieldcr();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT, crname2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1394:1"]
#[derive(Clone, Debug)]
struct instructionVar94 {
    RT: TableRT,
}
impl instructionVar94 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("MFIA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 165i64 {
            return None;
        }
        if token_parser.TokenFieldreg1().disassembly() != 0i64 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1425:1"]
#[derive(Clone, Debug)]
struct instructionVar95 {
    SR3bit: TableSR3bit,
    RB: TableRB,
    R1: TableR1,
}
impl instructionVar95 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("IITLBA"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",(")];
        display.extend_from_slice(&extend);
        self.SR3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshiftedshort().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i64 {
            return None;
        }
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SR3bit, RB, R1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1427:1"]
#[derive(Clone, Debug)]
struct instructionVar96 {
    SR3bit: TableSR3bit,
    RB: TableRB,
    R1: TableR1,
}
impl instructionVar96 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("IITLBP"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",(")];
        display.extend_from_slice(&extend);
        self.SR3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshiftedshort().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldim5().disassembly() != 0i64 {
            return None;
        }
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SR3bit, RB, R1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1125:1"]
#[derive(Clone, Debug)]
struct instructionVar97 {
    SEDCondSym: TokenField_SEDCondSym,
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    ShiftCondNullify: TableShiftCondNullify,
    SAR: TableSAR,
}
impl instructionVar97 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("SHRPW"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 52i64 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbits59().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ShiftCondNullify = if let Some((len, table)) =
            TableShiftCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                ShiftCondNullify,
                SAR,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1147:1"]
#[derive(Clone, Debug)]
struct instructionVar98 {
    SEDCondSym: TokenField_SEDCondSym,
    R2: TableR2,
    shiftCLen: TableshiftCLen,
    R1dst: TableR1dst,
    ExtrCondNullify: TableExtrCondNullify,
    SAR: TableSAR,
}
impl instructionVar98 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("EXTRW"),
            DisplayElement::Literal(",U"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 52i64 {
            return None;
        }
        if token_parser.TokenFieldbits59().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 4i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ExtrCondNullify = if let Some((len, table)) =
            TableExtrCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                shiftCLen,
                R1dst,
                ExtrCondNullify,
                SAR,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1157:1"]
#[derive(Clone, Debug)]
struct instructionVar99 {
    SEDCondSym: TokenField_SEDCondSym,
    R2: TableR2,
    shiftCLen: TableshiftCLen,
    R1dst: TableR1dst,
    ExtrCondNullify: TableExtrCondNullify,
    SAR: TableSAR,
}
impl instructionVar99 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("EXTRW"),
            DisplayElement::Literal(",S"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 52i64 {
            return None;
        }
        if token_parser.TokenFieldbits59().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 5i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ExtrCondNullify = if let Some((len, table)) =
            TableExtrCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                shiftCLen,
                R1dst,
                ExtrCondNullify,
                SAR,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1187:1"]
#[derive(Clone, Debug)]
struct instructionVar100 {
    SEDCondSym: TokenField_SEDCondSym,
    R1: TableR1,
    R2: TableR2,
    R2dst: TableR2dst,
    shiftCLen: TableshiftCLen,
    DepCondNullify: TableDepCondNullify,
    SAR: TableSAR,
}
impl instructionVar100 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("DEPW"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 53i64 {
            return None;
        }
        if token_parser.TokenFieldbits59().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 1i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                R2dst,
                shiftCLen,
                DepCondNullify,
                SAR,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1214:1"]
#[derive(Clone, Debug)]
struct instructionVar101 {
    SEDCondSym: TokenField_SEDCondSym,
    shiftCLen: TableshiftCLen,
    highlse5: Tablehighlse5,
    R2: TableR2,
    R2dst: TableR2dst,
    DepCondNullify: TableDepCondNullify,
    SAR: TableSAR,
}
impl instructionVar101 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("DEPWI"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 53i64 {
            return None;
        }
        if token_parser.TokenFieldbits59().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 5i64 {
            return None;
        }
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shiftCLen,
                highlse5,
                R2,
                R2dst,
                DepCondNullify,
                SAR,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1243:1"]
#[derive(Clone, Debug)]
struct instructionVar102 {
    SEDCondSym: TokenField_SEDCondSym,
    R1: TableR1,
    shiftCLen: TableshiftCLen,
    R2: TableR2,
    R2dst: TableR2dst,
    DepCondNullify: TableDepCondNullify,
    SAR: TableSAR,
}
impl instructionVar102 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("DEPW"),
            DisplayElement::Literal(",Z"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 53i64 {
            return None;
        }
        if token_parser.TokenFieldbits59().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                shiftCLen,
                R2,
                R2dst,
                DepCondNullify,
                SAR,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1263:1"]
#[derive(Clone, Debug)]
struct instructionVar103 {
    SEDCondSym: TokenField_SEDCondSym,
    SAR: TableSAR,
    shiftCLen: TableshiftCLen,
    highlse5: Tablehighlse5,
    R2dst: TableR2dst,
    DepCondNullify: TableDepCondNullify,
}
impl instructionVar103 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("DEPWI"),
            DisplayElement::Literal(",Z"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 53i64 {
            return None;
        }
        if token_parser.TokenFieldbits59().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 4i64 {
            return None;
        }
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SAR,
                shiftCLen,
                highlse5,
                R2dst,
                DepCondNullify,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1294:1"]
#[derive(Clone, Debug)]
struct instructionVar104 {
    im5: TokenField_im5,
    im13: TokenField_im13,
}
impl instructionVar104 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("BREAK"),
            DisplayElement::Literal(" "),
            self.im5.display(),
            DisplayElement::Literal(","),
            self.im13.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsysop().disassembly() != 0i64 {
            return None;
        }
        let im5 = token_parser.TokenFieldim5();
        let im13 = token_parser.TokenFieldim13();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { im5, im13 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1437:1"]
#[derive(Clone, Debug)]
struct instructionVar105 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    SR3bit: TableSR3bit,
    RB: TableRB,
}
impl instructionVar105 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("FIC")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.SR3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshiftedshort().disassembly() != 10i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                SR3bit,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1438:1"]
#[derive(Clone, Debug)]
struct instructionVar106 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    SR3bit: TableSR3bit,
    RB: TableRB,
}
impl instructionVar106 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("FIC")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.SR3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshiftedshort().disassembly() != 10i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                SR3bit,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1443:1"]
#[derive(Clone, Debug)]
struct instructionVar107 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    SR3bit: TableSR3bit,
    RB: TableRB,
}
impl instructionVar107 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FICE")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.SR3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshiftedshort().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                SR3bit,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1444:1"]
#[derive(Clone, Debug)]
struct instructionVar108 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    RX: TableRX,
    SR3bit: TableSR3bit,
    RB: TableRB,
}
impl instructionVar108 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FICE")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.SR3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsysopshiftedshort().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                RX,
                SR3bit,
                RB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1587:1"]
#[derive(Clone, Debug)]
struct instructionVar109 {
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    FPRT64: TableFPRT64,
    highlse5: Tablehighlse5,
}
impl instructionVar109 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDD")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldbit6().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                loadCC,
                SRRB,
                SPCBASE,
                FPRT64,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1621:1"]
#[derive(Clone, Debug)]
struct instructionVar110 {
    shortDispCmplt: TableshortDispCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    FPRT64: TableFPRT64,
    highlse5: Tablehighlse5,
}
impl instructionVar110 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTD")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldbit6().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                storeCC,
                SRRB,
                SPCBASE,
                FPRT64,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1686:1"]
#[derive(Clone, Debug)]
struct instructionVar111 {
    fpsf: TokenField_fpsf,
    fixeddf: TokenField_fixeddf,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl instructionVar111 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNVFX"),
            self.fpsf.display(),
            self.fixeddf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 1i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpsf = token_parser.TokenFieldfpsf();
        let fixeddf = token_parser.TokenFieldfixeddf();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpsf,
                fixeddf,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1692:1"]
#[derive(Clone, Debug)]
struct instructionVar112 {
    fpsf: TokenField_fpsf,
    fixeddf: TokenField_fixeddf,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl instructionVar112 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNVFX"),
            self.fpsf.display(),
            self.fixeddf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 0i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpsf = token_parser.TokenFieldfpsf();
        let fixeddf = token_parser.TokenFieldfixeddf();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpsf,
                fixeddf,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1702:1"]
#[derive(Clone, Debug)]
struct instructionVar113 {
    fpsf: TokenField_fpsf,
    fixeddf: TokenField_fixeddf,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl instructionVar113 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNVFXT"),
            self.fpsf.display(),
            self.fixeddf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 1i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpsf = token_parser.TokenFieldfpsf();
        let fixeddf = token_parser.TokenFieldfixeddf();
        let fpsfraw = token_parser.TokenFieldfpsfraw();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpsf,
                fixeddf,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1707:1"]
#[derive(Clone, Debug)]
struct instructionVar114 {
    fpsf: TokenField_fpsf,
    fixeddf: TokenField_fixeddf,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl instructionVar114 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNVFXT"),
            self.fpsf.display(),
            self.fixeddf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsfu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 0i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpsf = token_parser.TokenFieldfpsf();
        let fixeddf = token_parser.TokenFieldfixeddf();
        let fpsfraw = token_parser.TokenFieldfpsfraw();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpsf,
                fixeddf,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:62:1"]
#[derive(Clone, Debug)]
struct instructionVar115 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    loadCC: TableloadCC,
    RX: TableRX,
    RT: TableRT,
    SRRB: TableSRRB,
}
impl instructionVar115 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("LDW")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                loadCC,
                RX,
                RT,
                SRRB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:68:1"]
#[derive(Clone, Debug)]
struct instructionVar116 {
    indexedHalfwordAccessCmplt: TableindexedHalfwordAccessCmplt,
    loadCC: TableloadCC,
    RX: TableRX,
    SRRB: TableSRRB,
    RT: TableRT,
}
impl instructionVar116 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("LDH")];
        display.extend_from_slice(&extend);
        self.indexedHalfwordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        let indexedHalfwordAccessCmplt = if let Some((len, table)) =
            TableindexedHalfwordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedHalfwordAccessCmplt,
                loadCC,
                RX,
                SRRB,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:74:1"]
#[derive(Clone, Debug)]
struct instructionVar117 {
    indexedByteAccessCmplt: TableindexedByteAccessCmplt,
    loadCC: TableloadCC,
    RX: TableRX,
    SRRB: TableSRRB,
    RT: TableRT,
}
impl instructionVar117 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("LDB")];
        display.extend_from_slice(&extend);
        self.indexedByteAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        let indexedByteAccessCmplt = if let Some((len, table)) =
            TableindexedByteAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedByteAccessCmplt,
                loadCC,
                RX,
                SRRB,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:85:1"]
#[derive(Clone, Debug)]
struct instructionVar118 {
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    loadClearCC: TableloadClearCC,
    RX: TableRX,
    SRRB: TableSRRB,
    RT: TableRT,
}
impl instructionVar118 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("LDCWX")];
        display.extend_from_slice(&extend);
        self.indexedDoublewordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadClearCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 7i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadClearCC = if let Some((len, table)) = TableloadClearCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedDoublewordAccessCmplt,
                loadClearCC,
                RX,
                SRRB,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:92:1"]
#[derive(Clone, Debug)]
struct instructionVar119 {
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    highlse5: Tablehighlse5,
    SRRB: TableSRRB,
    RT: TableRT,
}
impl instructionVar119 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("LDW")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                loadCC,
                highlse5,
                SRRB,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:98:1"]
#[derive(Clone, Debug)]
struct instructionVar120 {
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    highlse5: Tablehighlse5,
    SRRB: TableSRRB,
    RT: TableRT,
}
impl instructionVar120 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("LDH")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                loadCC,
                highlse5,
                SRRB,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:104:1"]
#[derive(Clone, Debug)]
struct instructionVar121 {
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    highlse5: Tablehighlse5,
    SRRB: TableSRRB,
    RT: TableRT,
}
impl instructionVar121 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("LDB")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                loadCC,
                highlse5,
                SRRB,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:110:1"]
#[derive(Clone, Debug)]
struct instructionVar122 {
    storeShortDispCmplt: TablestoreShortDispCmplt,
    storeCC: TablestoreCC,
    lse5: Tablelse5,
    SRRB: TableSRRB,
    RR: TableRR,
}
impl instructionVar122 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("STW")];
        display.extend_from_slice(&extend);
        self.storeShortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.lse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 10i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        let storeShortDispCmplt = if let Some((len, table)) =
            TablestoreShortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                storeShortDispCmplt,
                storeCC,
                lse5,
                SRRB,
                RR,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:116:1"]
#[derive(Clone, Debug)]
struct instructionVar123 {
    storeShortDispCmplt: TablestoreShortDispCmplt,
    storeCC: TablestoreCC,
    lse5: Tablelse5,
    SRRB: TableSRRB,
    RR: TableRR,
}
impl instructionVar123 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("STH")];
        display.extend_from_slice(&extend);
        self.storeShortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.lse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        let storeShortDispCmplt = if let Some((len, table)) =
            TablestoreShortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                storeShortDispCmplt,
                storeCC,
                lse5,
                SRRB,
                RR,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:122:1"]
#[derive(Clone, Debug)]
struct instructionVar124 {
    storeShortDispCmplt: TablestoreShortDispCmplt,
    storeCC: TablestoreCC,
    lse5: Tablelse5,
    SRRB: TableSRRB,
    RR: TableRR,
}
impl instructionVar124 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("STB")];
        display.extend_from_slice(&extend);
        self.storeShortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.lse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 8i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        let storeShortDispCmplt = if let Some((len, table)) =
            TablestoreShortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                storeShortDispCmplt,
                storeCC,
                lse5,
                SRRB,
                RR,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:127:1"]
#[derive(Clone, Debug)]
struct instructionVar125 {
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    highlse5: Tablehighlse5,
    RB: TableRB,
    RT: TableRT,
}
impl instructionVar125 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("LDWAS")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("),")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 6i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                loadCC,
                highlse5,
                RB,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:132:1"]
#[derive(Clone, Debug)]
struct instructionVar126 {
    shortDispCmplt: TableshortDispCmplt,
    loadClearCC: TableloadClearCC,
    highlse5: Tablehighlse5,
    SRRB: TableSRRB,
    RT: TableRT,
}
impl instructionVar126 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("LDCWS")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadClearCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 7i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadClearCC = if let Some((len, table)) = TableloadClearCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                loadClearCC,
                highlse5,
                SRRB,
                RT,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:138:1"]
#[derive(Clone, Debug)]
struct instructionVar127 {
    shortDispCmplt: TableshortDispCmplt,
    storeCC: TablestoreCC,
    lse5: Tablelse5,
    RB: TableRB,
    RR: TableRR,
}
impl instructionVar127 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("STWAS")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.lse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldsubop().disassembly() != 14i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                storeCC,
                lse5,
                RB,
                RR,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:247:1"]
#[derive(Clone, Debug)]
struct instructionVar128 {
    nullifyForBranch: TablenullifyForBranch,
    branchTarget3W: TablebranchTarget3W,
}
impl instructionVar128 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("B")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.branchTarget3W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i64 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldreg2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget3W = if let Some((len, table)) =
            TablebranchTarget3W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                nullifyForBranch,
                branchTarget3W,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:264:1"]
#[derive(Clone, Debug)]
struct instructionVar129 {
    nullifySymForBranch: TablenullifySymForBranch,
    branchTarget3W: TablebranchTarget3W,
}
impl instructionVar129 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("B")];
        display.extend_from_slice(&extend);
        self.nullifySymForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.branchTarget3W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i64 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldreg2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let nullifySymForBranch = if let Some((len, table)) =
            TablenullifySymForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget3W = if let Some((len, table)) =
            TablebranchTarget3W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                nullifySymForBranch,
                branchTarget3W,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:197:1"]
#[derive(Clone, Debug)]
struct instructionVar130 {
    lse14: Tablelse14,
    R1dst: TableR1dst,
}
impl instructionVar130 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDI"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 13i64 {
            return None;
        }
        if token_parser.TokenFieldb().disassembly() != 0i64 {
            return None;
        }
        let lse14 = if let Some((len, table)) =
            Tablelse14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse14, R1dst }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:430:1"]
#[derive(Clone, Debug)]
struct instructionVar131 {
    RB: TableRB,
    nullifyForBranch: TablenullifyForBranch,
    ReturnTarget: TableReturnTarget,
}
impl instructionVar131 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchIsReturn(
            Some(inst_next),
            context.register().read_branchIsReturn_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("BV")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" (")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i64 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 6i64 {
            return None;
        }
        if token_parser.TokenFieldreg1().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 4i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchIsReturn_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ReturnTarget = if let Some((len, table)) = TableReturnTarget::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                nullifyForBranch,
                ReturnTarget,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:447:1"]
#[derive(Clone, Debug)]
struct instructionVar132 {
    RB: TableRB,
    nullifyForBranch: TablenullifyForBranch,
    ReturnTarget: TableReturnTarget,
}
impl instructionVar132 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("BV")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" (")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i64 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 6i64 {
            return None;
        }
        if token_parser.TokenFieldreg1().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ReturnTarget = if let Some((len, table)) = TableReturnTarget::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                nullifyForBranch,
                ReturnTarget,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:409:1"]
#[derive(Clone, Debug)]
struct instructionVar133 {
    RB: TableRB,
    nullifyForBranch: TablenullifyForBranch,
    RX: TableRX,
    IndexedTarget: TableIndexedTarget,
}
impl instructionVar133 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("BV")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i64 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 6i64 {
            return None;
        }
        if token_parser.TokenFieldbit0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 4i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let IndexedTarget = if let Some((len, table)) =
            TableIndexedTarget::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                nullifyForBranch,
                RX,
                IndexedTarget,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:423:1"]
#[derive(Clone, Debug)]
struct instructionVar134 {
    RB: TableRB,
    nullifySymForBranch: TablenullifySymForBranch,
    RX: TableRX,
    IndexedTarget: TableIndexedTarget,
}
impl instructionVar134 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("BV")];
        display.extend_from_slice(&extend);
        self.nullifySymForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i64 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 6i64 {
            return None;
        }
        if token_parser.TokenFieldbit0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifySymForBranch = if let Some((len, table)) =
            TablenullifySymForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let IndexedTarget = if let Some((len, table)) =
            TableIndexedTarget::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                nullifySymForBranch,
                RX,
                IndexedTarget,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:219:1"]
#[derive(Clone, Debug)]
struct instructionVar135 {
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget3W: TablebranchTarget3W,
}
impl instructionVar135 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("B"), DisplayElement::Literal(",L")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.branchTarget3W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i64 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget3W = if let Some((len, table)) =
            TablebranchTarget3W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2dst,
                nullifyForBranch,
                branchTarget3W,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:235:1"]
#[derive(Clone, Debug)]
struct instructionVar136 {
    R2dst: TableR2dst,
    nullifySymForBranch: TablenullifySymForBranch,
    branchTarget3W: TablebranchTarget3W,
}
impl instructionVar136 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("B"), DisplayElement::Literal(",L")];
        display.extend_from_slice(&extend);
        self.nullifySymForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.branchTarget3W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i64 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifySymForBranch = if let Some((len, table)) =
            TablenullifySymForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget3W = if let Some((len, table)) =
            TablebranchTarget3W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2dst,
                nullifySymForBranch,
                branchTarget3W,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:387:1"]
#[derive(Clone, Debug)]
struct instructionVar137 {
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    RR: TableRR,
    IPRelativeIndexedTarget: TableIPRelativeIndexedTarget,
}
impl instructionVar137 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("BLR")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i64 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 5i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let IPRelativeIndexedTarget = if let Some((len, table)) =
            TableIPRelativeIndexedTarget::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2dst,
                nullifyForBranch,
                RR,
                IPRelativeIndexedTarget,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:402:1"]
#[derive(Clone, Debug)]
struct instructionVar138 {
    R2dst: TableR2dst,
    nullifySymForBranch: TablenullifySymForBranch,
    RR: TableRR,
    IPRelativeIndexedTarget: TableIPRelativeIndexedTarget,
}
impl instructionVar138 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("BLR")];
        display.extend_from_slice(&extend);
        self.nullifySymForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i64 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifySymForBranch = if let Some((len, table)) =
            TablenullifySymForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let IPRelativeIndexedTarget = if let Some((len, table)) =
            TableIPRelativeIndexedTarget::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2dst,
                nullifySymForBranch,
                RR,
                IPRelativeIndexedTarget,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:762:1"]
#[derive(Clone, Debug)]
struct instructionVar139 {
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget3W: TablebranchTarget3W,
}
impl instructionVar139 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("B"),
            DisplayElement::Literal(",GATE"),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.branchTarget3W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i64 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget3W = if let Some((len, table)) =
            TablebranchTarget3W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2dst,
                nullifyForBranch,
                branchTarget3W,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:776:1"]
#[derive(Clone, Debug)]
struct instructionVar140 {
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget3W: TablebranchTarget3W,
}
impl instructionVar140 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("B"),
            DisplayElement::Literal(",GATE"),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.branchTarget3W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 58i64 {
            return None;
        }
        if token_parser.TokenFieldc().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget3W = if let Some((len, table)) =
            TablebranchTarget3W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2dst,
                nullifyForBranch,
                branchTarget3W,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:272:1"]
#[derive(Clone, Debug)]
struct instructionVar141 {
    RegCSCondSym: TokenField_RegCSCondSym,
    R1: TableR1,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    RegCSCond: TableRegCSCond,
}
impl instructionVar141 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPBT"),
            self.RegCSCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 32i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCond = if let Some((len, table)) = TableRegCSCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_parser.TokenFieldRegCSCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                nullifyForBranch,
                branchTarget2W,
                RegCSCond,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:285:2"]
#[derive(Clone, Debug)]
struct instructionVar142 {
    RegCSCondSym: TokenField_RegCSCondSym,
    R1: TableR1,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
    RegCSCond: TableRegCSCond,
}
impl instructionVar142 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPBT"),
            self.RegCSCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 32i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCond = if let Some((len, table)) = TableRegCSCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_parser.TokenFieldRegCSCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                nullifyForBranch,
                branchTarget2W,
                displacement2W,
                RegCSCond,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:299:1"]
#[derive(Clone, Debug)]
struct instructionVar143 {
    RegCSCondSym: TokenField_RegCSCondSym,
    R1: TableR1,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    RegCSCond: TableRegCSCond,
}
impl instructionVar143 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPBF"),
            self.RegCSCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 34i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCond = if let Some((len, table)) = TableRegCSCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_parser.TokenFieldRegCSCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                nullifyForBranch,
                branchTarget2W,
                RegCSCond,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:312:1"]
#[derive(Clone, Debug)]
struct instructionVar144 {
    RegCSCondSym: TokenField_RegCSCondSym,
    R1: TableR1,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
    RegCSCond: TableRegCSCond,
}
impl instructionVar144 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPBF"),
            self.RegCSCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 34i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCond = if let Some((len, table)) = TableRegCSCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_parser.TokenFieldRegCSCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                nullifyForBranch,
                branchTarget2W,
                displacement2W,
                RegCSCond,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:329:1"]
#[derive(Clone, Debug)]
struct instructionVar145 {
    RegCSCondSym: TokenField_RegCSCondSym,
    highlse5: Tablehighlse5,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    RegCSCondI: TableRegCSCondI,
}
impl instructionVar145 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPIBT"),
            self.RegCSCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 33i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondI = if let Some((len, table)) = TableRegCSCondI::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_parser.TokenFieldRegCSCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                highlse5,
                R2,
                nullifyForBranch,
                branchTarget2W,
                RegCSCondI,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:342:1"]
#[derive(Clone, Debug)]
struct instructionVar146 {
    RegCSCondSym: TokenField_RegCSCondSym,
    highlse5: Tablehighlse5,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
    RegCSCondI: TableRegCSCondI,
}
impl instructionVar146 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPIBT"),
            self.RegCSCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 33i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondI = if let Some((len, table)) = TableRegCSCondI::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_parser.TokenFieldRegCSCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                highlse5,
                R2,
                nullifyForBranch,
                branchTarget2W,
                displacement2W,
                RegCSCondI,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:356:1"]
#[derive(Clone, Debug)]
struct instructionVar147 {
    RegCSCondSym: TokenField_RegCSCondSym,
    highlse5: Tablehighlse5,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    RegCSCondI: TableRegCSCondI,
}
impl instructionVar147 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPIBF"),
            self.RegCSCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 35i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondI = if let Some((len, table)) = TableRegCSCondI::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_parser.TokenFieldRegCSCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                highlse5,
                R2,
                nullifyForBranch,
                branchTarget2W,
                RegCSCondI,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:369:1"]
#[derive(Clone, Debug)]
struct instructionVar148 {
    RegCSCondSym: TokenField_RegCSCondSym,
    highlse5: Tablehighlse5,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
    RegCSCondI: TableRegCSCondI,
}
impl instructionVar148 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CMPIBF"),
            self.RegCSCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 35i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondI = if let Some((len, table)) = TableRegCSCondI::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegCSCondSym = token_parser.TokenFieldRegCSCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                highlse5,
                R2,
                nullifyForBranch,
                branchTarget2W,
                displacement2W,
                RegCSCondI,
                RegCSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:456:1"]
#[derive(Clone, Debug)]
struct instructionVar149 {
    SEDCondSym: TokenField_SEDCondSym,
    R2dst: TableR2dst,
    R1: TableR1,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    DepCond: TableDepCond,
}
impl instructionVar149 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOVB"), self.SEDCondSym.display()];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 50i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCond = if let Some((len, table)) = TableDepCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2dst,
                R1,
                nullifyForBranch,
                branchTarget2W,
                DepCond,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:472:1"]
#[derive(Clone, Debug)]
struct instructionVar150 {
    SEDCondSym: TokenField_SEDCondSym,
    R2dst: TableR2dst,
    R1: TableR1,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
    DepCond: TableDepCond,
}
impl instructionVar150 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOVB"), self.SEDCondSym.display()];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 50i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCond = if let Some((len, table)) = TableDepCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2dst,
                R1,
                nullifyForBranch,
                branchTarget2W,
                displacement2W,
                DepCond,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:493:1"]
#[derive(Clone, Debug)]
struct instructionVar151 {
    SEDCondSym: TokenField_SEDCondSym,
    im5: TokenField_im5,
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    DepCond: TableDepCond,
}
impl instructionVar151 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOVIB"), self.SEDCondSym.display()];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.im5.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 51i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCond = if let Some((len, table)) = TableDepCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let im5 = token_parser.TokenFieldim5();
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2dst,
                nullifyForBranch,
                branchTarget2W,
                DepCond,
                im5,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:509:1"]
#[derive(Clone, Debug)]
struct instructionVar152 {
    SEDCondSym: TokenField_SEDCondSym,
    im5: TokenField_im5,
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
    DepCond: TableDepCond,
}
impl instructionVar152 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("MOVIB"), self.SEDCondSym.display()];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.im5.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 51i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCond = if let Some((len, table)) = TableDepCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let im5 = token_parser.TokenFieldim5();
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2dst,
                nullifyForBranch,
                branchTarget2W,
                displacement2W,
                DepCond,
                im5,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:527:1"]
#[derive(Clone, Debug)]
struct instructionVar153 {
    RegAddCondSym: TokenField_RegAddCondSym,
    R1: TableR1,
    R2dst: TableR2dst,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    RegAddCond: TableRegAddCond,
}
impl instructionVar153 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDBT"),
            self.RegAddCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 40i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCond = if let Some((len, table)) = TableRegAddCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_parser.TokenFieldRegAddCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2dst,
                R2,
                nullifyForBranch,
                branchTarget2W,
                RegAddCond,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:542:1"]
#[derive(Clone, Debug)]
struct instructionVar154 {
    RegAddCondSym: TokenField_RegAddCondSym,
    R1: TableR1,
    R2dst: TableR2dst,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
    RegAddCond: TableRegAddCond,
}
impl instructionVar154 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDBT"),
            self.RegAddCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 40i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCond = if let Some((len, table)) = TableRegAddCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_parser.TokenFieldRegAddCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2dst,
                R2,
                nullifyForBranch,
                branchTarget2W,
                displacement2W,
                RegAddCond,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:560:1"]
#[derive(Clone, Debug)]
struct instructionVar155 {
    RegAddCondSym: TokenField_RegAddCondSym,
    R1: TableR1,
    R2dst: TableR2dst,
    R2: TableR2,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    RegAddCond: TableRegAddCond,
}
impl instructionVar155 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDBF"),
            self.RegAddCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 42i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCond = if let Some((len, table)) = TableRegAddCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_parser.TokenFieldRegAddCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2dst,
                R2,
                nullifyForBranch,
                branchTarget2W,
                RegAddCond,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:575:1"]
#[derive(Clone, Debug)]
struct instructionVar156 {
    RegAddCondSym: TokenField_RegAddCondSym,
    R1: TableR1,
    R2: TableR2,
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
    RegAddCond: TableRegAddCond,
}
impl instructionVar156 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDBF"),
            self.RegAddCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 42i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCond = if let Some((len, table)) = TableRegAddCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_parser.TokenFieldRegAddCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                R2dst,
                nullifyForBranch,
                branchTarget2W,
                displacement2W,
                RegAddCond,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:592:1"]
#[derive(Clone, Debug)]
struct instructionVar157 {
    RegAddCondSym: TokenField_RegAddCondSym,
    highlse5: Tablehighlse5,
    R2: TableR2,
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    RegAddCondI: TableRegAddCondI,
}
impl instructionVar157 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDIBT"),
            self.RegAddCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 41i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondI = if let Some((len, table)) = TableRegAddCondI::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_parser.TokenFieldRegAddCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                highlse5,
                R2,
                R2dst,
                nullifyForBranch,
                branchTarget2W,
                RegAddCondI,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:607:1"]
#[derive(Clone, Debug)]
struct instructionVar158 {
    RegAddCondSym: TokenField_RegAddCondSym,
    highlse5: Tablehighlse5,
    R2: TableR2,
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
    RegAddCondI: TableRegAddCondI,
}
impl instructionVar158 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDIBT"),
            self.RegAddCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 41i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondI = if let Some((len, table)) = TableRegAddCondI::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_parser.TokenFieldRegAddCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                highlse5,
                R2,
                R2dst,
                nullifyForBranch,
                branchTarget2W,
                displacement2W,
                RegAddCondI,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:623:1"]
#[derive(Clone, Debug)]
struct instructionVar159 {
    RegAddCondSym: TokenField_RegAddCondSym,
    highlse5: Tablehighlse5,
    R2: TableR2,
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    RegAddCondI: TableRegAddCondI,
}
impl instructionVar159 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDIBF"),
            self.RegAddCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 43i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondI = if let Some((len, table)) = TableRegAddCondI::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_parser.TokenFieldRegAddCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                highlse5,
                R2,
                R2dst,
                nullifyForBranch,
                branchTarget2W,
                RegAddCondI,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:638:1"]
#[derive(Clone, Debug)]
struct instructionVar160 {
    RegAddCondSym: TokenField_RegAddCondSym,
    highlse5: Tablehighlse5,
    R2: TableR2,
    R2dst: TableR2dst,
    nullifyForBranch: TablenullifyForBranch,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
    RegAddCondI: TableRegAddCondI,
}
impl instructionVar160 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDIBF"),
            self.RegAddCondSym.display(),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 43i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondI = if let Some((len, table)) = TableRegAddCondI::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RegAddCondSym = token_parser.TokenFieldRegAddCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                highlse5,
                R2,
                R2dst,
                nullifyForBranch,
                branchTarget2W,
                displacement2W,
                RegAddCondI,
                RegAddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:655:1"]
#[derive(Clone, Debug)]
struct instructionVar161 {
    SEDCondSym: TokenField_SEDCondSym,
    branchTarget2W: TablebranchTarget2W,
    nullifyForBranch: TablenullifyForBranch,
    R1: TableR1,
    BVBCond: TableBVBCond,
    SAR: TableSAR,
}
impl instructionVar161 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BB"), self.SEDCondSym.display()];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 48i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BVBCond = if let Some((len, table)) = TableBVBCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                branchTarget2W,
                nullifyForBranch,
                R1,
                BVBCond,
                SAR,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:668:1"]
#[derive(Clone, Debug)]
struct instructionVar162 {
    SEDCondSym: TokenField_SEDCondSym,
    branchTarget2W: TablebranchTarget2W,
    nullifyForBranch: TablenullifyForBranch,
    displacement2W: Tabledisplacement2W,
    R1: TableR1,
    BVBCond: TableBVBCond,
    SAR: TableSAR,
}
impl instructionVar162 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BB"), self.SEDCondSym.display()];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SAR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 48i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BVBCond = if let Some((len, table)) = TableBVBCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SAR = if let Some((len, table)) =
            TableSAR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                branchTarget2W,
                nullifyForBranch,
                displacement2W,
                R1,
                BVBCond,
                SAR,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:683:1"]
#[derive(Clone, Debug)]
struct instructionVar163 {
    SEDCondSym: TokenField_SEDCondSym,
    bboffset: TokenField_bboffset,
    branchTarget2W: TablebranchTarget2W,
    nullifyForBranch: TablenullifyForBranch,
    R1: TableR1,
    BBCond: TableBBCond,
}
impl instructionVar163 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BB"), self.SEDCondSym.display()];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            self.bboffset.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 49i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BBCond = if let Some((len, table)) = TableBBCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        let bboffset = token_parser.TokenFieldbboffset();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                branchTarget2W,
                nullifyForBranch,
                R1,
                BBCond,
                SEDCondSym,
                bboffset,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:696:1"]
#[derive(Clone, Debug)]
struct instructionVar164 {
    SEDCondSym: TokenField_SEDCondSym,
    bboffset: TokenField_bboffset,
    branchTarget2W: TablebranchTarget2W,
    displacement2W: Tabledisplacement2W,
    nullifyForBranch: TablenullifyForBranch,
    R1: TableR1,
    BBCond: TableBBCond,
}
impl instructionVar164 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BB"), self.SEDCondSym.display()];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            self.bboffset.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.branchTarget2W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 49i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 2i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let branchTarget2W = if let Some((len, table)) =
            TablebranchTarget2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement2W = if let Some((len, table)) =
            Tabledisplacement2W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BBCond = if let Some((len, table)) = TableBBCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        let bboffset = token_parser.TokenFieldbboffset();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                branchTarget2W,
                displacement2W,
                nullifyForBranch,
                R1,
                BBCond,
                SEDCondSym,
                bboffset,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:716:1"]
#[derive(Clone, Debug)]
struct instructionVar165 {
    nullifyForBranch: TablenullifyForBranch,
    externalTarget: TableexternalTarget,
    SR3bit: TableSR3bit,
}
impl instructionVar165 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("BE")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.externalTarget.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 56i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 4i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let externalTarget = if let Some((len, table)) =
            TableexternalTarget::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                nullifyForBranch,
                externalTarget,
                SR3bit,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:731:1"]
#[derive(Clone, Debug)]
struct instructionVar166 {
    nullifyForBranch: TablenullifyForBranch,
    externalTarget: TableexternalTarget,
    SR3bit: TableSR3bit,
}
impl instructionVar166 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("BE")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.externalTarget.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 56i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let externalTarget = if let Some((len, table)) =
            TableexternalTarget::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                nullifyForBranch,
                externalTarget,
                SR3bit,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:737:1"]
#[derive(Clone, Debug)]
struct instructionVar167 {
    nullifyForBranch: TablenullifyForBranch,
    SR0: TableSR0,
    R31: TableR31,
    SR3bit: TableSR3bit,
    externalTarget: TableexternalTarget,
}
impl instructionVar167 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_branchEnable(
            Some(inst_next),
            context.register().read_branchEnable_disassembly(),
        );
        global_set.set_branchType(
            Some(inst_next),
            context.register().read_branchType_disassembly(),
        );
        global_set.set_branchCouldBeNullified(
            Some(inst_next),
            context.register().read_branchCouldBeNullified_disassembly(),
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BE"), DisplayElement::Literal(",L")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.externalTarget.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SR0.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R31.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 57i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_branchEnable_disassembly(tmp);
        let tmp = 5i64;
        context_instance
            .register_mut()
            .write_branchType_disassembly(tmp);
        let tmp = context_instance.register().read_nullifyEnable_disassembly();
        context_instance
            .register_mut()
            .write_branchCouldBeNullified_disassembly(tmp);
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR0 = if let Some((len, table)) =
            TableSR0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R31 = if let Some((len, table)) =
            TableR31::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let externalTarget = if let Some((len, table)) =
            TableexternalTarget::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                nullifyForBranch,
                SR0,
                R31,
                SR3bit,
                externalTarget,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:754:1"]
#[derive(Clone, Debug)]
struct instructionVar168 {
    nullifyForBranch: TablenullifyForBranch,
    SR0: TableSR0,
    R31: TableR31,
    SR3bit: TableSR3bit,
    externalTarget: TableexternalTarget,
}
impl instructionVar168 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("BE"), DisplayElement::Literal(",L")];
        display.extend_from_slice(&extend);
        self.nullifyForBranch.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.externalTarget.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.SR0.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R31.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 57i64 {
            return None;
        }
        if token_parser.TokenFieldn().disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let nullifyForBranch = if let Some((len, table)) =
            TablenullifyForBranch::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR0 = if let Some((len, table)) =
            TableSR0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R31 = if let Some((len, table)) =
            TableR31::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let externalTarget = if let Some((len, table)) =
            TableexternalTarget::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                nullifyForBranch,
                SR0,
                R31,
                SR3bit,
                externalTarget,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:790:1"]
#[derive(Clone, Debug)]
struct instructionVar169 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
    AddCondSym: TableAddCondSym,
}
impl instructionVar169 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ADD")];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 24i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondNullify,
                AddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:797:1"]
#[derive(Clone, Debug)]
struct instructionVar170 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
    AddCondSym: TableAddCondSym,
}
impl instructionVar170 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADD"),
            DisplayElement::Literal(",L"),
        ];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 40i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondNullify,
                AddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:802:1"]
#[derive(Clone, Debug)]
struct instructionVar171 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondSym: TableAddCondSym,
    AddCondNullify: TableAddCondNullify,
}
impl instructionVar171 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ADDO")];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 56i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondSym,
                AddCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:813:1"]
#[derive(Clone, Debug)]
struct instructionVar172 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondSym: TableAddCondSym,
    AddCondNullify: TableAddCondNullify,
}
impl instructionVar172 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADD"),
            DisplayElement::Literal(",C"),
        ];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 28i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondSym,
                AddCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:821:1"]
#[derive(Clone, Debug)]
struct instructionVar173 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondSym: TableAddCondSym,
    AddCondNullify: TableAddCondNullify,
}
impl instructionVar173 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADD"),
            DisplayElement::Literal(",CO"),
        ];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 60i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondSym,
                AddCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:840:1"]
#[derive(Clone, Debug)]
struct instructionVar174 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCond: TableAddCond,
    AddCondSym: TableAddCondSym,
    AddCondNullify: TableAddCondNullify,
}
impl instructionVar174 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("SH1ADD")];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 25i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCond = if let Some((len, table)) = TableAddCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCond,
                AddCondSym,
                AddCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:847:1"]
#[derive(Clone, Debug)]
struct instructionVar175 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
    AddCondSym: TableAddCondSym,
}
impl instructionVar175 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("SH1ADDL")];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 41i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondNullify,
                AddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:853:1"]
#[derive(Clone, Debug)]
struct instructionVar176 {
    SEDCondSym: TokenField_SEDCondSym,
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
}
impl instructionVar176 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("SH1ADDO"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 57i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondNullify,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:865:1"]
#[derive(Clone, Debug)]
struct instructionVar177 {
    SEDCondSym: TokenField_SEDCondSym,
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
}
impl instructionVar177 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("SH2ADD"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 26i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondNullify,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:872:1"]
#[derive(Clone, Debug)]
struct instructionVar178 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
    AddCondSym: TableAddCondSym,
}
impl instructionVar178 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("SH2ADDL")];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 42i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondNullify,
                AddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:878:1"]
#[derive(Clone, Debug)]
struct instructionVar179 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
    AddCondSym: TableAddCondSym,
}
impl instructionVar179 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("SH2ADDO")];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 58i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondNullify,
                AddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:890:1"]
#[derive(Clone, Debug)]
struct instructionVar180 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
    AddCondSym: TableAddCondSym,
}
impl instructionVar180 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("SH3ADD")];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 27i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondNullify,
                AddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:897:1"]
#[derive(Clone, Debug)]
struct instructionVar181 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
    AddCondSym: TableAddCondSym,
}
impl instructionVar181 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("SH3ADDL")];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 43i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondNullify,
                AddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:903:1"]
#[derive(Clone, Debug)]
struct instructionVar182 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    AddCondNullify: TableAddCondNullify,
    AddCondSym: TableAddCondSym,
}
impl instructionVar182 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("SH3ADDO")];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 59i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondNullify = if let Some((len, table)) =
            TableAddCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                AddCondNullify,
                AddCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:915:1"]
#[derive(Clone, Debug)]
struct instructionVar183 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    CSCondSym: TableCSCondSym,
    CSCondNullify: TableCSCondNullify,
}
impl instructionVar183 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("SUB")];
        display.extend_from_slice(&extend);
        self.CSCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 16i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) = TableCSCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondNullify = if let Some((len, table)) =
            TableCSCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                CSCondSym,
                CSCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:921:1"]
#[derive(Clone, Debug)]
struct instructionVar184 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    CSCondSym: TableCSCondSym,
    CSCondNullify: TableCSCondNullify,
}
impl instructionVar184 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUB"),
            DisplayElement::Literal(",O"),
        ];
        display.extend_from_slice(&extend);
        self.CSCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 48i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) = TableCSCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondNullify = if let Some((len, table)) =
            TableCSCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                CSCondSym,
                CSCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:932:1"]
#[derive(Clone, Debug)]
struct instructionVar185 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    CSCondSym: TableCSCondSym,
    CSCondNullify: TableCSCondNullify,
}
impl instructionVar185 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUB"),
            DisplayElement::Literal(",B"),
        ];
        display.extend_from_slice(&extend);
        self.CSCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 20i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) = TableCSCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondNullify = if let Some((len, table)) =
            TableCSCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                CSCondSym,
                CSCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:939:1"]
#[derive(Clone, Debug)]
struct instructionVar186 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    CSCondSym: TableCSCondSym,
    CSCondNullify: TableCSCondNullify,
}
impl instructionVar186 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUB"),
            DisplayElement::Literal(",BO"),
        ];
        display.extend_from_slice(&extend);
        self.CSCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 52i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) = TableCSCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondNullify = if let Some((len, table)) =
            TableCSCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                CSCondSym,
                CSCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:953:1"]
#[derive(Clone, Debug)]
struct instructionVar187 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    CSCondSym: TableCSCondSym,
    CSCond: TableCSCond,
}
impl instructionVar187 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUB"),
            DisplayElement::Literal(",T"),
        ];
        display.extend_from_slice(&extend);
        self.CSCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) = TableCSCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCond = if let Some((len, table)) = TableCSCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                CSCondSym,
                CSCond,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:964:1"]
#[derive(Clone, Debug)]
struct instructionVar188 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    CSCondSym: TableCSCondSym,
    CSCond: TableCSCond,
}
impl instructionVar188 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUB"),
            DisplayElement::Literal(",TO"),
        ];
        display.extend_from_slice(&extend);
        self.CSCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 51i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) = TableCSCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCond = if let Some((len, table)) = TableCSCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                CSCondSym,
                CSCond,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:977:1"]
#[derive(Clone, Debug)]
struct instructionVar189 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    CSCondSym: TableCSCondSym,
    CSCondNullify: TableCSCondNullify,
}
impl instructionVar189 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("DS")];
        display.extend_from_slice(&extend);
        self.CSCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 17i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) = TableCSCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondNullify = if let Some((len, table)) =
            TableCSCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                CSCondSym,
                CSCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1000:1"]
#[derive(Clone, Debug)]
struct instructionVar190 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    CSCondSym: TableCSCondSym,
    CSCondNullify: TableCSCondNullify,
}
impl instructionVar190 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("CMPCLR")];
        display.extend_from_slice(&extend);
        self.CSCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 34i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) = TableCSCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondNullify = if let Some((len, table)) =
            TableCSCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                CSCondSym,
                CSCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1014:1"]
#[derive(Clone, Debug)]
struct instructionVar191 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    LogicCondSym: TableLogicCondSym,
    LogicCondNullify: TableLogicCondNullify,
}
impl instructionVar191 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("OR")];
        display.extend_from_slice(&extend);
        self.LogicCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let LogicCondSym = if let Some((len, table)) = TableLogicCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let LogicCondNullify = if let Some((len, table)) =
            TableLogicCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                LogicCondSym,
                LogicCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1019:1"]
#[derive(Clone, Debug)]
struct instructionVar192 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    LogicCondSym: TableLogicCondSym,
    LogicCondNullify: TableLogicCondNullify,
}
impl instructionVar192 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("XOR")];
        display.extend_from_slice(&extend);
        self.LogicCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 10i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let LogicCondSym = if let Some((len, table)) = TableLogicCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let LogicCondNullify = if let Some((len, table)) =
            TableLogicCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                LogicCondSym,
                LogicCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1024:1"]
#[derive(Clone, Debug)]
struct instructionVar193 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    LogicCondSym: TableLogicCondSym,
    LogicCondNullify: TableLogicCondNullify,
}
impl instructionVar193 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("AND")];
        display.extend_from_slice(&extend);
        self.LogicCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 8i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let LogicCondSym = if let Some((len, table)) = TableLogicCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let LogicCondNullify = if let Some((len, table)) =
            TableLogicCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                LogicCondSym,
                LogicCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1029:1"]
#[derive(Clone, Debug)]
struct instructionVar194 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    LogicCondSym: TableLogicCondSym,
    LogicCondNullify: TableLogicCondNullify,
}
impl instructionVar194 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ANDCM")];
        display.extend_from_slice(&extend);
        self.LogicCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let LogicCondSym = if let Some((len, table)) = TableLogicCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let LogicCondNullify = if let Some((len, table)) =
            TableLogicCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                LogicCondSym,
                LogicCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1034:1"]
#[derive(Clone, Debug)]
struct instructionVar195 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    UnitCondSym: TableUnitCondSym,
    UnitCondNullify: TableUnitCondNullify,
}
impl instructionVar195 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("UXOR")];
        display.extend_from_slice(&extend);
        self.UnitCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 14i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UnitCondSym = if let Some((len, table)) = TableUnitCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UnitCondNullify = if let Some((len, table)) =
            TableUnitCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                UnitCondSym,
                UnitCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1039:1"]
#[derive(Clone, Debug)]
struct instructionVar196 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    UnitCondSym: TableUnitCondSym,
    UnitCondNullify: TableUnitCondNullify,
}
impl instructionVar196 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("UADDCM")];
        display.extend_from_slice(&extend);
        self.UnitCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 38i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UnitCondSym = if let Some((len, table)) = TableUnitCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UnitCondNullify = if let Some((len, table)) =
            TableUnitCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                UnitCondSym,
                UnitCondNullify,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1045:1"]
#[derive(Clone, Debug)]
struct instructionVar197 {
    R1: TableR1,
    R2: TableR2,
    RT: TableRT,
    UnitCond: TableUnitCond,
    UnitCondSym: TableUnitCondSym,
}
impl instructionVar197 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("UADDCMT")];
        display.extend_from_slice(&extend);
        self.UnitCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 39i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UnitCond = if let Some((len, table)) = TableUnitCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UnitCondSym = if let Some((len, table)) = TableUnitCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R1,
                R2,
                RT,
                UnitCond,
                UnitCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1717:1"]
#[derive(Clone, Debug)]
struct instructionVar198 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl instructionVar198 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FCPY"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldfreg1().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 1i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1721:1"]
#[derive(Clone, Debug)]
struct instructionVar199 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl instructionVar199 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FCPY"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldfreg1().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 0i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1776:1"]
#[derive(Clone, Debug)]
struct instructionVar200 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
    FPR164: TableFPR164,
}
impl instructionVar200 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FMPY"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldbit8().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 0i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg1sgl = token_parser.TokenFieldfreg1sgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                FPR164,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1780:1"]
#[derive(Clone, Debug)]
struct instructionVar201 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
    FPR164: TableFPR164,
}
impl instructionVar201 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FMPY"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldbit8().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 1i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg1sgl = token_parser.TokenFieldfreg1sgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                FPR164,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1752:1"]
#[derive(Clone, Debug)]
struct instructionVar202 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
    FPR164: TableFPR164,
}
impl instructionVar202 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FADD"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 0i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        let freg1sgl = token_parser.TokenFieldfreg1sgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        let fptsgl = token_parser.TokenFieldfptsgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                FPR164,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1756:1"]
#[derive(Clone, Debug)]
struct instructionVar203 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
    FPR164: TableFPR164,
}
impl instructionVar203 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FADD"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 1i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        let freg1sgl = token_parser.TokenFieldfreg1sgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        let fptsgl = token_parser.TokenFieldfptsgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                FPR164,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1764:1"]
#[derive(Clone, Debug)]
struct instructionVar204 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
    FPR164: TableFPR164,
}
impl instructionVar204 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FSUB"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 0i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg1sgl = token_parser.TokenFieldfreg1sgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                FPR164,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1768:1"]
#[derive(Clone, Debug)]
struct instructionVar205 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
    FPR164: TableFPR164,
}
impl instructionVar205 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FSUB"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 1i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg1sgl = token_parser.TokenFieldfreg1sgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                FPR164,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1788:1"]
#[derive(Clone, Debug)]
struct instructionVar206 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
    FPR164: TableFPR164,
}
impl instructionVar206 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FDIV"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 0i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg1sgl = token_parser.TokenFieldfreg1sgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                FPR164,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1792:1"]
#[derive(Clone, Debug)]
struct instructionVar207 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
    FPR164: TableFPR164,
}
impl instructionVar207 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FDIV"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 1i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        let fptsgl = token_parser.TokenFieldfptsgl();
        let freg1sgl = token_parser.TokenFieldfreg1sgl();
        let freg2sgl = token_parser.TokenFieldfreg2sgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                FPR164,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1848:1"]
#[derive(Clone, Debug)]
struct instructionVar208 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPR164: TableFPR164,
    fpcmp: Tablefpcmp,
}
impl instructionVar208 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("FCMP"), self.fpfmt.display()];
        display.extend_from_slice(&extend);
        self.fpcmp.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 0i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpcmp = if let Some((len, table)) =
            Tablefpcmp::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPR164,
                fpcmp,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1857:1"]
#[derive(Clone, Debug)]
struct instructionVar209 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPR164: TableFPR164,
    fpcmp64: Tablefpcmp64,
}
impl instructionVar209 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("FCMP"), self.fpfmt.display()];
        display.extend_from_slice(&extend);
        self.fpcmp64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsfraw().disassembly() != 1i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpcmp64 = if let Some((len, table)) = Tablefpcmp64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPR164,
                fpcmp64,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1136:1"]
#[derive(Clone, Debug)]
struct instructionVar210 {
    SEDCondSym: TokenField_SEDCondSym,
    R2: TableR2,
    R1: TableR1,
    shiftC: TableshiftC,
    RT: TableRT,
    ShiftCondNullify: TableShiftCondNullify,
}
impl instructionVar210 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("SHRPW"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 52i64 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 2i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftC = if let Some((len, table)) = TableshiftC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ShiftCondNullify = if let Some((len, table)) =
            TableShiftCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                R1,
                shiftC,
                RT,
                ShiftCondNullify,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1167:1"]
#[derive(Clone, Debug)]
struct instructionVar211 {
    SEDCondSym: TokenField_SEDCondSym,
    cp: TokenField_cp,
    R2: TableR2,
    shiftCLen: TableshiftCLen,
    R1dst: TableR1dst,
    ExtrCondNullify: TableExtrCondNullify,
    shiftC: TableshiftC,
}
impl instructionVar211 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("EXTRW"),
            DisplayElement::Literal(",U"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            self.cp.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 52i64 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 6i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ExtrCondNullify = if let Some((len, table)) =
            TableExtrCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftC = if let Some((len, table)) = TableshiftC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let cp = token_parser.TokenFieldcp();
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                shiftCLen,
                R1dst,
                ExtrCondNullify,
                shiftC,
                cp,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1177:1"]
#[derive(Clone, Debug)]
struct instructionVar212 {
    SEDCondSym: TokenField_SEDCondSym,
    cp: TokenField_cp,
    R2: TableR2,
    shiftC: TableshiftC,
    shiftCLen: TableshiftCLen,
    R1dst: TableR1dst,
    ExtrCondNullify: TableExtrCondNullify,
}
impl instructionVar212 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("EXTRW"),
            DisplayElement::Literal(",S"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            self.cp.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 52i64 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 7i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftC = if let Some((len, table)) = TableshiftC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let ExtrCondNullify = if let Some((len, table)) =
            TableExtrCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let cp = token_parser.TokenFieldcp();
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                shiftC,
                shiftCLen,
                R1dst,
                ExtrCondNullify,
                cp,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1201:1"]
#[derive(Clone, Debug)]
struct instructionVar213 {
    SEDCondSym: TokenField_SEDCondSym,
    shiftC: TableshiftC,
    shiftCLen: TableshiftCLen,
    R1: TableR1,
    R2: TableR2,
    R2dst: TableR2dst,
    DepCondNullify: TableDepCondNullify,
}
impl instructionVar213 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("DEPW"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 53i64 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 3i64 {
            return None;
        }
        let shiftC = if let Some((len, table)) = TableshiftC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        let cp = token_parser.TokenFieldcp();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shiftC,
                shiftCLen,
                R1,
                R2,
                R2dst,
                DepCondNullify,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1229:1"]
#[derive(Clone, Debug)]
struct instructionVar214 {
    SEDCondSym: TokenField_SEDCondSym,
    shiftC: TableshiftC,
    highlse5: Tablehighlse5,
    R2: TableR2,
    R2dst: TableR2dst,
    shiftCLen: TableshiftCLen,
    DepCondNullify: TableDepCondNullify,
}
impl instructionVar214 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("DEPWI"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 53i64 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 7i64 {
            return None;
        }
        let shiftC = if let Some((len, table)) = TableshiftC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        let cp = token_parser.TokenFieldcp();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shiftC,
                highlse5,
                R2,
                R2dst,
                shiftCLen,
                DepCondNullify,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1253:1"]
#[derive(Clone, Debug)]
struct instructionVar215 {
    SEDCondSym: TokenField_SEDCondSym,
    shiftC: TableshiftC,
    R2: TableR2,
    R2dst: TableR2dst,
    shiftCLen: TableshiftCLen,
    R1: TableR1,
    DepCondNullify: TableDepCondNullify,
}
impl instructionVar215 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("DEPW"),
            DisplayElement::Literal(",Z"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 53i64 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 2i64 {
            return None;
        }
        let shiftC = if let Some((len, table)) = TableshiftC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        let cp = token_parser.TokenFieldcp();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shiftC,
                R2,
                R2dst,
                shiftCLen,
                R1,
                DepCondNullify,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1274:1"]
#[derive(Clone, Debug)]
struct instructionVar216 {
    SEDCondSym: TokenField_SEDCondSym,
    shiftC: TableshiftC,
    highlse5: Tablehighlse5,
    R2dst: TableR2dst,
    shiftCLen: TableshiftCLen,
    DepCondNullify: TableDepCondNullify,
}
impl instructionVar216 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("DEPWI"),
            DisplayElement::Literal(",Z"),
            self.SEDCondSym.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.shiftCLen.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 53i64 {
            return None;
        }
        if token_parser.TokenFieldsubop1012().disassembly() != 6i64 {
            return None;
        }
        let shiftC = if let Some((len, table)) = TableshiftC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2dst = if let Some((len, table)) =
            TableR2dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shiftCLen = if let Some((len, table)) = TableshiftCLen::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DepCondNullify = if let Some((len, table)) =
            TableDepCondNullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SEDCondSym = token_parser.TokenFieldSEDCondSym();
        let cp = token_parser.TokenFieldcp();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shiftC,
                highlse5,
                R2dst,
                shiftCLen,
                DepCondNullify,
                SEDCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1287:1"]
#[derive(Clone, Debug)]
struct instructionVar217 {
    R2: TableR2,
    RT: TableRT,
    UnitCond: TableUnitCond,
    UnitCondSym: TableUnitCondSym,
}
impl instructionVar217 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("DCOR")];
        display.extend_from_slice(&extend);
        self.UnitCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 46i64 {
            return None;
        }
        if token_parser.TokenFieldreg1().disassembly() != 0i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UnitCond = if let Some((len, table)) = TableUnitCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UnitCondSym = if let Some((len, table)) = TableUnitCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                RT,
                UnitCond,
                UnitCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1288:1"]
#[derive(Clone, Debug)]
struct instructionVar218 {
    R2: TableR2,
    RT: TableRT,
    UnitCond: TableUnitCond,
    UnitCondSym: TableUnitCondSym,
}
impl instructionVar218 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("IDCOR")];
        display.extend_from_slice(&extend);
        self.UnitCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldop().disassembly() != 47i64 {
            return None;
        }
        if token_parser.TokenFieldreg1().disassembly() != 0i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UnitCond = if let Some((len, table)) = TableUnitCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UnitCondSym = if let Some((len, table)) = TableUnitCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                R2,
                RT,
                UnitCond,
                UnitCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1829:1"]
#[derive(Clone, Debug)]
struct instructionVar219 {
    fpfmt1bit: TokenField_fpfmt1bit,
    FPR232: TableFPR232,
    FPR132: TableFPR132,
    fpcmp: Tablefpcmp,
}
impl instructionVar219 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("FCMP"), self.fpfmt1bit.display()];
        display.extend_from_slice(&extend);
        self.fpcmp.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR132.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit11().disassembly() != 0i64 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpcmp = if let Some((len, table)) =
            Tablefpcmp::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt1bit = token_parser.TokenFieldfpfmt1bit();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPR132,
                fpcmp,
                fpfmt1bit,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1838:1"]
#[derive(Clone, Debug)]
struct instructionVar220 {
    fpfmt1bit: TokenField_fpfmt1bit,
    FPR232: TableFPR232,
    FPR132: TableFPR132,
    fpcmp64: Tablefpcmp64,
}
impl instructionVar220 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("FCMP"), self.fpfmt1bit.display()];
        display.extend_from_slice(&extend);
        self.fpcmp64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR132.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit11().disassembly() != 1i64 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpcmp64 = if let Some((len, table)) = Tablefpcmp64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt1bit = token_parser.TokenFieldfpfmt1bit();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPR132,
                fpcmp64,
                fpfmt1bit,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1054:1"]
#[derive(Clone, Debug)]
struct instructionVar221 {
    lse11: Tablelse11,
    R2: TableR2,
    R1dst: TableR1dst,
    AddCondSym: TableAddCondSym,
    AddCondI11Nullify: TableAddCondI11Nullify,
}
impl instructionVar221 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ADDI")];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 45i64 {
            return None;
        }
        if token_parser.TokenFieldbit11().disassembly() != 0i64 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondI11Nullify = if let Some((len, table)) =
            TableAddCondI11Nullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                lse11,
                R2,
                R1dst,
                AddCondSym,
                AddCondI11Nullify,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1062:1"]
#[derive(Clone, Debug)]
struct instructionVar222 {
    lse11: Tablelse11,
    R2: TableR2,
    R1dst: TableR1dst,
    AddCondSym: TableAddCondSym,
    AddCondI11Nullify: TableAddCondI11Nullify,
}
impl instructionVar222 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDI"),
            DisplayElement::Literal(",TSV"),
        ];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 45i64 {
            return None;
        }
        if token_parser.TokenFieldbit11().disassembly() != 1i64 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondI11Nullify = if let Some((len, table)) =
            TableAddCondI11Nullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                lse11,
                R2,
                R1dst,
                AddCondSym,
                AddCondI11Nullify,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1075:1"]
#[derive(Clone, Debug)]
struct instructionVar223 {
    lse11: Tablelse11,
    R2: TableR2,
    R1dst: TableR1dst,
    AddCondSym: TableAddCondSym,
    AddCondI11: TableAddCondI11,
}
impl instructionVar223 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDI"),
            DisplayElement::Literal(",TC"),
        ];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 44i64 {
            return None;
        }
        if token_parser.TokenFieldbit11().disassembly() != 0i64 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondI11 = if let Some((len, table)) = TableAddCondI11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                lse11,
                R2,
                R1dst,
                AddCondSym,
                AddCondI11,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1088:1"]
#[derive(Clone, Debug)]
struct instructionVar224 {
    lse11: Tablelse11,
    R2: TableR2,
    R1dst: TableR1dst,
    AddCondSym: TableAddCondSym,
    AddCondI11: TableAddCondI11,
}
impl instructionVar224 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDI"),
            DisplayElement::Literal(",TC,TSV"),
        ];
        display.extend_from_slice(&extend);
        self.AddCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 44i64 {
            return None;
        }
        if token_parser.TokenFieldbit11().disassembly() != 1i64 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondSym = if let Some((len, table)) = TableAddCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let AddCondI11 = if let Some((len, table)) = TableAddCondI11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                lse11,
                R2,
                R1dst,
                AddCondSym,
                AddCondI11,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1101:1"]
#[derive(Clone, Debug)]
struct instructionVar225 {
    lse11: Tablelse11,
    R2: TableR2,
    R1dst: TableR1dst,
    CSCondI11Nullify: TableCSCondI11Nullify,
    CSCondSym: TableCSCondSym,
}
impl instructionVar225 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("SUBI")];
        display.extend_from_slice(&extend);
        self.CSCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 37i64 {
            return None;
        }
        if token_parser.TokenFieldbit11().disassembly() != 0i64 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondI11Nullify = if let Some((len, table)) =
            TableCSCondI11Nullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) = TableCSCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                lse11,
                R2,
                R1dst,
                CSCondI11Nullify,
                CSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1108:1"]
#[derive(Clone, Debug)]
struct instructionVar226 {
    lse11: Tablelse11,
    R2: TableR2,
    R1dst: TableR1dst,
    CSCondI11: TableCSCondI11,
    CSCondSym: TableCSCondSym,
    CSCondI11Nullify: TableCSCondI11Nullify,
}
impl instructionVar226 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SUBI"),
            DisplayElement::Literal(",TSV"),
        ];
        display.extend_from_slice(&extend);
        self.CSCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 37i64 {
            return None;
        }
        if token_parser.TokenFieldbit11().disassembly() != 1i64 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondI11 = if let Some((len, table)) = TableCSCondI11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) = TableCSCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondI11Nullify = if let Some((len, table)) =
            TableCSCondI11Nullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                lse11,
                R2,
                R1dst,
                CSCondI11,
                CSCondSym,
                CSCondI11Nullify,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1120:1"]
#[derive(Clone, Debug)]
struct instructionVar227 {
    lse11: Tablelse11,
    R2: TableR2,
    R1dst: TableR1dst,
    CSCondI11Nullify: TableCSCondI11Nullify,
    CSCondSym: TableCSCondSym,
}
impl instructionVar227 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("CMPICLR")];
        display.extend_from_slice(&extend);
        self.CSCondSym.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse11.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 36i64 {
            return None;
        }
        if token_parser.TokenFieldbit11().disassembly() != 0i64 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondI11Nullify = if let Some((len, table)) =
            TableCSCondI11Nullify::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CSCondSym = if let Some((len, table)) = TableCSCondSym::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                lse11,
                R2,
                R1dst,
                CSCondI11Nullify,
                CSCondSym,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1729:1"]
#[derive(Clone, Debug)]
struct instructionVar228 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl instructionVar228 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FABS"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldfreg1().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbits59().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit10().disassembly() != 0i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1725:1"]
#[derive(Clone, Debug)]
struct instructionVar229 {
    fpfmt: TokenField_fpfmt,
    FPR232: TableFPR232,
    FPRT32: TableFPRT32,
}
impl instructionVar229 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FABS"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldfreg1().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit5().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit8().disassembly() != 0i64 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPRT32,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1713:1"]
#[derive(Clone, Debug)]
struct instructionVar230 {
    fpfmt: TokenField_fpfmt,
    FPR232: TableFPR232,
    FPRT32: TableFPRT32,
}
impl instructionVar230 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FCPY"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldfreg1().disassembly() != 0i64 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPRT32,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1733:1"]
#[derive(Clone, Debug)]
struct instructionVar231 {
    fpfmt: TokenField_fpfmt,
    FPR232: TableFPR232,
    FPRT32: TableFPRT32,
}
impl instructionVar231 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FSQRT"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldfreg1().disassembly() != 0i64 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPRT32,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1736:1"]
#[derive(Clone, Debug)]
struct instructionVar232 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl instructionVar232 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FSQRT"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldfreg1().disassembly() != 0i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1639:1"]
#[derive(Clone, Debug)]
struct instructionVar233 {
    fpsf: TokenField_fpsf,
    fpdf: TokenField_fpdf,
    FPR232: TableFPR232,
    FPRT32: TableFPRT32,
}
impl instructionVar233 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNV"),
            self.fpsf.display(),
            self.fpdf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i64 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpsf = token_parser.TokenFieldfpsf();
        let fpdf = token_parser.TokenFieldfpdf();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPRT32,
                fpsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1659:1"]
#[derive(Clone, Debug)]
struct instructionVar234 {
    fpsf: TokenField_fpsf,
    fpdf: TokenField_fpdf,
    FPR232: TableFPR232,
    FPRT32: TableFPRT32,
}
impl instructionVar234 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNVXF"),
            self.fpsf.display(),
            self.fpdf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i64 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpsf = token_parser.TokenFieldfpsf();
        let fpdf = token_parser.TokenFieldfpdf();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPRT32,
                fpsf,
                fpdf,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1681:1"]
#[derive(Clone, Debug)]
struct instructionVar235 {
    fpsf: TokenField_fpsf,
    fixeddf: TokenField_fixeddf,
    FPR232: TableFPR232,
    FPRT32: TableFPRT32,
}
impl instructionVar235 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNVFX"),
            self.fpsf.display(),
            self.fixeddf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i64 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpsf = token_parser.TokenFieldfpsf();
        let fixeddf = token_parser.TokenFieldfixeddf();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPRT32,
                fpsf,
                fixeddf,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1698:1"]
#[derive(Clone, Debug)]
struct instructionVar236 {
    fpsf: TokenField_fpsf,
    fixeddf: TokenField_fixeddf,
    FPR232: TableFPR232,
    FPRT32: TableFPRT32,
}
impl instructionVar236 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("FCNVFXT"),
            self.fpsf.display(),
            self.fixeddf.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldfpc1sub2().disassembly() != 0i64 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpsf = token_parser.TokenFieldfpsf();
        let fixeddf = token_parser.TokenFieldfixeddf();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPRT32,
                fpsf,
                fixeddf,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1772:1"]
#[derive(Clone, Debug)]
struct instructionVar237 {
    fpfmt: TokenField_fpfmt,
    FPR232: TableFPR232,
    FPR132: TableFPR132,
    FPRT32: TableFPRT32,
}
impl instructionVar237 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FMPY"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR132.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldbit8().disassembly() != 0i64 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPR132,
                FPRT32,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1820:1"]
#[derive(Clone, Debug)]
struct instructionVar238 {
    fpfmt: TokenField_fpfmt,
    FPR232: TableFPR232,
    FPR132: TableFPR132,
    FPRT64: TableFPRT64,
}
impl instructionVar238 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("XMPYU"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR132.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldbit8().disassembly() != 1i64 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        let fptsgl = token_parser.TokenFieldfptsgl();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPR132,
                FPRT64,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1740:1"]
#[derive(Clone, Debug)]
struct instructionVar239 {
    fpfmt: TokenField_fpfmt,
    FPR232: TableFPR232,
    FPRT32: TableFPRT32,
}
impl instructionVar239 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FRND"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 5i64 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPRT32,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1744:1"]
#[derive(Clone, Debug)]
struct instructionVar240 {
    fpfmt: TokenField_fpfmt,
    FPR264: TableFPR264,
    FPRT64: TableFPRT64,
}
impl instructionVar240 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FRND"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 5i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPRT64,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1748:1"]
#[derive(Clone, Debug)]
struct instructionVar241 {
    fpfmt: TokenField_fpfmt,
    FPR232: TableFPR232,
    FPR132: TableFPR132,
    FPRT32: TableFPRT32,
}
impl instructionVar241 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FADD"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR132.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 0i64 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPR132,
                FPRT32,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1760:1"]
#[derive(Clone, Debug)]
struct instructionVar242 {
    fpfmt: TokenField_fpfmt,
    FPR232: TableFPR232,
    FPR132: TableFPR132,
    FPRT32: TableFPRT32,
}
impl instructionVar242 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FSUB"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR132.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 1i64 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPR132,
                FPRT32,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1784:1"]
#[derive(Clone, Debug)]
struct instructionVar243 {
    fpfmt: TokenField_fpfmt,
    FPR232: TableFPR232,
    FPR132: TableFPR132,
    FPRT32: TableFPRT32,
}
impl instructionVar243 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FDIV"),
            self.fpfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR232.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR132.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 14i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 3i64 {
            return None;
        }
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fpfmt = token_parser.TokenFieldfpfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR232,
                FPR132,
                FPRT32,
                fpfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1866:1"]
#[derive(Clone, Debug)]
struct instructionVar244 {
    fptest: TokenField_fptest,
}
impl instructionVar244 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_nullifyEnable(
            Some(inst_next),
            context.register().read_nullifyEnable_disassembly(),
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("FTEST"), self.fptest.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldfpclass().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldfpsub().disassembly() != 1i64 {
            return None;
        }
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_nullifyEnable_disassembly(tmp);
        let fptest = token_parser.TokenFieldfptest();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fptest }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1452:1"]
#[derive(Clone, Debug)]
struct instructionVar245 {
    im15: TokenField_im15,
    im5: TokenField_im5,
    SFU: TableSFU,
    nullifyForSpecial: TablenullifyForSpecial,
}
impl instructionVar245 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut sop: i64 = 0;
        sop = (self
            .im15
            .disassembly()
            .checked_shl(u32::try_from(5i64).unwrap())
            .unwrap_or(0)
            | self.im5.disassembly());
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SPOP0"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.nullifyForSpecial.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Number(true, sop),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldspecop().disassembly() != 0i64 {
            return None;
        }
        let mut sop: i64 = 0;
        sop = (token_parser
            .TokenFieldim15()
            .disassembly()
            .checked_shl(u32::try_from(5i64).unwrap())
            .unwrap_or(0)
            | token_parser.TokenFieldim5().disassembly());
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForSpecial = if let Some((len, table)) =
            TablenullifyForSpecial::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let im5 = token_parser.TokenFieldim5();
        let im15 = token_parser.TokenFieldim15();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SFU,
                nullifyForSpecial,
                im5,
                im15,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1453:1"]
#[derive(Clone, Debug)]
struct instructionVar246 {
    sopim10: TokenField_sopim10,
    im5: TokenField_im5,
    SFU: TableSFU,
    nullifyForSpecial: TablenullifyForSpecial,
}
impl instructionVar246 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut sop: i64 = 0;
        sop = (self
            .sopim10
            .disassembly()
            .checked_shl(u32::try_from(5i64).unwrap())
            .unwrap_or(0)
            | self.im5.disassembly());
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SPOP1"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.nullifyForSpecial.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Number(true, sop),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldspecop().disassembly() != 1i64 {
            return None;
        }
        let mut sop: i64 = 0;
        sop = (token_parser
            .TokenFieldsopim10()
            .disassembly()
            .checked_shl(u32::try_from(5i64).unwrap())
            .unwrap_or(0)
            | token_parser.TokenFieldim5().disassembly());
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForSpecial = if let Some((len, table)) =
            TablenullifyForSpecial::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let im5 = token_parser.TokenFieldim5();
        let sopim10 = token_parser.TokenFieldsopim10();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SFU,
                nullifyForSpecial,
                im5,
                sopim10,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1454:1"]
#[derive(Clone, Debug)]
struct instructionVar247 {
    sopim5: TokenField_sopim5,
    im5: TokenField_im5,
    SFU: TableSFU,
    nullifyForSpecial: TablenullifyForSpecial,
    R2: TableR2,
}
impl instructionVar247 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut sop: i64 = 0;
        sop = (self
            .sopim5
            .disassembly()
            .checked_shl(u32::try_from(5i64).unwrap())
            .unwrap_or(0)
            | self.im5.disassembly());
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SPOP2"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.nullifyForSpecial.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Number(true, sop),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldspecop().disassembly() != 2i64 {
            return None;
        }
        let mut sop: i64 = 0;
        sop = (token_parser
            .TokenFieldsopim5()
            .disassembly()
            .checked_shl(u32::try_from(5i64).unwrap())
            .unwrap_or(0)
            | token_parser.TokenFieldim5().disassembly());
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForSpecial = if let Some((len, table)) =
            TablenullifyForSpecial::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let im5 = token_parser.TokenFieldim5();
        let sopim5 = token_parser.TokenFieldsopim5();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SFU,
                nullifyForSpecial,
                R2,
                im5,
                sopim5,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1455:1"]
#[derive(Clone, Debug)]
struct instructionVar248 {
    sopim5: TokenField_sopim5,
    im5: TokenField_im5,
    SFU: TableSFU,
    nullifyForSpecial: TablenullifyForSpecial,
    R1: TableR1,
    R2: TableR2,
}
impl instructionVar248 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut sop: i64 = 0;
        sop = (self
            .sopim5
            .disassembly()
            .checked_shl(u32::try_from(5i64).unwrap())
            .unwrap_or(0)
            | self.im5.disassembly());
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("SPOP3"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.nullifyForSpecial.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Number(true, sop),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldspecop().disassembly() != 3i64 {
            return None;
        }
        let mut sop: i64 = 0;
        sop = (token_parser
            .TokenFieldsopim5()
            .disassembly()
            .checked_shl(u32::try_from(5i64).unwrap())
            .unwrap_or(0)
            | token_parser.TokenFieldim5().disassembly());
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForSpecial = if let Some((len, table)) =
            TablenullifyForSpecial::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let im5 = token_parser.TokenFieldim5();
        let sopim5 = token_parser.TokenFieldsopim5();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SFU,
                nullifyForSpecial,
                R1,
                R2,
                im5,
                sopim5,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1475:1"]
#[derive(Clone, Debug)]
struct instructionVar249 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RX: TableRX,
    FPRT32: TableFPRT32,
    SPCBASE: TableSPCBASE,
}
impl instructionVar249 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDW")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                loadCC,
                SRRB,
                RX,
                FPRT32,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1480:1"]
#[derive(Clone, Debug)]
struct instructionVar250 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RX: TableRX,
    FPRT32: TableFPRT32,
    SPCBASE: TableSPCBASE,
}
impl instructionVar250 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDW")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                loadCC,
                SRRB,
                RX,
                FPRT32,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1485:1"]
#[derive(Clone, Debug)]
struct instructionVar251 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RX: TableRX,
    RB: TableRB,
    FPRT32: TableFPRT32,
    SPCBASE: TableSPCBASE,
}
impl instructionVar251 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDW")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                loadCC,
                SRRB,
                RX,
                RB,
                FPRT32,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1491:1"]
#[derive(Clone, Debug)]
struct instructionVar252 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RB: TableRB,
    RX: TableRX,
    FPRT32: TableFPRT32,
    SPCBASE: TableSPCBASE,
}
impl instructionVar252 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDW")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                loadCC,
                SRRB,
                RB,
                RX,
                FPRT32,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1522:1"]
#[derive(Clone, Debug)]
struct instructionVar253 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    RX: TableRX,
    FPRT32: TableFPRT32,
    SPCBASE: TableSPCBASE,
}
impl instructionVar253 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTW")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                storeCC,
                SRRB,
                RX,
                FPRT32,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1527:1"]
#[derive(Clone, Debug)]
struct instructionVar254 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    RX: TableRX,
    FPRT32: TableFPRT32,
    SPCBASE: TableSPCBASE,
}
impl instructionVar254 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTW")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                storeCC,
                SRRB,
                RX,
                FPRT32,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1532:1"]
#[derive(Clone, Debug)]
struct instructionVar255 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    RX: TableRX,
    RB: TableRB,
    FPRT32: TableFPRT32,
    SPCBASE: TableSPCBASE,
}
impl instructionVar255 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTW")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                storeCC,
                SRRB,
                RX,
                RB,
                FPRT32,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1538:1"]
#[derive(Clone, Debug)]
struct instructionVar256 {
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    RX: TableRX,
    RB: TableRB,
    FPRT32: TableFPRT32,
    SPCBASE: TableSPCBASE,
}
impl instructionVar256 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTW")];
        display.extend_from_slice(&extend);
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedWordAccessCmplt,
                storeCC,
                SRRB,
                RX,
                RB,
                FPRT32,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1544:1"]
#[derive(Clone, Debug)]
struct instructionVar257 {
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    RX: TableRX,
    FPRT64: TableFPRT64,
    SPCBASE: TableSPCBASE,
}
impl instructionVar257 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTD")];
        display.extend_from_slice(&extend);
        self.indexedDoublewordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedDoublewordAccessCmplt,
                storeCC,
                SRRB,
                RX,
                FPRT64,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1549:1"]
#[derive(Clone, Debug)]
struct instructionVar258 {
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    RX: TableRX,
    FPRT64: TableFPRT64,
    SPCBASE: TableSPCBASE,
}
impl instructionVar258 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTD")];
        display.extend_from_slice(&extend);
        self.indexedDoublewordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedDoublewordAccessCmplt,
                storeCC,
                SRRB,
                RX,
                FPRT64,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1554:1"]
#[derive(Clone, Debug)]
struct instructionVar259 {
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    RX: TableRX,
    RB: TableRB,
    FPRT64: TableFPRT64,
    SPCBASE: TableSPCBASE,
}
impl instructionVar259 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTD")];
        display.extend_from_slice(&extend);
        self.indexedDoublewordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedDoublewordAccessCmplt,
                storeCC,
                SRRB,
                RX,
                RB,
                FPRT64,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1560:1"]
#[derive(Clone, Debug)]
struct instructionVar260 {
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    RX: TableRX,
    RB: TableRB,
    FPRT64: TableFPRT64,
    SPCBASE: TableSPCBASE,
}
impl instructionVar260 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTD")];
        display.extend_from_slice(&extend);
        self.indexedDoublewordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexedDoublewordAccessCmplt,
                storeCC,
                SRRB,
                RX,
                RB,
                FPRT64,
                SPCBASE,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1574:1"]
#[derive(Clone, Debug)]
struct instructionVar261 {
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    FPRT32: TableFPRT32,
    RB: TableRB,
    highlse5: Tablehighlse5,
}
impl instructionVar261 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDW")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                loadCC,
                SRRB,
                SPCBASE,
                FPRT32,
                RB,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1581:1"]
#[derive(Clone, Debug)]
struct instructionVar262 {
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
    FPRT32: TableFPRT32,
    highlse5: Tablehighlse5,
}
impl instructionVar262 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDW")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                loadCC,
                SRRB,
                RB,
                SPCBASE,
                FPRT32,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1609:1"]
#[derive(Clone, Debug)]
struct instructionVar263 {
    shortDispCmplt: TableshortDispCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    RB: TableRB,
    FPRT32: TableFPRT32,
    highlse5: Tablehighlse5,
}
impl instructionVar263 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTW")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                storeCC,
                SRRB,
                SPCBASE,
                RB,
                FPRT32,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1615:1"]
#[derive(Clone, Debug)]
struct instructionVar264 {
    shortDispCmplt: TableshortDispCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    RB: TableRB,
    FPRT32: TableFPRT32,
    highlse5: Tablehighlse5,
}
impl instructionVar264 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTW")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                storeCC,
                SRRB,
                SPCBASE,
                RB,
                FPRT32,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1568:1"]
#[derive(Clone, Debug)]
struct instructionVar265 {
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    FPRT32: TableFPRT32,
    highlse5: Tablehighlse5,
}
impl instructionVar265 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FLDW")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                loadCC,
                SRRB,
                SPCBASE,
                FPRT32,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1604:1"]
#[derive(Clone, Debug)]
struct instructionVar266 {
    shortDispCmplt: TableshortDispCmplt,
    storeCC: TablestoreCC,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
    FPRT32: TableFPRT32,
    highlse5: Tablehighlse5,
}
impl instructionVar266 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("FSTW")];
        display.extend_from_slice(&extend);
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FPRT32.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldbits78().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT32 = if let Some((len, table)) = TableFPRT32::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shortDispCmplt,
                storeCC,
                SRRB,
                SPCBASE,
                FPRT32,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1458:1"]
#[derive(Clone, Debug)]
struct instructionVar267 {
    RX: TableRX,
    SRRB: TableSRRB,
    RT: TableRT,
    SFU: TableSFU,
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    loadCC: TableloadCC,
}
impl instructionVar267 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CLDW"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB,
                RT,
                SFU,
                indexedWordAccessCmplt,
                loadCC,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1459:1"]
#[derive(Clone, Debug)]
struct instructionVar268 {
    RX: TableRX,
    SRRB: TableSRRB,
    RT: TableRT,
    SFU: TableSFU,
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    loadCC: TableloadCC,
}
impl instructionVar268 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CLDD"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.indexedDoublewordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB,
                RT,
                SFU,
                indexedDoublewordAccessCmplt,
                loadCC,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1460:1"]
#[derive(Clone, Debug)]
struct instructionVar269 {
    RX: TableRX,
    SRRB: TableSRRB,
    RT: TableRT,
    SFU: TableSFU,
    indexedWordAccessCmplt: TableindexedWordAccessCmplt,
    storeCC: TablestoreCC,
}
impl instructionVar269 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CSTW"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.indexedWordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let indexedWordAccessCmplt = if let Some((len, table)) =
            TableindexedWordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB,
                RT,
                SFU,
                indexedWordAccessCmplt,
                storeCC,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1461:1"]
#[derive(Clone, Debug)]
struct instructionVar270 {
    RX: TableRX,
    SRRB: TableSRRB,
    RT: TableRT,
    SFU: TableSFU,
    indexedDoublewordAccessCmplt: TableindexedDoublewordAccessCmplt,
    storeCC: TablestoreCC,
}
impl instructionVar270 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CSTD"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.indexedDoublewordAccessCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RX.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldzero().disassembly() != 0i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let indexedDoublewordAccessCmplt = if let Some((len, table)) =
            TableindexedDoublewordAccessCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RX,
                SRRB,
                RT,
                SFU,
                indexedDoublewordAccessCmplt,
                storeCC,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1463:1"]
#[derive(Clone, Debug)]
struct instructionVar271 {
    SRRB: TableSRRB,
    RT: TableRT,
    SFU: TableSFU,
    highlse5: Tablehighlse5,
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
}
impl instructionVar271 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CLDW"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SRRB,
                RT,
                SFU,
                highlse5,
                shortDispCmplt,
                loadCC,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1464:1"]
#[derive(Clone, Debug)]
struct instructionVar272 {
    SRRB: TableSRRB,
    RT: TableRT,
    SFU: TableSFU,
    highlse5: Tablehighlse5,
    shortDispCmplt: TableshortDispCmplt,
    loadCC: TableloadCC,
}
impl instructionVar272 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CLDD"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.loadCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let loadCC = if let Some((len, table)) = TableloadCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SRRB,
                RT,
                SFU,
                highlse5,
                shortDispCmplt,
                loadCC,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1465:1"]
#[derive(Clone, Debug)]
struct instructionVar273 {
    SRRB: TableSRRB,
    RT: TableRT,
    SFU: TableSFU,
    highlse5: Tablehighlse5,
    shortDispCmplt: TableshortDispCmplt,
    storeCC: TablestoreCC,
}
impl instructionVar273 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CSTW"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 9i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SRRB,
                RT,
                SFU,
                highlse5,
                shortDispCmplt,
                storeCC,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1466:1"]
#[derive(Clone, Debug)]
struct instructionVar274 {
    SRRB: TableSRRB,
    RT: TableRT,
    SFU: TableSFU,
    highlse5: Tablehighlse5,
    shortDispCmplt: TableshortDispCmplt,
    storeCC: TablestoreCC,
}
impl instructionVar274 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("CSTD"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.shortDispCmplt.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.storeCC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.highlse5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldbit9().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldone().disassembly() != 1i64 {
            return None;
        }
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let shortDispCmplt = if let Some((len, table)) =
            TableshortDispCmplt::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let storeCC = if let Some((len, table)) = TablestoreCC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SRRB,
                RT,
                SFU,
                highlse5,
                shortDispCmplt,
                storeCC,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1797:1"]
#[derive(Clone, Debug)]
struct instructionVar275 {
    fusedfmt: TokenField_fusedfmt,
    fpra: TokenField_fpra,
    fpta: TokenField_fpta,
    FPR264: TableFPR264,
    FPR164: TableFPR164,
    FPRT64: TableFPRT64,
}
impl instructionVar275 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FMPYADD"),
            self.fusedfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            self.fpra.display(),
            DisplayElement::Literal(","),
            self.fpta.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 6i64 {
            return None;
        }
        if token_parser.TokenFieldbit5().disassembly() != 0i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fusedfmt = token_parser.TokenFieldfusedfmt();
        let fpra = token_parser.TokenFieldfpra();
        let fpta = token_parser.TokenFieldfpta();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPR164,
                FPRT64,
                fusedfmt,
                fpra,
                fpta,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1803:1"]
#[derive(Clone, Debug)]
struct instructionVar276 {
    fusedfmt: TokenField_fusedfmt,
    FUSEDR2: TableFUSEDR2,
    FUSEDR1: TableFUSEDR1,
    FUSEDRT: TableFUSEDRT,
    FUSEDRA: TableFUSEDRA,
    FUSEDTA: TableFUSEDTA,
}
impl instructionVar276 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FMPYADD"),
            self.fusedfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FUSEDR2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDR1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDRT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDRA.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDTA.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 6i64 {
            return None;
        }
        if token_parser.TokenFieldbit5().disassembly() != 1i64 {
            return None;
        }
        let FUSEDR2 = if let Some((len, table)) = TableFUSEDR2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FUSEDR1 = if let Some((len, table)) = TableFUSEDR1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FUSEDRT = if let Some((len, table)) = TableFUSEDRT::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FUSEDRA = if let Some((len, table)) = TableFUSEDRA::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FUSEDTA = if let Some((len, table)) = TableFUSEDTA::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fusedfmt = token_parser.TokenFieldfusedfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FUSEDR2,
                FUSEDR1,
                FUSEDRT,
                FUSEDRA,
                FUSEDTA,
                fusedfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1809:1"]
#[derive(Clone, Debug)]
struct instructionVar277 {
    fusedfmt: TokenField_fusedfmt,
    fpra: TokenField_fpra,
    fpta: TokenField_fpta,
    FPR264: TableFPR264,
    FPR164: TableFPR164,
    FPRT64: TableFPRT64,
}
impl instructionVar277 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FMPYSUB"),
            self.fusedfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FPR264.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPR164.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FPRT64.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            self.fpra.display(),
            DisplayElement::Literal(","),
            self.fpta.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 38i64 {
            return None;
        }
        if token_parser.TokenFieldbit5().disassembly() != 0i64 {
            return None;
        }
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPRT64 = if let Some((len, table)) = TableFPRT64::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fusedfmt = token_parser.TokenFieldfusedfmt();
        let fpra = token_parser.TokenFieldfpra();
        let fpta = token_parser.TokenFieldfpta();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPR264,
                FPR164,
                FPRT64,
                fusedfmt,
                fpra,
                fpta,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1814:1"]
#[derive(Clone, Debug)]
struct instructionVar278 {
    fusedfmt: TokenField_fusedfmt,
    FUSEDR2: TableFUSEDR2,
    FUSEDR1: TableFUSEDR1,
    FUSEDRT: TableFUSEDRT,
    FUSEDRA: TableFUSEDRA,
    FUSEDTA: TableFUSEDTA,
}
impl instructionVar278 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("FMPYSUB"),
            self.fusedfmt.display(),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.FUSEDR2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDR1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDRT.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDRA.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.FUSEDTA.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 38i64 {
            return None;
        }
        if token_parser.TokenFieldbit5().disassembly() != 1i64 {
            return None;
        }
        let FUSEDR2 = if let Some((len, table)) = TableFUSEDR2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FUSEDR1 = if let Some((len, table)) = TableFUSEDR1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FUSEDRT = if let Some((len, table)) = TableFUSEDRT::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FUSEDRA = if let Some((len, table)) = TableFUSEDRA::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FUSEDTA = if let Some((len, table)) = TableFUSEDTA::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fusedfmt = token_parser.TokenFieldfusedfmt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FUSEDR2,
                FUSEDR1,
                FUSEDRT,
                FUSEDRA,
                FUSEDTA,
                fusedfmt,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:12:1"]
#[derive(Clone, Debug)]
struct instructionVar279 {
    OFF_BASE_14: TableOFF_BASE_14,
    R1dst: TableR1dst,
}
impl instructionVar279 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDW"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 18i64 {
            return None;
        }
        let OFF_BASE_14 = if let Some((len, table)) = TableOFF_BASE_14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE_14, R1dst }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:17:1"]
#[derive(Clone, Debug)]
struct instructionVar280 {
    OFF_BASE_14: TableOFF_BASE_14,
    R1dst: TableR1dst,
}
impl instructionVar280 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDH"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 17i64 {
            return None;
        }
        let OFF_BASE_14 = if let Some((len, table)) = TableOFF_BASE_14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE_14, R1dst }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:22:1"]
#[derive(Clone, Debug)]
struct instructionVar281 {
    OFF_BASE_14: TableOFF_BASE_14,
    R1dst: TableR1dst,
}
impl instructionVar281 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDB"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 16i64 {
            return None;
        }
        let OFF_BASE_14 = if let Some((len, table)) = TableOFF_BASE_14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE_14, R1dst }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:27:1"]
#[derive(Clone, Debug)]
struct instructionVar282 {
    OFF_BASE_14: TableOFF_BASE_14,
    R1: TableR1,
}
impl instructionVar282 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STW"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 26i64 {
            return None;
        }
        let OFF_BASE_14 = if let Some((len, table)) = TableOFF_BASE_14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE_14, R1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:32:1"]
#[derive(Clone, Debug)]
struct instructionVar283 {
    R1: TableR1,
    OFF_BASE_14: TableOFF_BASE_14,
}
impl instructionVar283 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STH"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 25i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let OFF_BASE_14 = if let Some((len, table)) = TableOFF_BASE_14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, OFF_BASE_14 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:36:1"]
#[derive(Clone, Debug)]
struct instructionVar284 {
    OFF_BASE_14: TableOFF_BASE_14,
    R1: TableR1,
}
impl instructionVar284 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("STB"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 24i64 {
            return None;
        }
        let OFF_BASE_14 = if let Some((len, table)) = TableOFF_BASE_14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OFF_BASE_14, R1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:41:1"]
#[derive(Clone, Debug)]
struct instructionVar285 {
    OFF_BASE_14: TableOFF_BASE_14,
    R1dst: TableR1dst,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
    lse14: Tablelse14,
}
impl instructionVar285 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("LDW"),
            DisplayElement::Literal(",M"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 19i64 {
            return None;
        }
        let OFF_BASE_14 = if let Some((len, table)) = TableOFF_BASE_14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse14 = if let Some((len, table)) =
            Tablelse14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                OFF_BASE_14,
                R1dst,
                RB,
                SPCBASE,
                lse14,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:51:1"]
#[derive(Clone, Debug)]
struct instructionVar286 {
    OFF_BASE_14: TableOFF_BASE_14,
    R1: TableR1,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
    lse14: Tablelse14,
}
impl instructionVar286 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("STW"),
            DisplayElement::Literal(",M"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.R1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.OFF_BASE_14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 27i64 {
            return None;
        }
        let OFF_BASE_14 = if let Some((len, table)) = TableOFF_BASE_14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse14 = if let Some((len, table)) =
            Tablelse14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                OFF_BASE_14,
                R1,
                RB,
                SPCBASE,
                lse14,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:188:1"]
#[derive(Clone, Debug)]
struct instructionVar287 {
    lse14: Tablelse14,
    RB: TableRB,
    R1dst: TableR1dst,
}
impl instructionVar287 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("LDO"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.lse14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("),")];
        display.extend_from_slice(&extend);
        self.R1dst.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 13i64 {
            return None;
        }
        let lse14 = if let Some((len, table)) =
            Tablelse14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R1dst = if let Some((len, table)) =
            TableR1dst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse14, RB, R1dst }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:201:1"]
#[derive(Clone, Debug)]
struct instructionVar288 {
    R2: TableR2,
    lse21: Tablelse21,
}
impl instructionVar288 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("LDIL"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.lse21.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 8i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse21 = if let Some((len, table)) =
            Tablelse21::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse21 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:207:1"]
#[derive(Clone, Debug)]
struct instructionVar289 {
    R2: TableR2,
    lse21: Tablelse21,
}
impl instructionVar289 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ADDIL"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.lse21.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(", ")];
        display.extend_from_slice(&extend);
        self.R2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(", "),
            DisplayElement::Register(Register::r1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 10i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse21 = if let Some((len, table)) =
            Tablelse21::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse21 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1447:1"]
#[derive(Clone, Debug)]
struct instructionVar290 {
    im26: TokenField_im26,
}
impl instructionVar290 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("DIAG"),
            DisplayElement::Literal(" "),
            self.im26.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 5i64 {
            return None;
        }
        let im26 = token_parser.TokenFieldim26();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { im26 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-riscInstructions.sinc:1456:1"]
#[derive(Clone, Debug)]
struct instructionVar291 {
    sopim17: TokenField_sopim17,
    im5: TokenField_im5,
    SFU: TableSFU,
    nullifyForSpecial: TablenullifyForSpecial,
}
impl instructionVar291 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut sop: i64 = 0;
        sop = (self
            .sopim17
            .disassembly()
            .checked_shl(u32::try_from(5i64).unwrap())
            .unwrap_or(0)
            | self.im5.disassembly());
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("COPR"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SFU.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Number(true, sop),
        ];
        display.extend_from_slice(&extend);
        self.nullifyForSpecial.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldopfam().disassembly() != 12i64 {
            return None;
        }
        let mut sop: i64 = 0;
        sop = (token_parser
            .TokenFieldsopim17()
            .disassembly()
            .checked_shl(u32::try_from(5i64).unwrap())
            .unwrap_or(0)
            | token_parser.TokenFieldim5().disassembly());
        let SFU = if let Some((len, table)) =
            TableSFU::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let nullifyForSpecial = if let Some((len, table)) =
            TablenullifyForSpecial::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let im5 = token_parser.TokenFieldim5();
        let sopim17 = token_parser.TokenFieldsopim17();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SFU,
                nullifyForSpecial,
                im5,
                sopim17,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum Tableinstruction {
    Var0(instructionVar0),
    Var1(instructionVar1),
    Var2(instructionVar2),
    Var3(instructionVar3),
    Var4(instructionVar4),
    Var5(instructionVar5),
    Var6(instructionVar6),
    Var7(instructionVar7),
    Var8(instructionVar8),
    Var9(instructionVar9),
    Var10(instructionVar10),
    Var11(instructionVar11),
    Var12(instructionVar12),
    Var13(instructionVar13),
    Var14(instructionVar14),
    Var15(instructionVar15),
    Var16(instructionVar16),
    Var17(instructionVar17),
    Var18(instructionVar18),
    Var19(instructionVar19),
    Var20(instructionVar20),
    Var21(instructionVar21),
    Var22(instructionVar22),
    Var23(instructionVar23),
    Var24(instructionVar24),
    Var25(instructionVar25),
    Var26(instructionVar26),
    Var27(instructionVar27),
    Var28(instructionVar28),
    Var29(instructionVar29),
    Var30(instructionVar30),
    Var31(instructionVar31),
    Var32(instructionVar32),
    Var33(instructionVar33),
    Var34(instructionVar34),
    Var35(instructionVar35),
    Var36(instructionVar36),
    Var37(instructionVar37),
    Var38(instructionVar38),
    Var39(instructionVar39),
    Var40(instructionVar40),
    Var41(instructionVar41),
    Var42(instructionVar42),
    Var43(instructionVar43),
    Var44(instructionVar44),
    Var45(instructionVar45),
    Var46(instructionVar46),
    Var47(instructionVar47),
    Var48(instructionVar48),
    Var49(instructionVar49),
    Var50(instructionVar50),
    Var51(instructionVar51),
    Var52(instructionVar52),
    Var53(instructionVar53),
    Var54(instructionVar54),
    Var55(instructionVar55),
    Var56(instructionVar56),
    Var57(instructionVar57),
    Var58(instructionVar58),
    Var59(instructionVar59),
    Var60(instructionVar60),
    Var61(instructionVar61),
    Var62(instructionVar62),
    Var63(instructionVar63),
    Var64(instructionVar64),
    Var65(instructionVar65),
    Var66(instructionVar66),
    Var67(instructionVar67),
    Var68(instructionVar68),
    Var69(instructionVar69),
    Var70(instructionVar70),
    Var71(instructionVar71),
    Var72(instructionVar72),
    Var73(instructionVar73),
    Var74(instructionVar74),
    Var75(instructionVar75),
    Var76(instructionVar76),
    Var77(instructionVar77),
    Var78(instructionVar78),
    Var79(instructionVar79),
    Var80(instructionVar80),
    Var81(instructionVar81),
    Var82(instructionVar82),
    Var83(instructionVar83),
    Var84(instructionVar84),
    Var85(instructionVar85),
    Var86(instructionVar86),
    Var87(instructionVar87),
    Var88(instructionVar88),
    Var89(instructionVar89),
    Var90(instructionVar90),
    Var91(instructionVar91),
    Var92(instructionVar92),
    Var93(instructionVar93),
    Var94(instructionVar94),
    Var95(instructionVar95),
    Var96(instructionVar96),
    Var97(instructionVar97),
    Var98(instructionVar98),
    Var99(instructionVar99),
    Var100(instructionVar100),
    Var101(instructionVar101),
    Var102(instructionVar102),
    Var103(instructionVar103),
    Var104(instructionVar104),
    Var105(instructionVar105),
    Var106(instructionVar106),
    Var107(instructionVar107),
    Var108(instructionVar108),
    Var109(instructionVar109),
    Var110(instructionVar110),
    Var111(instructionVar111),
    Var112(instructionVar112),
    Var113(instructionVar113),
    Var114(instructionVar114),
    Var115(instructionVar115),
    Var116(instructionVar116),
    Var117(instructionVar117),
    Var118(instructionVar118),
    Var119(instructionVar119),
    Var120(instructionVar120),
    Var121(instructionVar121),
    Var122(instructionVar122),
    Var123(instructionVar123),
    Var124(instructionVar124),
    Var125(instructionVar125),
    Var126(instructionVar126),
    Var127(instructionVar127),
    Var128(instructionVar128),
    Var129(instructionVar129),
    Var130(instructionVar130),
    Var131(instructionVar131),
    Var132(instructionVar132),
    Var133(instructionVar133),
    Var134(instructionVar134),
    Var135(instructionVar135),
    Var136(instructionVar136),
    Var137(instructionVar137),
    Var138(instructionVar138),
    Var139(instructionVar139),
    Var140(instructionVar140),
    Var141(instructionVar141),
    Var142(instructionVar142),
    Var143(instructionVar143),
    Var144(instructionVar144),
    Var145(instructionVar145),
    Var146(instructionVar146),
    Var147(instructionVar147),
    Var148(instructionVar148),
    Var149(instructionVar149),
    Var150(instructionVar150),
    Var151(instructionVar151),
    Var152(instructionVar152),
    Var153(instructionVar153),
    Var154(instructionVar154),
    Var155(instructionVar155),
    Var156(instructionVar156),
    Var157(instructionVar157),
    Var158(instructionVar158),
    Var159(instructionVar159),
    Var160(instructionVar160),
    Var161(instructionVar161),
    Var162(instructionVar162),
    Var163(instructionVar163),
    Var164(instructionVar164),
    Var165(instructionVar165),
    Var166(instructionVar166),
    Var167(instructionVar167),
    Var168(instructionVar168),
    Var169(instructionVar169),
    Var170(instructionVar170),
    Var171(instructionVar171),
    Var172(instructionVar172),
    Var173(instructionVar173),
    Var174(instructionVar174),
    Var175(instructionVar175),
    Var176(instructionVar176),
    Var177(instructionVar177),
    Var178(instructionVar178),
    Var179(instructionVar179),
    Var180(instructionVar180),
    Var181(instructionVar181),
    Var182(instructionVar182),
    Var183(instructionVar183),
    Var184(instructionVar184),
    Var185(instructionVar185),
    Var186(instructionVar186),
    Var187(instructionVar187),
    Var188(instructionVar188),
    Var189(instructionVar189),
    Var190(instructionVar190),
    Var191(instructionVar191),
    Var192(instructionVar192),
    Var193(instructionVar193),
    Var194(instructionVar194),
    Var195(instructionVar195),
    Var196(instructionVar196),
    Var197(instructionVar197),
    Var198(instructionVar198),
    Var199(instructionVar199),
    Var200(instructionVar200),
    Var201(instructionVar201),
    Var202(instructionVar202),
    Var203(instructionVar203),
    Var204(instructionVar204),
    Var205(instructionVar205),
    Var206(instructionVar206),
    Var207(instructionVar207),
    Var208(instructionVar208),
    Var209(instructionVar209),
    Var210(instructionVar210),
    Var211(instructionVar211),
    Var212(instructionVar212),
    Var213(instructionVar213),
    Var214(instructionVar214),
    Var215(instructionVar215),
    Var216(instructionVar216),
    Var217(instructionVar217),
    Var218(instructionVar218),
    Var219(instructionVar219),
    Var220(instructionVar220),
    Var221(instructionVar221),
    Var222(instructionVar222),
    Var223(instructionVar223),
    Var224(instructionVar224),
    Var225(instructionVar225),
    Var226(instructionVar226),
    Var227(instructionVar227),
    Var228(instructionVar228),
    Var229(instructionVar229),
    Var230(instructionVar230),
    Var231(instructionVar231),
    Var232(instructionVar232),
    Var233(instructionVar233),
    Var234(instructionVar234),
    Var235(instructionVar235),
    Var236(instructionVar236),
    Var237(instructionVar237),
    Var238(instructionVar238),
    Var239(instructionVar239),
    Var240(instructionVar240),
    Var241(instructionVar241),
    Var242(instructionVar242),
    Var243(instructionVar243),
    Var244(instructionVar244),
    Var245(instructionVar245),
    Var246(instructionVar246),
    Var247(instructionVar247),
    Var248(instructionVar248),
    Var249(instructionVar249),
    Var250(instructionVar250),
    Var251(instructionVar251),
    Var252(instructionVar252),
    Var253(instructionVar253),
    Var254(instructionVar254),
    Var255(instructionVar255),
    Var256(instructionVar256),
    Var257(instructionVar257),
    Var258(instructionVar258),
    Var259(instructionVar259),
    Var260(instructionVar260),
    Var261(instructionVar261),
    Var262(instructionVar262),
    Var263(instructionVar263),
    Var264(instructionVar264),
    Var265(instructionVar265),
    Var266(instructionVar266),
    Var267(instructionVar267),
    Var268(instructionVar268),
    Var269(instructionVar269),
    Var270(instructionVar270),
    Var271(instructionVar271),
    Var272(instructionVar272),
    Var273(instructionVar273),
    Var274(instructionVar274),
    Var275(instructionVar275),
    Var276(instructionVar276),
    Var277(instructionVar277),
    Var278(instructionVar278),
    Var279(instructionVar279),
    Var280(instructionVar280),
    Var281(instructionVar281),
    Var282(instructionVar282),
    Var283(instructionVar283),
    Var284(instructionVar284),
    Var285(instructionVar285),
    Var286(instructionVar286),
    Var287(instructionVar287),
    Var288(instructionVar288),
    Var289(instructionVar289),
    Var290(instructionVar290),
    Var291(instructionVar291),
}
impl Tableinstruction {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var18(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var19(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var20(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var21(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var22(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var23(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var24(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var25(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var26(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var27(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var28(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var29(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var30(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var31(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var32(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var33(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var34(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var35(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var36(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var37(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var38(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var39(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var40(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var41(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var42(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var43(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var44(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var45(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var46(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var47(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var48(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var49(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var50(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var51(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var52(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var53(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var54(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var55(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var56(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var57(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var58(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var59(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var60(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var61(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var62(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var63(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var64(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var65(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var66(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var67(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var68(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var69(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var70(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var71(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var72(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var73(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var74(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var75(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var76(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var77(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var78(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var79(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var80(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var81(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var82(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var83(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var84(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var85(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var86(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var87(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var88(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var89(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var90(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var91(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var92(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var93(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var94(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var95(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var96(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var97(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var98(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var99(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var100(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var101(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var102(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var103(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var104(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var105(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var106(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var107(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var108(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var109(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var110(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var111(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var112(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var113(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var114(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var115(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var116(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var117(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var118(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var119(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var120(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var121(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var122(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var123(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var124(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var125(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var126(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var127(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var128(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var129(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var130(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var131(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var132(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var133(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var134(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var135(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var136(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var137(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var138(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var139(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var140(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var141(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var142(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var143(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var144(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var145(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var146(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var147(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var148(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var149(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var150(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var151(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var152(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var153(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var154(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var155(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var156(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var157(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var158(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var159(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var160(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var161(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var162(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var163(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var164(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var165(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var166(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var167(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var168(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var169(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var170(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var171(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var172(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var173(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var174(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var175(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var176(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var177(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var178(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var179(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var180(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var181(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var182(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var183(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var184(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var185(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var186(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var187(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var188(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var189(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var190(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var191(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var192(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var193(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var194(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var195(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var196(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var197(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var198(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var199(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var200(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var201(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var202(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var203(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var204(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var205(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var206(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var207(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var208(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var209(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var210(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var211(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var212(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var213(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var214(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var215(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var216(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var217(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var218(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var219(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var220(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var221(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var222(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var223(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var224(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var225(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var226(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var227(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var228(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var229(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var230(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var231(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var232(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var233(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var234(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var235(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var236(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var237(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var238(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var239(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var240(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var241(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var242(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var243(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var244(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var245(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var246(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var247(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var248(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var249(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var250(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var251(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var252(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var253(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var254(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var255(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var256(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var257(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var258(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var259(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var260(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var261(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var262(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var263(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var264(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var265(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var266(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var267(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var268(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var269(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var270(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var271(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var272(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var273(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var274(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var275(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var276(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var277(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var278(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var279(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var280(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var281(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var282(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var283(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var284(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var285(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var286(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var287(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var288(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var289(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var290(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var291(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = instructionVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar8::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar9::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar10::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar11::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar12::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar13::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar14::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar15::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar16::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var16(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar17::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var17(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar18::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var18(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar19::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var19(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar20::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var20(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar21::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var21(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar22::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var22(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar23::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var23(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar24::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var24(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar25::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var25(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar26::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var26(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar27::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var27(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar28::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var28(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar29::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var29(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar30::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var30(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar31::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var31(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar32::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var32(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar33::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var33(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar34::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var34(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar35::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var35(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar36::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var36(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar37::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var37(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar38::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var38(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar39::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var39(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar40::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var40(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar41::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var41(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar42::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var42(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar43::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var43(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar44::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var44(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar45::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var45(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar46::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var46(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar47::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var47(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar48::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var48(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar49::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var49(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar50::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var50(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar51::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var51(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar52::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var52(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar53::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var53(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar54::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var54(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar55::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var55(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar56::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var56(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar57::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var57(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar58::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var58(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar59::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var59(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar60::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var60(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar61::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var61(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar62::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var62(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar63::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var63(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar64::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var64(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar65::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var65(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar66::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var66(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar67::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var67(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar68::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var68(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar69::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var69(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar70::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var70(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar71::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var71(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar72::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var72(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar73::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var73(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar74::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var74(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar75::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var75(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar76::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var76(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar77::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var77(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar78::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var78(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar79::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var79(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar80::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var80(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar81::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var81(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar82::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var82(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar83::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var83(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar84::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var84(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar85::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var85(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar86::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var86(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar87::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var87(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar88::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var88(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar89::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var89(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar90::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var90(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar91::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var91(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar92::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var92(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar93::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var93(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar94::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var94(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar95::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var95(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar96::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var96(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar97::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var97(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar98::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var98(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar99::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var99(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar100::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var100(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar101::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var101(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar102::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var102(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar103::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var103(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar104::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var104(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar105::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var105(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar106::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var106(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar107::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var107(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar108::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var108(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar109::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var109(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar110::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var110(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar111::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var111(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar112::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var112(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar113::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var113(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar114::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var114(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar115::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var115(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar116::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var116(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar117::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var117(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar118::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var118(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar119::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var119(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar120::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var120(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar121::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var121(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar122::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var122(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar123::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var123(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar124::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var124(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar125::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var125(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar126::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var126(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar127::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var127(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar128::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var128(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar129::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var129(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar130::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var130(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar131::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var131(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar132::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var132(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar133::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var133(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar134::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var134(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar135::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var135(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar136::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var136(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar137::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var137(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar138::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var138(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar139::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var139(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar140::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var140(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar141::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var141(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar142::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var142(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar143::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var143(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar144::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var144(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar145::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var145(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar146::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var146(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar147::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var147(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar148::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var148(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar149::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var149(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar150::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var150(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar151::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var151(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar152::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var152(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar153::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var153(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar154::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var154(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar155::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var155(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar156::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var156(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar157::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var157(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar158::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var158(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar159::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var159(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar160::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var160(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar161::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var161(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar162::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var162(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar163::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var163(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar164::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var164(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar165::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var165(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar166::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var166(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar167::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var167(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar168::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var168(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar169::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var169(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar170::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var170(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar171::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var171(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar172::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var172(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar173::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var173(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar174::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var174(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar175::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var175(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar176::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var176(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar177::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var177(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar178::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var178(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar179::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var179(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar180::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var180(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar181::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var181(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar182::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var182(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar183::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var183(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar184::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var184(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar185::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var185(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar186::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var186(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar187::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var187(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar188::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var188(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar189::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var189(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar190::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var190(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar191::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var191(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar192::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var192(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar193::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var193(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar194::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var194(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar195::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var195(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar196::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var196(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar197::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var197(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar198::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var198(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar199::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var199(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar200::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var200(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar201::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var201(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar202::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var202(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar203::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var203(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar204::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var204(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar205::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var205(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar206::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var206(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar207::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var207(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar208::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var208(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar209::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var209(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar210::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var210(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar211::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var211(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar212::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var212(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar213::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var213(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar214::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var214(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar215::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var215(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar216::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var216(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar217::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var217(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar218::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var218(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar219::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var219(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar220::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var220(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar221::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var221(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar222::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var222(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar223::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var223(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar224::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var224(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar225::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var225(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar226::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var226(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar227::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var227(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar228::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var228(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar229::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var229(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar230::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var230(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar231::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var231(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar232::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var232(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar233::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var233(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar234::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var234(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar235::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var235(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar236::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var236(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar237::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var237(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar238::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var238(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar239::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var239(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar240::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var240(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar241::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var241(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar242::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var242(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar243::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var243(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar244::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var244(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar245::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var245(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar246::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var246(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar247::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var247(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar248::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var248(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar249::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var249(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar250::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var250(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar251::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var251(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar252::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var252(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar253::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var253(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar254::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var254(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar255::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var255(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar256::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var256(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar257::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var257(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar258::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var258(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar259::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var259(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar260::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var260(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar261::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var261(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar262::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var262(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar263::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var263(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar264::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var264(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar265::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var265(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar266::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var266(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar267::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var267(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar268::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var268(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar269::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var269(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar270::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var270(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar271::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var271(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar272::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var272(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar273::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var273(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar274::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var274(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar275::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var275(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar276::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var276(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar277::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var277(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar278::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var278(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar279::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var279(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar280::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var280(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar281::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var281(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar282::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var282(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar283::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var283(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar284::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var284(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar285::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var285(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar286::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var286(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar287::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var287(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar288::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var288(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar289::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var289(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar290::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var290(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar291::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var291(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:458:1"]
#[derive(Clone, Debug)]
struct immediateDestVar0 {}
impl immediateDestVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableimmediateDest {
    Var0(immediateDestVar0),
}
impl TableimmediateDest {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = immediateDestVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:942:1"]
#[derive(Clone, Debug)]
struct R1Var0 {
    reg1: TokenField_reg1,
}
impl R1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.reg1.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldreg1().disassembly() != 0i64 {
            return None;
        }
        let reg1 = token_parser.TokenFieldreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:943:1"]
#[derive(Clone, Debug)]
struct R1Var1 {
    reg1: TokenField_reg1,
}
impl R1Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.reg1.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let reg1 = token_parser.TokenFieldreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg1 }))
    }
}
#[derive(Clone, Debug)]
enum TableR1 {
    Var0(R1Var0),
    Var1(R1Var1),
}
impl TableR1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            R1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            R1Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:944:1"]
#[derive(Clone, Debug)]
struct R1dstVar0 {
    reg1: TokenField_reg1,
}
impl R1dstVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.reg1.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let reg1 = token_parser.TokenFieldreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg1 }))
    }
}
#[derive(Clone, Debug)]
enum TableR1dst {
    Var0(R1dstVar0),
}
impl TableR1dst {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            R1dstVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:946:1"]
#[derive(Clone, Debug)]
struct R2Var0 {
    reg2: TokenField_reg2,
}
impl R2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.reg2.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldreg2().disassembly() != 0i64 {
            return None;
        }
        let reg2 = token_parser.TokenFieldreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:947:1"]
#[derive(Clone, Debug)]
struct R2Var1 {
    reg2: TokenField_reg2,
}
impl R2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.reg2.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let reg2 = token_parser.TokenFieldreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg2 }))
    }
}
#[derive(Clone, Debug)]
enum TableR2 {
    Var0(R2Var0),
    Var1(R2Var1),
}
impl TableR2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            R2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            R2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:948:1"]
#[derive(Clone, Debug)]
struct R2dstVar0 {
    reg2: TokenField_reg2,
}
impl R2dstVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.reg2.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let reg2 = token_parser.TokenFieldreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg2 }))
    }
}
#[derive(Clone, Debug)]
enum TableR2dst {
    Var0(R2dstVar0),
}
impl TableR2dst {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            R2dstVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:950:1"]
#[derive(Clone, Debug)]
struct RTVar0 {
    t: TokenField_t,
}
impl RTVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.t.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let t = token_parser.TokenFieldt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { t }))
    }
}
#[derive(Clone, Debug)]
enum TableRT {
    Var0(RTVar0),
}
impl TableRT {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            RTVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:952:1"]
#[derive(Clone, Debug)]
struct RBVar0 {
    b: TokenField_b,
}
impl RBVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.b.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldb().disassembly() != 0i64 {
            return None;
        }
        let b = token_parser.TokenFieldb();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { b }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:953:1"]
#[derive(Clone, Debug)]
struct RBVar1 {
    b: TokenField_b,
}
impl RBVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.b.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let b = token_parser.TokenFieldb();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { b }))
    }
}
#[derive(Clone, Debug)]
enum TableRB {
    Var0(RBVar0),
    Var1(RBVar1),
}
impl TableRB {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            RBVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            RBVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:955:1"]
#[derive(Clone, Debug)]
struct RXVar0 {}
impl RXVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldx().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:956:1"]
#[derive(Clone, Debug)]
struct RXVar1 {
    x: TokenField_x,
}
impl RXVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.x.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let x = token_parser.TokenFieldx();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { x }))
    }
}
#[derive(Clone, Debug)]
enum TableRX {
    Var0(RXVar0),
    Var1(RXVar1),
}
impl TableRX {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            RXVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            RXVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:958:1"]
#[derive(Clone, Debug)]
struct RRVar0 {
    r: TokenField_r,
}
impl RRVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.r.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldr().disassembly() != 0i64 {
            return None;
        }
        let r = token_parser.TokenFieldr();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:959:1"]
#[derive(Clone, Debug)]
struct RRVar1 {
    r: TokenField_r,
}
impl RRVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.r.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let r = token_parser.TokenFieldr();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r }))
    }
}
#[derive(Clone, Debug)]
enum TableRR {
    Var0(RRVar0),
    Var1(RRVar1),
}
impl TableRR {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            RRVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            RRVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:961:1"]
#[derive(Clone, Debug)]
struct SARVar0 {}
impl SARVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("SAR")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSAR {
    Var0(SARVar0),
}
impl TableSAR {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            SARVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:962:1"]
#[derive(Clone, Debug)]
struct SR0Var0 {}
impl SR0Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr0)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSR0 {
    Var0(SR0Var0),
}
impl TableSR0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            SR0Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:963:1"]
#[derive(Clone, Debug)]
struct R31Var0 {}
impl R31Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r31)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableR31 {
    Var0(R31Var0),
}
impl TableR31 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            R31Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:966:1"]
#[derive(Clone, Debug)]
struct FPR164Var0 {
    freg1: TokenField_freg1,
}
impl FPR164Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.freg1.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[derive(Clone, Debug)]
enum TableFPR164 {
    Var0(FPR164Var0),
}
impl TableFPR164 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            FPR164Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:967:1"]
#[derive(Clone, Debug)]
struct FPR264Var0 {
    freg2: TokenField_freg2,
}
impl FPR264Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.freg2.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[derive(Clone, Debug)]
enum TableFPR264 {
    Var0(FPR264Var0),
}
impl TableFPR264 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            FPR264Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:968:1"]
#[derive(Clone, Debug)]
struct FPRT64Var0 {
    fpt: TokenField_fpt,
}
impl FPRT64Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.fpt.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[derive(Clone, Debug)]
enum TableFPRT64 {
    Var0(FPRT64Var0),
}
impl TableFPRT64 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            FPRT64Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:971:1"]
#[derive(Clone, Debug)]
struct FUSEDR1Var0 {
    fusedr1: TokenField_fusedr1,
}
impl FUSEDR1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.fusedr1.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let fusedr1 = token_parser.TokenFieldfusedr1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fusedr1 }))
    }
}
#[derive(Clone, Debug)]
enum TableFUSEDR1 {
    Var0(FUSEDR1Var0),
}
impl TableFUSEDR1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            FUSEDR1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:972:1"]
#[derive(Clone, Debug)]
struct FUSEDR2Var0 {
    fusedr2: TokenField_fusedr2,
}
impl FUSEDR2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.fusedr2.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let fusedr2 = token_parser.TokenFieldfusedr2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fusedr2 }))
    }
}
#[derive(Clone, Debug)]
enum TableFUSEDR2 {
    Var0(FUSEDR2Var0),
}
impl TableFUSEDR2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            FUSEDR2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:973:1"]
#[derive(Clone, Debug)]
struct FUSEDRAVar0 {
    fusedra: TokenField_fusedra,
}
impl FUSEDRAVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.fusedra.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let fusedra = token_parser.TokenFieldfusedra();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fusedra }))
    }
}
#[derive(Clone, Debug)]
enum TableFUSEDRA {
    Var0(FUSEDRAVar0),
}
impl TableFUSEDRA {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            FUSEDRAVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:974:1"]
#[derive(Clone, Debug)]
struct FUSEDTAVar0 {
    fusedta: TokenField_fusedta,
}
impl FUSEDTAVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.fusedta.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let fusedta = token_parser.TokenFieldfusedta();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fusedta }))
    }
}
#[derive(Clone, Debug)]
enum TableFUSEDTA {
    Var0(FUSEDTAVar0),
}
impl TableFUSEDTA {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            FUSEDTAVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:975:1"]
#[derive(Clone, Debug)]
struct FUSEDRTVar0 {
    fusedrt: TokenField_fusedrt,
}
impl FUSEDRTVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.fusedrt.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let fusedrt = token_parser.TokenFieldfusedrt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fusedrt }))
    }
}
#[derive(Clone, Debug)]
enum TableFUSEDRT {
    Var0(FUSEDRTVar0),
}
impl TableFUSEDRT {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            FUSEDRTVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:978:1"]
#[derive(Clone, Debug)]
struct FPR132Var0 {
    freg1: TokenField_freg1,
}
impl FPR132Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 0i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:979:1"]
#[derive(Clone, Debug)]
struct FPR132Var1 {
    freg1: TokenField_freg1,
}
impl FPR132Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 1i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:980:1"]
#[derive(Clone, Debug)]
struct FPR132Var2 {
    freg1: TokenField_freg1,
}
impl FPR132Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 2i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:981:1"]
#[derive(Clone, Debug)]
struct FPR132Var3 {
    freg1: TokenField_freg1,
}
impl FPR132Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 3i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:982:1"]
#[derive(Clone, Debug)]
struct FPR132Var4 {
    freg1: TokenField_freg1,
}
impl FPR132Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 4i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:983:1"]
#[derive(Clone, Debug)]
struct FPR132Var5 {
    freg1: TokenField_freg1,
}
impl FPR132Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 5i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:984:1"]
#[derive(Clone, Debug)]
struct FPR132Var6 {
    freg1: TokenField_freg1,
}
impl FPR132Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 6i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:985:1"]
#[derive(Clone, Debug)]
struct FPR132Var7 {
    freg1: TokenField_freg1,
}
impl FPR132Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 7i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:986:1"]
#[derive(Clone, Debug)]
struct FPR132Var8 {
    freg1: TokenField_freg1,
}
impl FPR132Var8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 8i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:987:1"]
#[derive(Clone, Debug)]
struct FPR132Var9 {
    freg1: TokenField_freg1,
}
impl FPR132Var9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 9i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:988:1"]
#[derive(Clone, Debug)]
struct FPR132Var10 {
    freg1: TokenField_freg1,
}
impl FPR132Var10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 10i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:989:1"]
#[derive(Clone, Debug)]
struct FPR132Var11 {
    freg1: TokenField_freg1,
}
impl FPR132Var11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 11i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:990:1"]
#[derive(Clone, Debug)]
struct FPR132Var12 {
    freg1: TokenField_freg1,
}
impl FPR132Var12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 12i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:991:1"]
#[derive(Clone, Debug)]
struct FPR132Var13 {
    freg1: TokenField_freg1,
}
impl FPR132Var13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 13i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:992:1"]
#[derive(Clone, Debug)]
struct FPR132Var14 {
    freg1: TokenField_freg1,
}
impl FPR132Var14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 14i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:993:1"]
#[derive(Clone, Debug)]
struct FPR132Var15 {
    freg1: TokenField_freg1,
}
impl FPR132Var15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 15i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:994:1"]
#[derive(Clone, Debug)]
struct FPR132Var16 {
    freg1: TokenField_freg1,
}
impl FPR132Var16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 16i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:995:1"]
#[derive(Clone, Debug)]
struct FPR132Var17 {
    freg1: TokenField_freg1,
}
impl FPR132Var17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 17i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:996:1"]
#[derive(Clone, Debug)]
struct FPR132Var18 {
    freg1: TokenField_freg1,
}
impl FPR132Var18 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 18i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:997:1"]
#[derive(Clone, Debug)]
struct FPR132Var19 {
    freg1: TokenField_freg1,
}
impl FPR132Var19 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 19i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:998:1"]
#[derive(Clone, Debug)]
struct FPR132Var20 {
    freg1: TokenField_freg1,
}
impl FPR132Var20 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 20i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:999:1"]
#[derive(Clone, Debug)]
struct FPR132Var21 {
    freg1: TokenField_freg1,
}
impl FPR132Var21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 21i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1000:1"]
#[derive(Clone, Debug)]
struct FPR132Var22 {
    freg1: TokenField_freg1,
}
impl FPR132Var22 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 22i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1001:1"]
#[derive(Clone, Debug)]
struct FPR132Var23 {
    freg1: TokenField_freg1,
}
impl FPR132Var23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 23i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1002:1"]
#[derive(Clone, Debug)]
struct FPR132Var24 {
    freg1: TokenField_freg1,
}
impl FPR132Var24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 24i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1003:1"]
#[derive(Clone, Debug)]
struct FPR132Var25 {
    freg1: TokenField_freg1,
}
impl FPR132Var25 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 25i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1004:1"]
#[derive(Clone, Debug)]
struct FPR132Var26 {
    freg1: TokenField_freg1,
}
impl FPR132Var26 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 26i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1005:1"]
#[derive(Clone, Debug)]
struct FPR132Var27 {
    freg1: TokenField_freg1,
}
impl FPR132Var27 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 27i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1006:1"]
#[derive(Clone, Debug)]
struct FPR132Var28 {
    freg1: TokenField_freg1,
}
impl FPR132Var28 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 28i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1007:1"]
#[derive(Clone, Debug)]
struct FPR132Var29 {
    freg1: TokenField_freg1,
}
impl FPR132Var29 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 29i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1008:1"]
#[derive(Clone, Debug)]
struct FPR132Var30 {
    freg1: TokenField_freg1,
}
impl FPR132Var30 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 30i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1009:1"]
#[derive(Clone, Debug)]
struct FPR132Var31 {
    freg1: TokenField_freg1,
}
impl FPR132Var31 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 31i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1010:1"]
#[derive(Clone, Debug)]
struct FPR132Var32 {
    freg1: TokenField_freg1,
}
impl FPR132Var32 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 0i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1011:1"]
#[derive(Clone, Debug)]
struct FPR132Var33 {
    freg1: TokenField_freg1,
}
impl FPR132Var33 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 1i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1012:1"]
#[derive(Clone, Debug)]
struct FPR132Var34 {
    freg1: TokenField_freg1,
}
impl FPR132Var34 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 2i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1013:1"]
#[derive(Clone, Debug)]
struct FPR132Var35 {
    freg1: TokenField_freg1,
}
impl FPR132Var35 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 3i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1014:1"]
#[derive(Clone, Debug)]
struct FPR132Var36 {
    freg1: TokenField_freg1,
}
impl FPR132Var36 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 4i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1015:1"]
#[derive(Clone, Debug)]
struct FPR132Var37 {
    freg1: TokenField_freg1,
}
impl FPR132Var37 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 5i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1016:1"]
#[derive(Clone, Debug)]
struct FPR132Var38 {
    freg1: TokenField_freg1,
}
impl FPR132Var38 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 6i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1017:1"]
#[derive(Clone, Debug)]
struct FPR132Var39 {
    freg1: TokenField_freg1,
}
impl FPR132Var39 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 7i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1018:1"]
#[derive(Clone, Debug)]
struct FPR132Var40 {
    freg1: TokenField_freg1,
}
impl FPR132Var40 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 8i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1019:1"]
#[derive(Clone, Debug)]
struct FPR132Var41 {
    freg1: TokenField_freg1,
}
impl FPR132Var41 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 9i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1020:1"]
#[derive(Clone, Debug)]
struct FPR132Var42 {
    freg1: TokenField_freg1,
}
impl FPR132Var42 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 10i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1021:1"]
#[derive(Clone, Debug)]
struct FPR132Var43 {
    freg1: TokenField_freg1,
}
impl FPR132Var43 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 11i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1022:1"]
#[derive(Clone, Debug)]
struct FPR132Var44 {
    freg1: TokenField_freg1,
}
impl FPR132Var44 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 12i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1023:1"]
#[derive(Clone, Debug)]
struct FPR132Var45 {
    freg1: TokenField_freg1,
}
impl FPR132Var45 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 13i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1024:1"]
#[derive(Clone, Debug)]
struct FPR132Var46 {
    freg1: TokenField_freg1,
}
impl FPR132Var46 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 14i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1025:1"]
#[derive(Clone, Debug)]
struct FPR132Var47 {
    freg1: TokenField_freg1,
}
impl FPR132Var47 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 15i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1026:1"]
#[derive(Clone, Debug)]
struct FPR132Var48 {
    freg1: TokenField_freg1,
}
impl FPR132Var48 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 16i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1027:1"]
#[derive(Clone, Debug)]
struct FPR132Var49 {
    freg1: TokenField_freg1,
}
impl FPR132Var49 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 17i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1028:1"]
#[derive(Clone, Debug)]
struct FPR132Var50 {
    freg1: TokenField_freg1,
}
impl FPR132Var50 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 18i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1029:1"]
#[derive(Clone, Debug)]
struct FPR132Var51 {
    freg1: TokenField_freg1,
}
impl FPR132Var51 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 19i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1030:1"]
#[derive(Clone, Debug)]
struct FPR132Var52 {
    freg1: TokenField_freg1,
}
impl FPR132Var52 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 20i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1031:1"]
#[derive(Clone, Debug)]
struct FPR132Var53 {
    freg1: TokenField_freg1,
}
impl FPR132Var53 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 21i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1032:1"]
#[derive(Clone, Debug)]
struct FPR132Var54 {
    freg1: TokenField_freg1,
}
impl FPR132Var54 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 22i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1033:1"]
#[derive(Clone, Debug)]
struct FPR132Var55 {
    freg1: TokenField_freg1,
}
impl FPR132Var55 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 23i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1034:1"]
#[derive(Clone, Debug)]
struct FPR132Var56 {
    freg1: TokenField_freg1,
}
impl FPR132Var56 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 24i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1035:1"]
#[derive(Clone, Debug)]
struct FPR132Var57 {
    freg1: TokenField_freg1,
}
impl FPR132Var57 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 25i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1036:1"]
#[derive(Clone, Debug)]
struct FPR132Var58 {
    freg1: TokenField_freg1,
}
impl FPR132Var58 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 26i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1037:1"]
#[derive(Clone, Debug)]
struct FPR132Var59 {
    freg1: TokenField_freg1,
}
impl FPR132Var59 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 27i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1038:1"]
#[derive(Clone, Debug)]
struct FPR132Var60 {
    freg1: TokenField_freg1,
}
impl FPR132Var60 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 28i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1039:1"]
#[derive(Clone, Debug)]
struct FPR132Var61 {
    freg1: TokenField_freg1,
}
impl FPR132Var61 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 29i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1040:1"]
#[derive(Clone, Debug)]
struct FPR132Var62 {
    freg1: TokenField_freg1,
}
impl FPR132Var62 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 30i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1041:1"]
#[derive(Clone, Debug)]
struct FPR132Var63 {
    freg1: TokenField_freg1,
}
impl FPR132Var63 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg1.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr1x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr1half().disassembly() != 31i64 {
            return None;
        }
        let freg1 = token_parser.TokenFieldfreg1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg1 }))
    }
}
#[derive(Clone, Debug)]
enum TableFPR132 {
    Var0(FPR132Var0),
    Var1(FPR132Var1),
    Var2(FPR132Var2),
    Var3(FPR132Var3),
    Var4(FPR132Var4),
    Var5(FPR132Var5),
    Var6(FPR132Var6),
    Var7(FPR132Var7),
    Var8(FPR132Var8),
    Var9(FPR132Var9),
    Var10(FPR132Var10),
    Var11(FPR132Var11),
    Var12(FPR132Var12),
    Var13(FPR132Var13),
    Var14(FPR132Var14),
    Var15(FPR132Var15),
    Var16(FPR132Var16),
    Var17(FPR132Var17),
    Var18(FPR132Var18),
    Var19(FPR132Var19),
    Var20(FPR132Var20),
    Var21(FPR132Var21),
    Var22(FPR132Var22),
    Var23(FPR132Var23),
    Var24(FPR132Var24),
    Var25(FPR132Var25),
    Var26(FPR132Var26),
    Var27(FPR132Var27),
    Var28(FPR132Var28),
    Var29(FPR132Var29),
    Var30(FPR132Var30),
    Var31(FPR132Var31),
    Var32(FPR132Var32),
    Var33(FPR132Var33),
    Var34(FPR132Var34),
    Var35(FPR132Var35),
    Var36(FPR132Var36),
    Var37(FPR132Var37),
    Var38(FPR132Var38),
    Var39(FPR132Var39),
    Var40(FPR132Var40),
    Var41(FPR132Var41),
    Var42(FPR132Var42),
    Var43(FPR132Var43),
    Var44(FPR132Var44),
    Var45(FPR132Var45),
    Var46(FPR132Var46),
    Var47(FPR132Var47),
    Var48(FPR132Var48),
    Var49(FPR132Var49),
    Var50(FPR132Var50),
    Var51(FPR132Var51),
    Var52(FPR132Var52),
    Var53(FPR132Var53),
    Var54(FPR132Var54),
    Var55(FPR132Var55),
    Var56(FPR132Var56),
    Var57(FPR132Var57),
    Var58(FPR132Var58),
    Var59(FPR132Var59),
    Var60(FPR132Var60),
    Var61(FPR132Var61),
    Var62(FPR132Var62),
    Var63(FPR132Var63),
}
impl TableFPR132 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var18(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var19(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var20(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var21(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var22(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var23(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var24(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var25(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var26(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var27(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var28(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var29(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var30(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var31(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var32(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var33(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var34(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var35(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var36(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var37(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var38(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var39(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var40(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var41(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var42(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var43(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var44(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var45(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var46(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var47(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var48(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var49(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var50(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var51(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var52(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var53(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var54(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var55(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var56(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var57(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var58(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var59(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var60(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var61(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var62(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var63(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            FPR132Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var12::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var13::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var14::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var15::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var16::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var16(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var17::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var17(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var18::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var18(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var19::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var19(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var20::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var20(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var21::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var21(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var22::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var22(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var23::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var23(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var24::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var24(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var25::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var25(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var26::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var26(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var27::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var27(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var28::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var28(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var29::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var29(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var30::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var30(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var31::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var31(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var32::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var32(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var33::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var33(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var34::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var34(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var35::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var35(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var36::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var36(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var37::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var37(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var38::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var38(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var39::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var39(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var40::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var40(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var41::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var41(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var42::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var42(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var43::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var43(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var44::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var44(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var45::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var45(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var46::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var46(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var47::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var47(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var48::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var48(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var49::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var49(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var50::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var50(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var51::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var51(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var52::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var52(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var53::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var53(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var54::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var54(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var55::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var55(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var56::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var56(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var57::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var57(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var58::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var58(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var59::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var59(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var60::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var60(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var61::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var61(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var62::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var62(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR132Var63::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var63(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1043:1"]
#[derive(Clone, Debug)]
struct FPR232Var0 {
    freg2: TokenField_freg2,
}
impl FPR232Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 0i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1044:1"]
#[derive(Clone, Debug)]
struct FPR232Var1 {
    freg2: TokenField_freg2,
}
impl FPR232Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 1i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1045:1"]
#[derive(Clone, Debug)]
struct FPR232Var2 {
    freg2: TokenField_freg2,
}
impl FPR232Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 2i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1046:1"]
#[derive(Clone, Debug)]
struct FPR232Var3 {
    freg2: TokenField_freg2,
}
impl FPR232Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 3i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1047:1"]
#[derive(Clone, Debug)]
struct FPR232Var4 {
    freg2: TokenField_freg2,
}
impl FPR232Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 4i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1048:1"]
#[derive(Clone, Debug)]
struct FPR232Var5 {
    freg2: TokenField_freg2,
}
impl FPR232Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 5i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1049:1"]
#[derive(Clone, Debug)]
struct FPR232Var6 {
    freg2: TokenField_freg2,
}
impl FPR232Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 6i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1050:1"]
#[derive(Clone, Debug)]
struct FPR232Var7 {
    freg2: TokenField_freg2,
}
impl FPR232Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 7i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1051:1"]
#[derive(Clone, Debug)]
struct FPR232Var8 {
    freg2: TokenField_freg2,
}
impl FPR232Var8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 8i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1052:1"]
#[derive(Clone, Debug)]
struct FPR232Var9 {
    freg2: TokenField_freg2,
}
impl FPR232Var9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 9i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1053:1"]
#[derive(Clone, Debug)]
struct FPR232Var10 {
    freg2: TokenField_freg2,
}
impl FPR232Var10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 10i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1054:1"]
#[derive(Clone, Debug)]
struct FPR232Var11 {
    freg2: TokenField_freg2,
}
impl FPR232Var11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 11i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1055:1"]
#[derive(Clone, Debug)]
struct FPR232Var12 {
    freg2: TokenField_freg2,
}
impl FPR232Var12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 12i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1056:1"]
#[derive(Clone, Debug)]
struct FPR232Var13 {
    freg2: TokenField_freg2,
}
impl FPR232Var13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 13i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1057:1"]
#[derive(Clone, Debug)]
struct FPR232Var14 {
    freg2: TokenField_freg2,
}
impl FPR232Var14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 14i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1058:1"]
#[derive(Clone, Debug)]
struct FPR232Var15 {
    freg2: TokenField_freg2,
}
impl FPR232Var15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 15i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1059:1"]
#[derive(Clone, Debug)]
struct FPR232Var16 {
    freg2: TokenField_freg2,
}
impl FPR232Var16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 16i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1060:1"]
#[derive(Clone, Debug)]
struct FPR232Var17 {
    freg2: TokenField_freg2,
}
impl FPR232Var17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 17i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1061:1"]
#[derive(Clone, Debug)]
struct FPR232Var18 {
    freg2: TokenField_freg2,
}
impl FPR232Var18 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 18i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1062:1"]
#[derive(Clone, Debug)]
struct FPR232Var19 {
    freg2: TokenField_freg2,
}
impl FPR232Var19 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 19i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1063:1"]
#[derive(Clone, Debug)]
struct FPR232Var20 {
    freg2: TokenField_freg2,
}
impl FPR232Var20 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 20i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1064:1"]
#[derive(Clone, Debug)]
struct FPR232Var21 {
    freg2: TokenField_freg2,
}
impl FPR232Var21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 21i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1065:1"]
#[derive(Clone, Debug)]
struct FPR232Var22 {
    freg2: TokenField_freg2,
}
impl FPR232Var22 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 22i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1066:1"]
#[derive(Clone, Debug)]
struct FPR232Var23 {
    freg2: TokenField_freg2,
}
impl FPR232Var23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 23i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1067:1"]
#[derive(Clone, Debug)]
struct FPR232Var24 {
    freg2: TokenField_freg2,
}
impl FPR232Var24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 24i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1068:1"]
#[derive(Clone, Debug)]
struct FPR232Var25 {
    freg2: TokenField_freg2,
}
impl FPR232Var25 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 25i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1069:1"]
#[derive(Clone, Debug)]
struct FPR232Var26 {
    freg2: TokenField_freg2,
}
impl FPR232Var26 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 26i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1070:1"]
#[derive(Clone, Debug)]
struct FPR232Var27 {
    freg2: TokenField_freg2,
}
impl FPR232Var27 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 27i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1071:1"]
#[derive(Clone, Debug)]
struct FPR232Var28 {
    freg2: TokenField_freg2,
}
impl FPR232Var28 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 28i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1072:1"]
#[derive(Clone, Debug)]
struct FPR232Var29 {
    freg2: TokenField_freg2,
}
impl FPR232Var29 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 29i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1073:1"]
#[derive(Clone, Debug)]
struct FPR232Var30 {
    freg2: TokenField_freg2,
}
impl FPR232Var30 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 30i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1074:1"]
#[derive(Clone, Debug)]
struct FPR232Var31 {
    freg2: TokenField_freg2,
}
impl FPR232Var31 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 31i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1076:1"]
#[derive(Clone, Debug)]
struct FPR232Var32 {
    freg2: TokenField_freg2,
}
impl FPR232Var32 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 0i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1077:1"]
#[derive(Clone, Debug)]
struct FPR232Var33 {
    freg2: TokenField_freg2,
}
impl FPR232Var33 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 1i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1078:1"]
#[derive(Clone, Debug)]
struct FPR232Var34 {
    freg2: TokenField_freg2,
}
impl FPR232Var34 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 2i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1079:1"]
#[derive(Clone, Debug)]
struct FPR232Var35 {
    freg2: TokenField_freg2,
}
impl FPR232Var35 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 3i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1080:1"]
#[derive(Clone, Debug)]
struct FPR232Var36 {
    freg2: TokenField_freg2,
}
impl FPR232Var36 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 4i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1081:1"]
#[derive(Clone, Debug)]
struct FPR232Var37 {
    freg2: TokenField_freg2,
}
impl FPR232Var37 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 5i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1082:1"]
#[derive(Clone, Debug)]
struct FPR232Var38 {
    freg2: TokenField_freg2,
}
impl FPR232Var38 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 6i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1083:1"]
#[derive(Clone, Debug)]
struct FPR232Var39 {
    freg2: TokenField_freg2,
}
impl FPR232Var39 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 7i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1084:1"]
#[derive(Clone, Debug)]
struct FPR232Var40 {
    freg2: TokenField_freg2,
}
impl FPR232Var40 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 8i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1085:1"]
#[derive(Clone, Debug)]
struct FPR232Var41 {
    freg2: TokenField_freg2,
}
impl FPR232Var41 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 9i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1086:1"]
#[derive(Clone, Debug)]
struct FPR232Var42 {
    freg2: TokenField_freg2,
}
impl FPR232Var42 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 10i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1087:1"]
#[derive(Clone, Debug)]
struct FPR232Var43 {
    freg2: TokenField_freg2,
}
impl FPR232Var43 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 11i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1088:1"]
#[derive(Clone, Debug)]
struct FPR232Var44 {
    freg2: TokenField_freg2,
}
impl FPR232Var44 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 12i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1089:1"]
#[derive(Clone, Debug)]
struct FPR232Var45 {
    freg2: TokenField_freg2,
}
impl FPR232Var45 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 13i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1090:1"]
#[derive(Clone, Debug)]
struct FPR232Var46 {
    freg2: TokenField_freg2,
}
impl FPR232Var46 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 14i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1091:1"]
#[derive(Clone, Debug)]
struct FPR232Var47 {
    freg2: TokenField_freg2,
}
impl FPR232Var47 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 15i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1092:1"]
#[derive(Clone, Debug)]
struct FPR232Var48 {
    freg2: TokenField_freg2,
}
impl FPR232Var48 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 16i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1093:1"]
#[derive(Clone, Debug)]
struct FPR232Var49 {
    freg2: TokenField_freg2,
}
impl FPR232Var49 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 17i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1094:1"]
#[derive(Clone, Debug)]
struct FPR232Var50 {
    freg2: TokenField_freg2,
}
impl FPR232Var50 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 18i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1095:1"]
#[derive(Clone, Debug)]
struct FPR232Var51 {
    freg2: TokenField_freg2,
}
impl FPR232Var51 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 19i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1096:1"]
#[derive(Clone, Debug)]
struct FPR232Var52 {
    freg2: TokenField_freg2,
}
impl FPR232Var52 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 20i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1097:1"]
#[derive(Clone, Debug)]
struct FPR232Var53 {
    freg2: TokenField_freg2,
}
impl FPR232Var53 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 21i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1098:1"]
#[derive(Clone, Debug)]
struct FPR232Var54 {
    freg2: TokenField_freg2,
}
impl FPR232Var54 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 22i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1099:1"]
#[derive(Clone, Debug)]
struct FPR232Var55 {
    freg2: TokenField_freg2,
}
impl FPR232Var55 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 23i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1100:1"]
#[derive(Clone, Debug)]
struct FPR232Var56 {
    freg2: TokenField_freg2,
}
impl FPR232Var56 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 24i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1101:1"]
#[derive(Clone, Debug)]
struct FPR232Var57 {
    freg2: TokenField_freg2,
}
impl FPR232Var57 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 25i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1102:1"]
#[derive(Clone, Debug)]
struct FPR232Var58 {
    freg2: TokenField_freg2,
}
impl FPR232Var58 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 26i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1103:1"]
#[derive(Clone, Debug)]
struct FPR232Var59 {
    freg2: TokenField_freg2,
}
impl FPR232Var59 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 27i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1104:1"]
#[derive(Clone, Debug)]
struct FPR232Var60 {
    freg2: TokenField_freg2,
}
impl FPR232Var60 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 28i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1105:1"]
#[derive(Clone, Debug)]
struct FPR232Var61 {
    freg2: TokenField_freg2,
}
impl FPR232Var61 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 29i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1106:1"]
#[derive(Clone, Debug)]
struct FPR232Var62 {
    freg2: TokenField_freg2,
}
impl FPR232Var62 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 30i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1107:1"]
#[derive(Clone, Debug)]
struct FPR232Var63 {
    freg2: TokenField_freg2,
}
impl FPR232Var63 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.freg2.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpr2x().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfr2half().disassembly() != 31i64 {
            return None;
        }
        let freg2 = token_parser.TokenFieldfreg2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { freg2 }))
    }
}
#[derive(Clone, Debug)]
enum TableFPR232 {
    Var0(FPR232Var0),
    Var1(FPR232Var1),
    Var2(FPR232Var2),
    Var3(FPR232Var3),
    Var4(FPR232Var4),
    Var5(FPR232Var5),
    Var6(FPR232Var6),
    Var7(FPR232Var7),
    Var8(FPR232Var8),
    Var9(FPR232Var9),
    Var10(FPR232Var10),
    Var11(FPR232Var11),
    Var12(FPR232Var12),
    Var13(FPR232Var13),
    Var14(FPR232Var14),
    Var15(FPR232Var15),
    Var16(FPR232Var16),
    Var17(FPR232Var17),
    Var18(FPR232Var18),
    Var19(FPR232Var19),
    Var20(FPR232Var20),
    Var21(FPR232Var21),
    Var22(FPR232Var22),
    Var23(FPR232Var23),
    Var24(FPR232Var24),
    Var25(FPR232Var25),
    Var26(FPR232Var26),
    Var27(FPR232Var27),
    Var28(FPR232Var28),
    Var29(FPR232Var29),
    Var30(FPR232Var30),
    Var31(FPR232Var31),
    Var32(FPR232Var32),
    Var33(FPR232Var33),
    Var34(FPR232Var34),
    Var35(FPR232Var35),
    Var36(FPR232Var36),
    Var37(FPR232Var37),
    Var38(FPR232Var38),
    Var39(FPR232Var39),
    Var40(FPR232Var40),
    Var41(FPR232Var41),
    Var42(FPR232Var42),
    Var43(FPR232Var43),
    Var44(FPR232Var44),
    Var45(FPR232Var45),
    Var46(FPR232Var46),
    Var47(FPR232Var47),
    Var48(FPR232Var48),
    Var49(FPR232Var49),
    Var50(FPR232Var50),
    Var51(FPR232Var51),
    Var52(FPR232Var52),
    Var53(FPR232Var53),
    Var54(FPR232Var54),
    Var55(FPR232Var55),
    Var56(FPR232Var56),
    Var57(FPR232Var57),
    Var58(FPR232Var58),
    Var59(FPR232Var59),
    Var60(FPR232Var60),
    Var61(FPR232Var61),
    Var62(FPR232Var62),
    Var63(FPR232Var63),
}
impl TableFPR232 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var18(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var19(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var20(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var21(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var22(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var23(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var24(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var25(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var26(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var27(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var28(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var29(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var30(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var31(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var32(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var33(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var34(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var35(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var36(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var37(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var38(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var39(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var40(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var41(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var42(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var43(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var44(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var45(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var46(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var47(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var48(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var49(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var50(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var51(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var52(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var53(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var54(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var55(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var56(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var57(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var58(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var59(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var60(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var61(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var62(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var63(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            FPR232Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var12::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var13::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var14::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var15::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var16::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var16(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var17::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var17(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var18::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var18(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var19::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var19(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var20::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var20(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var21::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var21(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var22::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var22(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var23::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var23(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var24::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var24(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var25::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var25(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var26::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var26(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var27::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var27(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var28::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var28(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var29::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var29(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var30::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var30(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var31::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var31(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var32::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var32(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var33::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var33(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var34::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var34(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var35::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var35(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var36::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var36(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var37::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var37(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var38::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var38(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var39::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var39(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var40::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var40(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var41::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var41(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var42::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var42(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var43::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var43(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var44::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var44(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var45::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var45(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var46::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var46(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var47::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var47(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var48::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var48(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var49::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var49(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var50::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var50(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var51::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var51(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var52::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var52(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var53::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var53(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var54::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var54(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var55::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var55(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var56::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var56(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var57::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var57(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var58::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var58(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var59::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var59(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var60::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var60(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var61::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var61(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var62::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var62(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPR232Var63::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var63(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1109:1"]
#[derive(Clone, Debug)]
struct FPRT32Var0 {
    fpt: TokenField_fpt,
}
impl FPRT32Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 0i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1110:1"]
#[derive(Clone, Debug)]
struct FPRT32Var1 {
    fpt: TokenField_fpt,
}
impl FPRT32Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 1i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1111:1"]
#[derive(Clone, Debug)]
struct FPRT32Var2 {
    fpt: TokenField_fpt,
}
impl FPRT32Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 2i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1112:1"]
#[derive(Clone, Debug)]
struct FPRT32Var3 {
    fpt: TokenField_fpt,
}
impl FPRT32Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 3i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1113:1"]
#[derive(Clone, Debug)]
struct FPRT32Var4 {
    fpt: TokenField_fpt,
}
impl FPRT32Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 4i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1114:1"]
#[derive(Clone, Debug)]
struct FPRT32Var5 {
    fpt: TokenField_fpt,
}
impl FPRT32Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 5i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1115:1"]
#[derive(Clone, Debug)]
struct FPRT32Var6 {
    fpt: TokenField_fpt,
}
impl FPRT32Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 6i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1116:1"]
#[derive(Clone, Debug)]
struct FPRT32Var7 {
    fpt: TokenField_fpt,
}
impl FPRT32Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 7i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1117:1"]
#[derive(Clone, Debug)]
struct FPRT32Var8 {
    fpt: TokenField_fpt,
}
impl FPRT32Var8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 8i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1118:1"]
#[derive(Clone, Debug)]
struct FPRT32Var9 {
    fpt: TokenField_fpt,
}
impl FPRT32Var9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 9i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1119:1"]
#[derive(Clone, Debug)]
struct FPRT32Var10 {
    fpt: TokenField_fpt,
}
impl FPRT32Var10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 10i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1120:1"]
#[derive(Clone, Debug)]
struct FPRT32Var11 {
    fpt: TokenField_fpt,
}
impl FPRT32Var11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 11i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1121:1"]
#[derive(Clone, Debug)]
struct FPRT32Var12 {
    fpt: TokenField_fpt,
}
impl FPRT32Var12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 12i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1122:1"]
#[derive(Clone, Debug)]
struct FPRT32Var13 {
    fpt: TokenField_fpt,
}
impl FPRT32Var13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 13i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1123:1"]
#[derive(Clone, Debug)]
struct FPRT32Var14 {
    fpt: TokenField_fpt,
}
impl FPRT32Var14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 14i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1124:1"]
#[derive(Clone, Debug)]
struct FPRT32Var15 {
    fpt: TokenField_fpt,
}
impl FPRT32Var15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 15i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1125:1"]
#[derive(Clone, Debug)]
struct FPRT32Var16 {
    fpt: TokenField_fpt,
}
impl FPRT32Var16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 16i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1126:1"]
#[derive(Clone, Debug)]
struct FPRT32Var17 {
    fpt: TokenField_fpt,
}
impl FPRT32Var17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 17i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1127:1"]
#[derive(Clone, Debug)]
struct FPRT32Var18 {
    fpt: TokenField_fpt,
}
impl FPRT32Var18 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 18i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1128:1"]
#[derive(Clone, Debug)]
struct FPRT32Var19 {
    fpt: TokenField_fpt,
}
impl FPRT32Var19 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 19i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1129:1"]
#[derive(Clone, Debug)]
struct FPRT32Var20 {
    fpt: TokenField_fpt,
}
impl FPRT32Var20 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 20i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1130:1"]
#[derive(Clone, Debug)]
struct FPRT32Var21 {
    fpt: TokenField_fpt,
}
impl FPRT32Var21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 21i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1131:1"]
#[derive(Clone, Debug)]
struct FPRT32Var22 {
    fpt: TokenField_fpt,
}
impl FPRT32Var22 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 22i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1132:1"]
#[derive(Clone, Debug)]
struct FPRT32Var23 {
    fpt: TokenField_fpt,
}
impl FPRT32Var23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 23i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1133:1"]
#[derive(Clone, Debug)]
struct FPRT32Var24 {
    fpt: TokenField_fpt,
}
impl FPRT32Var24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 24i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1134:1"]
#[derive(Clone, Debug)]
struct FPRT32Var25 {
    fpt: TokenField_fpt,
}
impl FPRT32Var25 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 25i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1135:1"]
#[derive(Clone, Debug)]
struct FPRT32Var26 {
    fpt: TokenField_fpt,
}
impl FPRT32Var26 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 26i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1136:1"]
#[derive(Clone, Debug)]
struct FPRT32Var27 {
    fpt: TokenField_fpt,
}
impl FPRT32Var27 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 27i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1137:1"]
#[derive(Clone, Debug)]
struct FPRT32Var28 {
    fpt: TokenField_fpt,
}
impl FPRT32Var28 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 28i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1138:1"]
#[derive(Clone, Debug)]
struct FPRT32Var29 {
    fpt: TokenField_fpt,
}
impl FPRT32Var29 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 29i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1139:1"]
#[derive(Clone, Debug)]
struct FPRT32Var30 {
    fpt: TokenField_fpt,
}
impl FPRT32Var30 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 30i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1140:1"]
#[derive(Clone, Debug)]
struct FPRT32Var31 {
    fpt: TokenField_fpt,
}
impl FPRT32Var31 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("L")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 31i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1143:1"]
#[derive(Clone, Debug)]
struct FPRT32Var32 {
    fpt: TokenField_fpt,
}
impl FPRT32Var32 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 0i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1144:1"]
#[derive(Clone, Debug)]
struct FPRT32Var33 {
    fpt: TokenField_fpt,
}
impl FPRT32Var33 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 1i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1145:1"]
#[derive(Clone, Debug)]
struct FPRT32Var34 {
    fpt: TokenField_fpt,
}
impl FPRT32Var34 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 2i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1146:1"]
#[derive(Clone, Debug)]
struct FPRT32Var35 {
    fpt: TokenField_fpt,
}
impl FPRT32Var35 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 3i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1147:1"]
#[derive(Clone, Debug)]
struct FPRT32Var36 {
    fpt: TokenField_fpt,
}
impl FPRT32Var36 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 4i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1148:1"]
#[derive(Clone, Debug)]
struct FPRT32Var37 {
    fpt: TokenField_fpt,
}
impl FPRT32Var37 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 5i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1149:1"]
#[derive(Clone, Debug)]
struct FPRT32Var38 {
    fpt: TokenField_fpt,
}
impl FPRT32Var38 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 6i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1150:1"]
#[derive(Clone, Debug)]
struct FPRT32Var39 {
    fpt: TokenField_fpt,
}
impl FPRT32Var39 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 7i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1151:1"]
#[derive(Clone, Debug)]
struct FPRT32Var40 {
    fpt: TokenField_fpt,
}
impl FPRT32Var40 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 8i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1152:1"]
#[derive(Clone, Debug)]
struct FPRT32Var41 {
    fpt: TokenField_fpt,
}
impl FPRT32Var41 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 9i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1153:1"]
#[derive(Clone, Debug)]
struct FPRT32Var42 {
    fpt: TokenField_fpt,
}
impl FPRT32Var42 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 10i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1154:1"]
#[derive(Clone, Debug)]
struct FPRT32Var43 {
    fpt: TokenField_fpt,
}
impl FPRT32Var43 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 11i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1155:1"]
#[derive(Clone, Debug)]
struct FPRT32Var44 {
    fpt: TokenField_fpt,
}
impl FPRT32Var44 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 12i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1156:1"]
#[derive(Clone, Debug)]
struct FPRT32Var45 {
    fpt: TokenField_fpt,
}
impl FPRT32Var45 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 13i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1157:1"]
#[derive(Clone, Debug)]
struct FPRT32Var46 {
    fpt: TokenField_fpt,
}
impl FPRT32Var46 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 14i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1158:1"]
#[derive(Clone, Debug)]
struct FPRT32Var47 {
    fpt: TokenField_fpt,
}
impl FPRT32Var47 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 15i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1159:1"]
#[derive(Clone, Debug)]
struct FPRT32Var48 {
    fpt: TokenField_fpt,
}
impl FPRT32Var48 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 16i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1160:1"]
#[derive(Clone, Debug)]
struct FPRT32Var49 {
    fpt: TokenField_fpt,
}
impl FPRT32Var49 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 17i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1161:1"]
#[derive(Clone, Debug)]
struct FPRT32Var50 {
    fpt: TokenField_fpt,
}
impl FPRT32Var50 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 18i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1162:1"]
#[derive(Clone, Debug)]
struct FPRT32Var51 {
    fpt: TokenField_fpt,
}
impl FPRT32Var51 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 19i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1163:1"]
#[derive(Clone, Debug)]
struct FPRT32Var52 {
    fpt: TokenField_fpt,
}
impl FPRT32Var52 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 20i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1164:1"]
#[derive(Clone, Debug)]
struct FPRT32Var53 {
    fpt: TokenField_fpt,
}
impl FPRT32Var53 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 21i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1165:1"]
#[derive(Clone, Debug)]
struct FPRT32Var54 {
    fpt: TokenField_fpt,
}
impl FPRT32Var54 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 22i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1166:1"]
#[derive(Clone, Debug)]
struct FPRT32Var55 {
    fpt: TokenField_fpt,
}
impl FPRT32Var55 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 23i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1167:1"]
#[derive(Clone, Debug)]
struct FPRT32Var56 {
    fpt: TokenField_fpt,
}
impl FPRT32Var56 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 24i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1168:1"]
#[derive(Clone, Debug)]
struct FPRT32Var57 {
    fpt: TokenField_fpt,
}
impl FPRT32Var57 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 25i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1169:1"]
#[derive(Clone, Debug)]
struct FPRT32Var58 {
    fpt: TokenField_fpt,
}
impl FPRT32Var58 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 26i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1170:1"]
#[derive(Clone, Debug)]
struct FPRT32Var59 {
    fpt: TokenField_fpt,
}
impl FPRT32Var59 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 27i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1171:1"]
#[derive(Clone, Debug)]
struct FPRT32Var60 {
    fpt: TokenField_fpt,
}
impl FPRT32Var60 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 28i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1172:1"]
#[derive(Clone, Debug)]
struct FPRT32Var61 {
    fpt: TokenField_fpt,
}
impl FPRT32Var61 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 29i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1173:1"]
#[derive(Clone, Debug)]
struct FPRT32Var62 {
    fpt: TokenField_fpt,
}
impl FPRT32Var62 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 30i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1174:1"]
#[derive(Clone, Debug)]
struct FPRT32Var63 {
    fpt: TokenField_fpt,
}
impl FPRT32Var63 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.fpt.display(), DisplayElement::Literal("R")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfptx().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldfpthalf().disassembly() != 31i64 {
            return None;
        }
        let fpt = token_parser.TokenFieldfpt();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fpt }))
    }
}
#[derive(Clone, Debug)]
enum TableFPRT32 {
    Var0(FPRT32Var0),
    Var1(FPRT32Var1),
    Var2(FPRT32Var2),
    Var3(FPRT32Var3),
    Var4(FPRT32Var4),
    Var5(FPRT32Var5),
    Var6(FPRT32Var6),
    Var7(FPRT32Var7),
    Var8(FPRT32Var8),
    Var9(FPRT32Var9),
    Var10(FPRT32Var10),
    Var11(FPRT32Var11),
    Var12(FPRT32Var12),
    Var13(FPRT32Var13),
    Var14(FPRT32Var14),
    Var15(FPRT32Var15),
    Var16(FPRT32Var16),
    Var17(FPRT32Var17),
    Var18(FPRT32Var18),
    Var19(FPRT32Var19),
    Var20(FPRT32Var20),
    Var21(FPRT32Var21),
    Var22(FPRT32Var22),
    Var23(FPRT32Var23),
    Var24(FPRT32Var24),
    Var25(FPRT32Var25),
    Var26(FPRT32Var26),
    Var27(FPRT32Var27),
    Var28(FPRT32Var28),
    Var29(FPRT32Var29),
    Var30(FPRT32Var30),
    Var31(FPRT32Var31),
    Var32(FPRT32Var32),
    Var33(FPRT32Var33),
    Var34(FPRT32Var34),
    Var35(FPRT32Var35),
    Var36(FPRT32Var36),
    Var37(FPRT32Var37),
    Var38(FPRT32Var38),
    Var39(FPRT32Var39),
    Var40(FPRT32Var40),
    Var41(FPRT32Var41),
    Var42(FPRT32Var42),
    Var43(FPRT32Var43),
    Var44(FPRT32Var44),
    Var45(FPRT32Var45),
    Var46(FPRT32Var46),
    Var47(FPRT32Var47),
    Var48(FPRT32Var48),
    Var49(FPRT32Var49),
    Var50(FPRT32Var50),
    Var51(FPRT32Var51),
    Var52(FPRT32Var52),
    Var53(FPRT32Var53),
    Var54(FPRT32Var54),
    Var55(FPRT32Var55),
    Var56(FPRT32Var56),
    Var57(FPRT32Var57),
    Var58(FPRT32Var58),
    Var59(FPRT32Var59),
    Var60(FPRT32Var60),
    Var61(FPRT32Var61),
    Var62(FPRT32Var62),
    Var63(FPRT32Var63),
}
impl TableFPRT32 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var18(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var19(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var20(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var21(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var22(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var23(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var24(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var25(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var26(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var27(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var28(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var29(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var30(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var31(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var32(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var33(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var34(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var35(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var36(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var37(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var38(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var39(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var40(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var41(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var42(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var43(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var44(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var45(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var46(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var47(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var48(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var49(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var50(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var51(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var52(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var53(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var54(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var55(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var56(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var57(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var58(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var59(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var60(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var61(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var62(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var63(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            FPRT32Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var12::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var13::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var14::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var15::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var16::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var16(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var17::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var17(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var18::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var18(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var19::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var19(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var20::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var20(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var21::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var21(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var22::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var22(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var23::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var23(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var24::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var24(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var25::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var25(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var26::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var26(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var27::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var27(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var28::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var28(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var29::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var29(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var30::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var30(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var31::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var31(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var32::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var32(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var33::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var33(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var34::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var34(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var35::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var35(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var36::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var36(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var37::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var37(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var38::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var38(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var39::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var39(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var40::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var40(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var41::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var41(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var42::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var42(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var43::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var43(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var44::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var44(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var45::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var45(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var46::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var46(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var47::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var47(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var48::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var48(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var49::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var49(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var50::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var50(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var51::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var51(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var52::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var52(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var53::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var53(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var54::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var54(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var55::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var55(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var56::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var56(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var57::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var57(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var58::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var58(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var59::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var59(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var60::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var60(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var61::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var61(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var62::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var62(parsed)));
        }
        if let Some((inst_len, parsed)) =
            FPRT32Var63::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var63(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1177:1"]
#[derive(Clone, Debug)]
struct fpcmpVar0 {}
impl fpcmpVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",FALSE?")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1178:1"]
#[derive(Clone, Debug)]
struct fpcmpVar1 {}
impl fpcmpVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",false")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1179:1"]
#[derive(Clone, Debug)]
struct fpcmpVar2 {}
impl fpcmpVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",?")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 2i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1180:1"]
#[derive(Clone, Debug)]
struct fpcmpVar3 {}
impl fpcmpVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!<=>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 3i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1181:1"]
#[derive(Clone, Debug)]
struct fpcmpVar4 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 4i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1182:1"]
#[derive(Clone, Debug)]
struct fpcmpVar5 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",=T")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 5i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1183:1"]
#[derive(Clone, Debug)]
struct fpcmpVar6 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",?=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 6i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1184:1"]
#[derive(Clone, Debug)]
struct fpcmpVar7 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!<>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 7i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1185:1"]
#[derive(Clone, Debug)]
struct fpcmpVar8 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!?>=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 8i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1186:1"]
#[derive(Clone, Debug)]
struct fpcmpVar9 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",<")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 9i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1187:1"]
#[derive(Clone, Debug)]
struct fpcmpVar10 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",?<")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 10i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1188:1"]
#[derive(Clone, Debug)]
struct fpcmpVar11 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!>=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 11i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1189:1"]
#[derive(Clone, Debug)]
struct fpcmpVar12 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!?>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 12i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1190:1"]
#[derive(Clone, Debug)]
struct fpcmpVar13 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",<=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 13i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1191:1"]
#[derive(Clone, Debug)]
struct fpcmpVar14 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",?<=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 14i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1192:1"]
#[derive(Clone, Debug)]
struct fpcmpVar15 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",!>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 15i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1193:1"]
#[derive(Clone, Debug)]
struct fpcmpVar16 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!?<=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 16i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1194:1"]
#[derive(Clone, Debug)]
struct fpcmpVar17 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 17i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1195:1"]
#[derive(Clone, Debug)]
struct fpcmpVar18 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar18 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",?>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 18i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1196:1"]
#[derive(Clone, Debug)]
struct fpcmpVar19 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar19 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!<=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 19i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1197:1"]
#[derive(Clone, Debug)]
struct fpcmpVar20 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar20 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!?<")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 20i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1198:1"]
#[derive(Clone, Debug)]
struct fpcmpVar21 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",>=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 21i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1199:1"]
#[derive(Clone, Debug)]
struct fpcmpVar22 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar22 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",?>=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 22i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1200:1"]
#[derive(Clone, Debug)]
struct fpcmpVar23 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!<;")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 23i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1201:1"]
#[derive(Clone, Debug)]
struct fpcmpVar24 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!?=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 24i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1202:1"]
#[derive(Clone, Debug)]
struct fpcmpVar25 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar25 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",<>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 25i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1203:1"]
#[derive(Clone, Debug)]
struct fpcmpVar26 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar26 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",!=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 26i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1204:1"]
#[derive(Clone, Debug)]
struct fpcmpVar27 {
    FPR132: TableFPR132,
    FPR232: TableFPR232,
}
impl fpcmpVar27 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!=T")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 27i64 {
            return None;
        }
        let FPR132 = if let Some((len, table)) = TableFPR132::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR232 = if let Some((len, table)) = TableFPR232::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR132, FPR232 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1205:1"]
#[derive(Clone, Debug)]
struct fpcmpVar28 {}
impl fpcmpVar28 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",!?")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 28i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1206:1"]
#[derive(Clone, Debug)]
struct fpcmpVar29 {}
impl fpcmpVar29 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",<=>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 29i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1207:1"]
#[derive(Clone, Debug)]
struct fpcmpVar30 {}
impl fpcmpVar30 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",TRUE?")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 30i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1208:1"]
#[derive(Clone, Debug)]
struct fpcmpVar31 {}
impl fpcmpVar31 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",TRUE")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 31i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablefpcmp {
    Var0(fpcmpVar0),
    Var1(fpcmpVar1),
    Var2(fpcmpVar2),
    Var3(fpcmpVar3),
    Var4(fpcmpVar4),
    Var5(fpcmpVar5),
    Var6(fpcmpVar6),
    Var7(fpcmpVar7),
    Var8(fpcmpVar8),
    Var9(fpcmpVar9),
    Var10(fpcmpVar10),
    Var11(fpcmpVar11),
    Var12(fpcmpVar12),
    Var13(fpcmpVar13),
    Var14(fpcmpVar14),
    Var15(fpcmpVar15),
    Var16(fpcmpVar16),
    Var17(fpcmpVar17),
    Var18(fpcmpVar18),
    Var19(fpcmpVar19),
    Var20(fpcmpVar20),
    Var21(fpcmpVar21),
    Var22(fpcmpVar22),
    Var23(fpcmpVar23),
    Var24(fpcmpVar24),
    Var25(fpcmpVar25),
    Var26(fpcmpVar26),
    Var27(fpcmpVar27),
    Var28(fpcmpVar28),
    Var29(fpcmpVar29),
    Var30(fpcmpVar30),
    Var31(fpcmpVar31),
}
impl Tablefpcmp {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var18(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var19(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var20(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var21(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var22(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var23(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var24(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var25(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var26(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var27(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var28(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var29(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var30(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var31(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            fpcmpVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar12::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar13::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar14::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar15::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar16::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var16(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar17::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var17(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar18::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var18(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar19::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var19(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar20::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var20(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar21::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var21(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar22::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var22(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar23::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var23(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar24::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var24(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar25::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var25(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar26::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var26(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar27::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var27(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar28::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var28(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar29::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var29(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar30::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var30(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmpVar31::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var31(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1210:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var0 {}
impl fpcmp64Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",FALSE?")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1211:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var1 {}
impl fpcmp64Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",false")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1212:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var2 {}
impl fpcmp64Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",?")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 2i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1213:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var3 {}
impl fpcmp64Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!<=>;")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 3i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1214:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var4 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 4i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1215:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var5 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",=T")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 5i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1216:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var6 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",?=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 6i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1217:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var7 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!<>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 7i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1218:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var8 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!?>=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 8i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1219:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var9 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",<")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 9i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1220:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var10 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",?<")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 10i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1221:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var11 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!>=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 11i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1222:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var12 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!?>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 12i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1223:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var13 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",<=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 13i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1224:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var14 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",?<=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 14i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1225:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var15 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",!>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 15i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1226:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var16 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!?<=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 16i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1227:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var17 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 17i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1228:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var18 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var18 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",?>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 18i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1229:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var19 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var19 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!<=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 19i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1230:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var20 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var20 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!?<")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 20i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1231:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var21 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",>=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 21i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1232:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var22 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var22 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",?>=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 22i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1233:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var23 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",!<")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 23i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1234:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var24 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!?=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 24i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1235:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var25 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var25 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",<>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 25i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1236:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var26 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var26 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",!=")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 26i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1237:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var27 {
    FPR164: TableFPR164,
    FPR264: TableFPR264,
}
impl fpcmp64Var27 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",!=T")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 27i64 {
            return None;
        }
        let FPR164 = if let Some((len, table)) = TableFPR164::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let FPR264 = if let Some((len, table)) = TableFPR264::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FPR164, FPR264 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1238:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var28 {}
impl fpcmp64Var28 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",!?")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 28i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1239:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var29 {}
impl fpcmp64Var29 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",<=>")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 29i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1240:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var30 {}
impl fpcmp64Var30 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",TRUE?")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 30i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1241:1"]
#[derive(Clone, Debug)]
struct fpcmp64Var31 {}
impl fpcmp64Var31 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",TRUE")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfpcond().disassembly() != 31i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablefpcmp64 {
    Var0(fpcmp64Var0),
    Var1(fpcmp64Var1),
    Var2(fpcmp64Var2),
    Var3(fpcmp64Var3),
    Var4(fpcmp64Var4),
    Var5(fpcmp64Var5),
    Var6(fpcmp64Var6),
    Var7(fpcmp64Var7),
    Var8(fpcmp64Var8),
    Var9(fpcmp64Var9),
    Var10(fpcmp64Var10),
    Var11(fpcmp64Var11),
    Var12(fpcmp64Var12),
    Var13(fpcmp64Var13),
    Var14(fpcmp64Var14),
    Var15(fpcmp64Var15),
    Var16(fpcmp64Var16),
    Var17(fpcmp64Var17),
    Var18(fpcmp64Var18),
    Var19(fpcmp64Var19),
    Var20(fpcmp64Var20),
    Var21(fpcmp64Var21),
    Var22(fpcmp64Var22),
    Var23(fpcmp64Var23),
    Var24(fpcmp64Var24),
    Var25(fpcmp64Var25),
    Var26(fpcmp64Var26),
    Var27(fpcmp64Var27),
    Var28(fpcmp64Var28),
    Var29(fpcmp64Var29),
    Var30(fpcmp64Var30),
    Var31(fpcmp64Var31),
}
impl Tablefpcmp64 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var18(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var19(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var20(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var21(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var22(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var23(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var24(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var25(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var26(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var27(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var28(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var29(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var30(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var31(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            fpcmp64Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var12::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var13::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var14::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var15::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var16::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var16(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var17::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var17(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var18::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var18(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var19::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var19(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var20::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var20(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var21::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var21(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var22::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var22(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var23::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var23(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var24::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var24(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var25::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var25(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var26::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var26(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var27::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var27(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var28::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var28(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var29::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var29(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var30::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var30(parsed)));
        }
        if let Some((inst_len, parsed)) =
            fpcmp64Var31::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var31(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1247:1"]
#[derive(Clone, Debug)]
struct SRVar0 {}
impl SRVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("srN")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFields().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1248:1"]
#[derive(Clone, Debug)]
struct SRVar1 {}
impl SRVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr1)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFields().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1249:1"]
#[derive(Clone, Debug)]
struct SRVar2 {}
impl SRVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr2)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFields().disassembly() != 2i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1250:1"]
#[derive(Clone, Debug)]
struct SRVar3 {}
impl SRVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr3)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFields().disassembly() != 3i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSR {
    Var0(SRVar0),
    Var1(SRVar1),
    Var2(SRVar2),
    Var3(SRVar3),
}
impl TableSR {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            SRVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SRVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SRVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SRVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1252:1"]
#[derive(Clone, Debug)]
struct SR3bitVar0 {}
impl SR3bitVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr0)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsrbit2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsrbit1().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsrbit0().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1253:1"]
#[derive(Clone, Debug)]
struct SR3bitVar1 {}
impl SR3bitVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr1)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsrbit2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsrbit1().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsrbit0().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1254:1"]
#[derive(Clone, Debug)]
struct SR3bitVar2 {}
impl SR3bitVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr2)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsrbit2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsrbit1().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsrbit0().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1255:1"]
#[derive(Clone, Debug)]
struct SR3bitVar3 {}
impl SR3bitVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr3)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsrbit2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsrbit1().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsrbit0().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1256:1"]
#[derive(Clone, Debug)]
struct SR3bitVar4 {}
impl SR3bitVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr4)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsrbit2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsrbit1().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsrbit0().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1257:1"]
#[derive(Clone, Debug)]
struct SR3bitVar5 {}
impl SR3bitVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr5)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsrbit2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsrbit1().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldsrbit0().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1258:1"]
#[derive(Clone, Debug)]
struct SR3bitVar6 {}
impl SR3bitVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr6)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsrbit2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsrbit1().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsrbit0().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1259:1"]
#[derive(Clone, Debug)]
struct SR3bitVar7 {}
impl SR3bitVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr7)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldsrbit2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsrbit1().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldsrbit0().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSR3bit {
    Var0(SR3bitVar0),
    Var1(SR3bitVar1),
    Var2(SR3bitVar2),
    Var3(SR3bitVar3),
    Var4(SR3bitVar4),
    Var5(SR3bitVar5),
    Var6(SR3bitVar6),
    Var7(SR3bitVar7),
}
impl TableSR3bit {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            SR3bitVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SR3bitVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SR3bitVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SR3bitVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SR3bitVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SR3bitVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SR3bitVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SR3bitVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1264:1"]
#[derive(Clone, Debug)]
struct SRRBVar0 {
    RB: TableRB,
}
impl SRRBVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFields().disassembly() != 0i64 {
            return None;
        }
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1266:1"]
#[derive(Clone, Debug)]
struct SRRBVar1 {
    SR: TableSR,
    RB: TableRB,
}
impl SRRBVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.SR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let SR = if let Some((len, table)) =
            TableSR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SR, RB }))
    }
}
#[derive(Clone, Debug)]
enum TableSRRB {
    Var0(SRRBVar0),
    Var1(SRRBVar1),
}
impl TableSRRB {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            SRRBVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SRRBVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1269:1"]
#[derive(Clone, Debug)]
struct SRRB3bitVar0 {
    SR3bit: TableSR3bit,
    RB: TableRB,
}
impl SRRB3bitVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.SR3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let SR3bit = if let Some((len, table)) = TableSR3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SR3bit, RB }))
    }
}
#[derive(Clone, Debug)]
enum TableSRRB3bit {
    Var0(SRRB3bitVar0),
}
impl TableSRRB3bit {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            SRRB3bitVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1274:1"]
#[derive(Clone, Debug)]
struct SRVALVar0 {
    SR: TableSR,
    RB: TableRB,
}
impl SRVALVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.SR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFields().disassembly() != 0i64 {
            return None;
        }
        let SR = if let Some((len, table)) =
            TableSR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SR, RB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1281:1"]
#[derive(Clone, Debug)]
struct SRVALVar1 {}
impl SRVALVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr1)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFields().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1282:1"]
#[derive(Clone, Debug)]
struct SRVALVar2 {}
impl SRVALVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr2)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFields().disassembly() != 2i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1283:1"]
#[derive(Clone, Debug)]
struct SRVALVar3 {}
impl SRVALVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sr3)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFields().disassembly() != 3i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSRVAL {
    Var0(SRVALVar0),
    Var1(SRVALVar1),
    Var2(SRVALVar2),
    Var3(SRVALVar3),
}
impl TableSRVAL {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            SRVALVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SRVALVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SRVALVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            SRVALVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1286:1"]
#[derive(Clone, Debug)]
struct SPCBASEVar0 {
    SRVAL: TableSRVAL,
    RB: TableRB,
}
impl SPCBASEVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let SRVAL = if let Some((len, table)) =
            TableSRVAL::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SRVAL, RB }))
    }
}
#[derive(Clone, Debug)]
enum TableSPCBASE {
    Var0(SPCBASEVar0),
}
impl TableSPCBASE {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            SPCBASEVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1298:1"]
#[derive(Clone, Debug)]
struct displacement2WVar0 {
    w: TokenField_w,
    w2: TokenField_w2,
}
impl displacement2WVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut target: i64 = 0;
        target = 1i64
            .wrapping_sub(self.w.disassembly().wrapping_mul(2i64))
            .wrapping_mul(
                ((self.w2.disassembly() & 1i64)
                    .checked_shl(u32::try_from(10i64).unwrap())
                    .unwrap_or(0)
                    | (self
                        .w2
                        .disassembly()
                        .checked_shr(u32::try_from(1i64).unwrap())
                        .unwrap_or(0)
                        & 1023i64)),
            );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, target)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut target: i64 = 0;
        target = 1i64
            .wrapping_sub(
                token_parser.TokenFieldw().disassembly().wrapping_mul(2i64),
            )
            .wrapping_mul(
                ((token_parser.TokenFieldw2().disassembly() & 1i64)
                    .checked_shl(u32::try_from(10i64).unwrap())
                    .unwrap_or(0)
                    | (token_parser
                        .TokenFieldw2()
                        .disassembly()
                        .checked_shr(u32::try_from(1i64).unwrap())
                        .unwrap_or(0)
                        & 1023i64)),
            );
        let w = token_parser.TokenFieldw();
        let w2 = token_parser.TokenFieldw2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { w, w2 }))
    }
}
#[derive(Clone, Debug)]
enum Tabledisplacement2W {
    Var0(displacement2WVar0),
}
impl Tabledisplacement2W {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = displacement2WVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1304:1"]
#[derive(Clone, Debug)]
struct branchTarget2WVar0 {
    w: TokenField_w,
    w2_2: TokenField_w2_2,
    w2less2: TokenField_w2less2,
}
impl branchTarget2WVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut target: i64 = 0;
        target = i64::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i64)
            .wrapping_add(
                4i64.wrapping_mul(
                    (((-1i64)
                        .wrapping_mul(self.w.disassembly())
                        .checked_shl(u32::try_from(11i64).unwrap())
                        .unwrap_or(0)
                        | self
                            .w2_2
                            .disassembly()
                            .checked_shl(u32::try_from(10i64).unwrap())
                            .unwrap_or(0))
                        | self.w2less2.disassembly()),
                ),
            );
        global_set.set_branchImmDest(
            Some(inst_next),
            context.register().read_branchImmDest_disassembly(),
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, target)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut target: i64 = 0;
        target = i64::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i64)
            .wrapping_add(
                4i64.wrapping_mul(
                    (((-1i64)
                        .wrapping_mul(token_parser.TokenFieldw().disassembly())
                        .checked_shl(u32::try_from(11i64).unwrap())
                        .unwrap_or(0)
                        | token_parser
                            .TokenFieldw2_2()
                            .disassembly()
                            .checked_shl(u32::try_from(10i64).unwrap())
                            .unwrap_or(0))
                        | token_parser.TokenFieldw2less2().disassembly()),
                ),
            );
        let tmp = context_instance.register().read_branchImmDest_disassembly();
        context_instance
            .register_mut()
            .write_temp32_disassembly(tmp);
        let tmp = target;
        context_instance
            .register_mut()
            .write_branchImmDest_disassembly(tmp);
        let tmp = context_instance.register().read_temp32_disassembly();
        context_instance
            .register_mut()
            .write_branchImmDest_disassembly(tmp);
        let w = token_parser.TokenFieldw();
        let w2less2 = token_parser.TokenFieldw2less2();
        let w2_2 = token_parser.TokenFieldw2_2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { w, w2less2, w2_2 }))
    }
}
#[derive(Clone, Debug)]
enum TablebranchTarget2W {
    Var0(branchTarget2WVar0),
}
impl TablebranchTarget2W {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = branchTarget2WVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1322:1"]
#[derive(Clone, Debug)]
struct displacement3WVar0 {
    w: TokenField_w,
    w1: TokenField_w1,
    w2_2: TokenField_w2_2,
    w2less2: TokenField_w2less2,
}
impl displacement3WVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut target: i64 = 0;
        target = 4i64.wrapping_mul(
            ((((-1i64)
                .wrapping_mul(self.w.disassembly())
                .checked_shl(u32::try_from(16i64).unwrap())
                .unwrap_or(0)
                | self
                    .w1
                    .disassembly()
                    .checked_shl(u32::try_from(11i64).unwrap())
                    .unwrap_or(0))
                | self
                    .w2_2
                    .disassembly()
                    .checked_shl(u32::try_from(10i64).unwrap())
                    .unwrap_or(0))
                | self.w2less2.disassembly()),
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, target)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut target: i64 = 0;
        target = 4i64.wrapping_mul(
            ((((-1i64)
                .wrapping_mul(token_parser.TokenFieldw().disassembly())
                .checked_shl(u32::try_from(16i64).unwrap())
                .unwrap_or(0)
                | token_parser
                    .TokenFieldw1()
                    .disassembly()
                    .checked_shl(u32::try_from(11i64).unwrap())
                    .unwrap_or(0))
                | token_parser
                    .TokenFieldw2_2()
                    .disassembly()
                    .checked_shl(u32::try_from(10i64).unwrap())
                    .unwrap_or(0))
                | token_parser.TokenFieldw2less2().disassembly()),
        );
        let w = token_parser.TokenFieldw();
        let w1 = token_parser.TokenFieldw1();
        let w2less2 = token_parser.TokenFieldw2less2();
        let w2_2 = token_parser.TokenFieldw2_2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                w,
                w1,
                w2less2,
                w2_2,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum Tabledisplacement3W {
    Var0(displacement3WVar0),
}
impl Tabledisplacement3W {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = displacement3WVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1332:1"]
#[derive(Clone, Debug)]
struct branchTarget3WVar0 {
    w: TokenField_w,
    w1: TokenField_w1,
    w2_2: TokenField_w2_2,
    w2less2: TokenField_w2less2,
}
impl branchTarget3WVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut target: i64 = 0;
        target = i64::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i64)
            .wrapping_add(
                4i64.wrapping_mul(
                    ((((-1i64)
                        .wrapping_mul(self.w.disassembly())
                        .checked_shl(u32::try_from(16i64).unwrap())
                        .unwrap_or(0)
                        | self
                            .w1
                            .disassembly()
                            .checked_shl(u32::try_from(11i64).unwrap())
                            .unwrap_or(0))
                        | self
                            .w2_2
                            .disassembly()
                            .checked_shl(u32::try_from(10i64).unwrap())
                            .unwrap_or(0))
                        | self.w2less2.disassembly()),
                ),
            );
        global_set.set_branchImmDest(
            Some(inst_next),
            context.register().read_branchImmDest_disassembly(),
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, target)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut target: i64 = 0;
        target = i64::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i64)
            .wrapping_add(
                4i64.wrapping_mul(
                    ((((-1i64)
                        .wrapping_mul(token_parser.TokenFieldw().disassembly())
                        .checked_shl(u32::try_from(16i64).unwrap())
                        .unwrap_or(0)
                        | token_parser
                            .TokenFieldw1()
                            .disassembly()
                            .checked_shl(u32::try_from(11i64).unwrap())
                            .unwrap_or(0))
                        | token_parser
                            .TokenFieldw2_2()
                            .disassembly()
                            .checked_shl(u32::try_from(10i64).unwrap())
                            .unwrap_or(0))
                        | token_parser.TokenFieldw2less2().disassembly()),
                ),
            );
        let tmp = context_instance.register().read_branchImmDest_disassembly();
        context_instance
            .register_mut()
            .write_temp32_disassembly(tmp);
        let tmp = target;
        context_instance
            .register_mut()
            .write_branchImmDest_disassembly(tmp);
        let tmp = context_instance.register().read_temp32_disassembly();
        context_instance
            .register_mut()
            .write_branchImmDest_disassembly(tmp);
        let w = token_parser.TokenFieldw();
        let w1 = token_parser.TokenFieldw1();
        let w2less2 = token_parser.TokenFieldw2less2();
        let w2_2 = token_parser.TokenFieldw2_2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                w,
                w1,
                w2less2,
                w2_2,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TablebranchTarget3W {
    Var0(branchTarget3WVar0),
}
impl TablebranchTarget3W {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = branchTarget3WVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1349:1"]
#[derive(Clone, Debug)]
struct IPRelativeIndexedTargetVar0 {
    RX: TableRX,
}
impl IPRelativeIndexedTargetVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX }))
    }
}
#[derive(Clone, Debug)]
enum TableIPRelativeIndexedTarget {
    Var0(IPRelativeIndexedTargetVar0),
}
impl TableIPRelativeIndexedTarget {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = IPRelativeIndexedTargetVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1357:1"]
#[derive(Clone, Debug)]
struct IndexedTargetVar0 {
    RX: TableRX,
    RB: TableRB,
}
impl IndexedTargetVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, RB }))
    }
}
#[derive(Clone, Debug)]
enum TableIndexedTarget {
    Var0(IndexedTargetVar0),
}
impl TableIndexedTarget {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = IndexedTargetVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1365:1"]
#[derive(Clone, Debug)]
struct ReturnTargetVar0 {
    RB: TableRB,
}
impl ReturnTargetVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RB }))
    }
}
#[derive(Clone, Debug)]
enum TableReturnTarget {
    Var0(ReturnTargetVar0),
}
impl TableReturnTarget {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = ReturnTargetVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1372:1"]
#[derive(Clone, Debug)]
struct externalTargetVar0 {
    RB: TableRB,
    displacement3W: Tabledisplacement3W,
    SRRB3bit: TableSRRB3bit,
}
impl externalTargetVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.displacement3W.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB3bit.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let displacement3W = if let Some((len, table)) =
            Tabledisplacement3W::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB3bit = if let Some((len, table)) = TableSRRB3bit::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                displacement3W,
                SRRB3bit,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TableexternalTarget {
    Var0(externalTargetVar0),
}
impl TableexternalTarget {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = externalTargetVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1383:1"]
#[derive(Clone, Debug)]
struct shiftCVar0 {
    cp: TokenField_cp,
}
impl shiftCVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut shift: i64 = 0;
        shift = 31i64.wrapping_sub(self.cp.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, shift)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut shift: i64 = 0;
        shift = 31i64.wrapping_sub(token_parser.TokenFieldcp().disassembly());
        let cp = token_parser.TokenFieldcp();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cp }))
    }
}
#[derive(Clone, Debug)]
enum TableshiftC {
    Var0(shiftCVar0),
}
impl TableshiftC {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            shiftCVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1384:1"]
#[derive(Clone, Debug)]
struct shiftCLenVar0 {
    im5: TokenField_im5,
}
impl shiftCLenVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut shift: i64 = 0;
        shift = 32i64.wrapping_sub(self.im5.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, shift)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut shift: i64 = 0;
        shift = 32i64.wrapping_sub(token_parser.TokenFieldim5().disassembly());
        let im5 = token_parser.TokenFieldim5();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { im5 }))
    }
}
#[derive(Clone, Debug)]
enum TableshiftCLen {
    Var0(shiftCLenVar0),
}
impl TableshiftCLen {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            shiftCLenVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1388:1"]
#[derive(Clone, Debug)]
struct lse14Var0 {
    bit0: TokenField_bit0,
    im14less0: TokenField_im14less0,
}
impl lse14Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut off: i64 = 0;
        off = ((-1i64)
            .wrapping_mul(self.bit0.disassembly())
            .checked_shl(u32::try_from(13i64).unwrap())
            .unwrap_or(0)
            | self.im14less0.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, off)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut off: i64 = 0;
        off = ((-1i64)
            .wrapping_mul(token_parser.TokenFieldbit0().disassembly())
            .checked_shl(u32::try_from(13i64).unwrap())
            .unwrap_or(0)
            | token_parser.TokenFieldim14less0().disassembly());
        let im14less0 = token_parser.TokenFieldim14less0();
        let bit0 = token_parser.TokenFieldbit0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { im14less0, bit0 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelse14 {
    Var0(lse14Var0),
}
impl Tablelse14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            lse14Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1392:1"]
#[derive(Clone, Debug)]
struct lse5Var0 {
    bit0: TokenField_bit0,
    im5less0: TokenField_im5less0,
}
impl lse5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut off: i64 = 0;
        off = ((-1i64)
            .wrapping_mul(self.bit0.disassembly())
            .checked_shl(u32::try_from(4i64).unwrap())
            .unwrap_or(0)
            | self.im5less0.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, off)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut off: i64 = 0;
        off = ((-1i64)
            .wrapping_mul(token_parser.TokenFieldbit0().disassembly())
            .checked_shl(u32::try_from(4i64).unwrap())
            .unwrap_or(0)
            | token_parser.TokenFieldim5less0().disassembly());
        let im5less0 = token_parser.TokenFieldim5less0();
        let bit0 = token_parser.TokenFieldbit0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { im5less0, bit0 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelse5 {
    Var0(lse5Var0),
}
impl Tablelse5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            lse5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1395:1"]
#[derive(Clone, Debug)]
struct highlse5Var0 {
    bit16: TokenField_bit16,
    highIm5less16: TokenField_highIm5less16,
}
impl highlse5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut off: i64 = 0;
        off = ((-1i64)
            .wrapping_mul(self.bit16.disassembly())
            .checked_shl(u32::try_from(4i64).unwrap())
            .unwrap_or(0)
            | self.highIm5less16.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, off)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut off: i64 = 0;
        off = ((-1i64)
            .wrapping_mul(token_parser.TokenFieldbit16().disassembly())
            .checked_shl(u32::try_from(4i64).unwrap())
            .unwrap_or(0)
            | token_parser.TokenFieldhighIm5less16().disassembly());
        let highIm5less16 = token_parser.TokenFieldhighIm5less16();
        let bit16 = token_parser.TokenFieldbit16();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                highIm5less16,
                bit16,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum Tablehighlse5 {
    Var0(highlse5Var0),
}
impl Tablehighlse5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            highlse5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1398:1"]
#[derive(Clone, Debug)]
struct lse21Var0 {
    bit0: TokenField_bit0,
    im21_1_12: TokenField_im21_1_12,
    im21_14_16: TokenField_im21_14_16,
    im21_16_21: TokenField_im21_16_21,
    im21_12_14: TokenField_im21_12_14,
}
impl lse21Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut off: i64 = 0;
        off = (((((-1i64)
            .wrapping_mul(self.bit0.disassembly())
            .checked_shl(u32::try_from(20i64).unwrap())
            .unwrap_or(0)
            | self
                .im21_1_12
                .disassembly()
                .checked_shl(u32::try_from(9i64).unwrap())
                .unwrap_or(0))
            | self
                .im21_14_16
                .disassembly()
                .checked_shl(u32::try_from(7i64).unwrap())
                .unwrap_or(0))
            | self
                .im21_16_21
                .disassembly()
                .checked_shl(u32::try_from(2i64).unwrap())
                .unwrap_or(0))
            | self.im21_12_14.disassembly())
        .checked_shl(u32::try_from(11i64).unwrap())
        .unwrap_or(0);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, off)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut off: i64 = 0;
        off = (((((-1i64)
            .wrapping_mul(token_parser.TokenFieldbit0().disassembly())
            .checked_shl(u32::try_from(20i64).unwrap())
            .unwrap_or(0)
            | token_parser
                .TokenFieldim21_1_12()
                .disassembly()
                .checked_shl(u32::try_from(9i64).unwrap())
                .unwrap_or(0))
            | token_parser
                .TokenFieldim21_14_16()
                .disassembly()
                .checked_shl(u32::try_from(7i64).unwrap())
                .unwrap_or(0))
            | token_parser
                .TokenFieldim21_16_21()
                .disassembly()
                .checked_shl(u32::try_from(2i64).unwrap())
                .unwrap_or(0))
            | token_parser.TokenFieldim21_12_14().disassembly())
        .checked_shl(u32::try_from(11i64).unwrap())
        .unwrap_or(0);
        let im21less0 = token_parser.TokenFieldim21less0();
        let bit0 = token_parser.TokenFieldbit0();
        let im21_1_12 = token_parser.TokenFieldim21_1_12();
        let im21_12_14 = token_parser.TokenFieldim21_12_14();
        let im21_14_16 = token_parser.TokenFieldim21_14_16();
        let im21_16_21 = token_parser.TokenFieldim21_16_21();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bit0,
                im21_1_12,
                im21_12_14,
                im21_14_16,
                im21_16_21,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum Tablelse21 {
    Var0(lse21Var0),
}
impl Tablelse21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            lse21Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1414:1"]
#[derive(Clone, Debug)]
struct lse11Var0 {
    bit0: TokenField_bit0,
    im11less0: TokenField_im11less0,
}
impl lse11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut immed: i64 = 0;
        immed = ((-1i64)
            .wrapping_mul(self.bit0.disassembly())
            .checked_shl(u32::try_from(10i64).unwrap())
            .unwrap_or(0)
            | self.im11less0.disassembly());
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, immed)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut immed: i64 = 0;
        immed = ((-1i64)
            .wrapping_mul(token_parser.TokenFieldbit0().disassembly())
            .checked_shl(u32::try_from(10i64).unwrap())
            .unwrap_or(0)
            | token_parser.TokenFieldim11less0().disassembly());
        let tmp = immed;
        context_instance
            .register_mut()
            .write_temp32_disassembly(tmp);
        let im11less0 = token_parser.TokenFieldim11less0();
        let bit0 = token_parser.TokenFieldbit0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { im11less0, bit0 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelse11 {
    Var0(lse11Var0),
}
impl Tablelse11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            lse11Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1419:1"]
#[derive(Clone, Debug)]
struct OFF_BASE_14Var0 {
    lse14: Tablelse14,
    SRRB: TableSRRB,
    SPCBASE: TableSPCBASE,
}
impl OFF_BASE_14Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.lse14.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.SRRB.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let lse14 = if let Some((len, table)) =
            Tablelse14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SRRB = if let Some((len, table)) =
            TableSRRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                lse14,
                SRRB,
                SPCBASE,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TableOFF_BASE_14 {
    Var0(OFF_BASE_14Var0),
}
impl TableOFF_BASE_14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = OFF_BASE_14Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1426:1"]
#[derive(Clone, Debug)]
struct ShiftCondVar0 {}
impl ShiftCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1427:1"]
#[derive(Clone, Debug)]
struct ShiftCondVar1 {
    RT: TableRT,
}
impl ShiftCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 1i64 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1428:1"]
#[derive(Clone, Debug)]
struct ShiftCondVar2 {
    RT: TableRT,
}
impl ShiftCondVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i64 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1429:1"]
#[derive(Clone, Debug)]
struct ShiftCondVar3 {
    RT: TableRT,
}
impl ShiftCondVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 3i64 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1430:1"]
#[derive(Clone, Debug)]
struct ShiftCondVar4 {}
impl ShiftCondVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 4i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1431:1"]
#[derive(Clone, Debug)]
struct ShiftCondVar5 {
    RT: TableRT,
}
impl ShiftCondVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 5i64 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1432:1"]
#[derive(Clone, Debug)]
struct ShiftCondVar6 {
    RT: TableRT,
}
impl ShiftCondVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i64 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1433:1"]
#[derive(Clone, Debug)]
struct ShiftCondVar7 {
    RT: TableRT,
}
impl ShiftCondVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 7i64 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[derive(Clone, Debug)]
enum TableShiftCond {
    Var0(ShiftCondVar0),
    Var1(ShiftCondVar1),
    Var2(ShiftCondVar2),
    Var3(ShiftCondVar3),
    Var4(ShiftCondVar4),
    Var5(ShiftCondVar5),
    Var6(ShiftCondVar6),
    Var7(ShiftCondVar7),
}
impl TableShiftCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ShiftCondVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ShiftCondVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ShiftCondVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ShiftCondVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ShiftCondVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ShiftCondVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ShiftCondVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ShiftCondVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1435:1"]
#[derive(Clone, Debug)]
struct ShiftCondNullifyVar0 {}
impl ShiftCondNullifyVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1436:1"]
#[derive(Clone, Debug)]
struct ShiftCondNullifyVar1 {
    ShiftCond: TableShiftCond,
}
impl ShiftCondNullifyVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_nullifyEnable(
            Some(inst_next),
            context.register().read_nullifyEnable_disassembly(),
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_nullifyEnable_disassembly(tmp);
        let ShiftCond = if let Some((len, table)) = TableShiftCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ShiftCond }))
    }
}
#[derive(Clone, Debug)]
enum TableShiftCondNullify {
    Var0(ShiftCondNullifyVar0),
    Var1(ShiftCondNullifyVar1),
}
impl TableShiftCondNullify {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = ShiftCondNullifyVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = ShiftCondNullifyVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1442:1"]
#[derive(Clone, Debug)]
struct DepCondVar0 {}
impl DepCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1443:1"]
#[derive(Clone, Debug)]
struct DepCondVar1 {}
impl DepCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1444:1"]
#[derive(Clone, Debug)]
struct DepCondVar2 {}
impl DepCondVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1445:1"]
#[derive(Clone, Debug)]
struct DepCondVar3 {}
impl DepCondVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 3i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1446:1"]
#[derive(Clone, Debug)]
struct DepCondVar4 {}
impl DepCondVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 4i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1447:1"]
#[derive(Clone, Debug)]
struct DepCondVar5 {}
impl DepCondVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 5i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1448:1"]
#[derive(Clone, Debug)]
struct DepCondVar6 {}
impl DepCondVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1449:1"]
#[derive(Clone, Debug)]
struct DepCondVar7 {}
impl DepCondVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 7i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableDepCond {
    Var0(DepCondVar0),
    Var1(DepCondVar1),
    Var2(DepCondVar2),
    Var3(DepCondVar3),
    Var4(DepCondVar4),
    Var5(DepCondVar5),
    Var6(DepCondVar6),
    Var7(DepCondVar7),
}
impl TableDepCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            DepCondVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            DepCondVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            DepCondVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            DepCondVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            DepCondVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            DepCondVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            DepCondVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            DepCondVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1451:1"]
#[derive(Clone, Debug)]
struct DepCondNullifyVar0 {}
impl DepCondNullifyVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1452:1"]
#[derive(Clone, Debug)]
struct DepCondNullifyVar1 {
    DepCond: TableDepCond,
}
impl DepCondNullifyVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_nullifyEnable(
            Some(inst_next),
            context.register().read_nullifyEnable_disassembly(),
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_nullifyEnable_disassembly(tmp);
        let DepCond = if let Some((len, table)) = TableDepCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { DepCond }))
    }
}
#[derive(Clone, Debug)]
enum TableDepCondNullify {
    Var0(DepCondNullifyVar0),
    Var1(DepCondNullifyVar1),
}
impl TableDepCondNullify {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = DepCondNullifyVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = DepCondNullifyVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1458:1"]
#[derive(Clone, Debug)]
struct ExtrCondVar0 {}
impl ExtrCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1459:1"]
#[derive(Clone, Debug)]
struct ExtrCondVar1 {}
impl ExtrCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1460:1"]
#[derive(Clone, Debug)]
struct ExtrCondVar2 {}
impl ExtrCondVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1461:1"]
#[derive(Clone, Debug)]
struct ExtrCondVar3 {}
impl ExtrCondVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 3i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1462:1"]
#[derive(Clone, Debug)]
struct ExtrCondVar4 {}
impl ExtrCondVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 4i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1463:1"]
#[derive(Clone, Debug)]
struct ExtrCondVar5 {}
impl ExtrCondVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 5i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1464:1"]
#[derive(Clone, Debug)]
struct ExtrCondVar6 {}
impl ExtrCondVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1465:1"]
#[derive(Clone, Debug)]
struct ExtrCondVar7 {}
impl ExtrCondVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 7i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableExtrCond {
    Var0(ExtrCondVar0),
    Var1(ExtrCondVar1),
    Var2(ExtrCondVar2),
    Var3(ExtrCondVar3),
    Var4(ExtrCondVar4),
    Var5(ExtrCondVar5),
    Var6(ExtrCondVar6),
    Var7(ExtrCondVar7),
}
impl TableExtrCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            ExtrCondVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ExtrCondVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ExtrCondVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ExtrCondVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ExtrCondVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ExtrCondVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ExtrCondVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            ExtrCondVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1467:1"]
#[derive(Clone, Debug)]
struct ExtrCondNullifyVar0 {}
impl ExtrCondNullifyVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1468:1"]
#[derive(Clone, Debug)]
struct ExtrCondNullifyVar1 {
    ExtrCond: TableExtrCond,
}
impl ExtrCondNullifyVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_nullifyEnable(
            Some(inst_next),
            context.register().read_nullifyEnable_disassembly(),
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_nullifyEnable_disassembly(tmp);
        let ExtrCond = if let Some((len, table)) = TableExtrCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ExtrCond }))
    }
}
#[derive(Clone, Debug)]
enum TableExtrCondNullify {
    Var0(ExtrCondNullifyVar0),
    Var1(ExtrCondNullifyVar1),
}
impl TableExtrCondNullify {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = ExtrCondNullifyVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = ExtrCondNullifyVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1475:1"]
#[derive(Clone, Debug)]
struct BVBCondVar0 {
    R1: TableR1,
}
impl BVBCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1476:1"]
#[derive(Clone, Debug)]
struct BVBCondVar1 {
    R1: TableR1,
}
impl BVBCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1 }))
    }
}
#[derive(Clone, Debug)]
enum TableBVBCond {
    Var0(BVBCondVar0),
    Var1(BVBCondVar1),
}
impl TableBVBCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            BVBCondVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            BVBCondVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1478:1"]
#[derive(Clone, Debug)]
struct BBCondVar0 {
    R1: TableR1,
}
impl BBCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let bboffset = token_parser.TokenFieldbboffset();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1479:1"]
#[derive(Clone, Debug)]
struct BBCondVar1 {
    R1: TableR1,
}
impl BBCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let bboffset = token_parser.TokenFieldbboffset();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1 }))
    }
}
#[derive(Clone, Debug)]
enum TableBBCond {
    Var0(BBCondVar0),
    Var1(BBCondVar1),
}
impl TableBBCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            BBCondVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            BBCondVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1484:1"]
#[derive(Clone, Debug)]
struct RegUnitCondVar0 {}
impl RegUnitCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1485:1"]
#[derive(Clone, Debug)]
struct RegUnitCondVar1 {
    RT: TableRT,
}
impl RegUnitCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i64 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1486:1"]
#[derive(Clone, Debug)]
struct RegUnitCondVar2 {
    RT: TableRT,
}
impl RegUnitCondVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 3i64 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1487:1"]
#[derive(Clone, Debug)]
struct RegUnitCondVar3 {}
impl RegUnitCondVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 4i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1488:1"]
#[derive(Clone, Debug)]
struct RegUnitCondVar4 {}
impl RegUnitCondVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1489:1"]
#[derive(Clone, Debug)]
struct RegUnitCondVar5 {}
impl RegUnitCondVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 7i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableRegUnitCond {
    Var0(RegUnitCondVar0),
    Var1(RegUnitCondVar1),
    Var2(RegUnitCondVar2),
    Var3(RegUnitCondVar3),
    Var4(RegUnitCondVar4),
    Var5(RegUnitCondVar5),
}
impl TableRegUnitCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = RegUnitCondVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = RegUnitCondVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = RegUnitCondVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = RegUnitCondVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = RegUnitCondVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = RegUnitCondVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1491:1"]
#[derive(Clone, Debug)]
struct UnitCondVar0 {
    RegUnitCond: TableRegUnitCond,
}
impl UnitCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(""), DisplayElement::Literal("")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 0i64 {
            return None;
        }
        let RegUnitCond = if let Some((len, table)) = TableRegUnitCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegUnitCond }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1492:1"]
#[derive(Clone, Debug)]
struct UnitCondVar1 {
    RegUnitCond: TableRegUnitCond,
}
impl UnitCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(""), DisplayElement::Literal("")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 1i64 {
            return None;
        }
        let RegUnitCond = if let Some((len, table)) = TableRegUnitCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegUnitCond }))
    }
}
#[derive(Clone, Debug)]
enum TableUnitCond {
    Var0(UnitCondVar0),
    Var1(UnitCondVar1),
}
impl TableUnitCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            UnitCondVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            UnitCondVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1494:1"]
#[derive(Clone, Debug)]
struct UnitCondNullifyVar0 {}
impl UnitCondNullifyVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfv().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1495:1"]
#[derive(Clone, Debug)]
struct UnitCondNullifyVar1 {
    UnitCond: TableUnitCond,
}
impl UnitCondNullifyVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_nullifyEnable(
            Some(inst_next),
            context.register().read_nullifyEnable_disassembly(),
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_nullifyEnable_disassembly(tmp);
        let UnitCond = if let Some((len, table)) = TableUnitCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { UnitCond }))
    }
}
#[derive(Clone, Debug)]
enum TableUnitCondNullify {
    Var0(UnitCondNullifyVar0),
    Var1(UnitCondNullifyVar1),
}
impl TableUnitCondNullify {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = UnitCondNullifyVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = UnitCondNullifyVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1500:1"]
#[derive(Clone, Debug)]
struct UnitCondSymVar0 {
    RegUnitCondSym: TokenField_RegUnitCondSym,
}
impl UnitCondSymVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.RegUnitCondSym.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 0i64 {
            return None;
        }
        let RegUnitCondSym = token_parser.TokenFieldRegUnitCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegUnitCondSym }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1501:1"]
#[derive(Clone, Debug)]
struct UnitCondSymVar1 {
    InvUnitCondSym: TokenField_InvUnitCondSym,
}
impl UnitCondSymVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.InvUnitCondSym.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 1i64 {
            return None;
        }
        let InvUnitCondSym = token_parser.TokenFieldInvUnitCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { InvUnitCondSym }))
    }
}
#[derive(Clone, Debug)]
enum TableUnitCondSym {
    Var0(UnitCondSymVar0),
    Var1(UnitCondSymVar1),
}
impl TableUnitCondSym {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = UnitCondSymVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = UnitCondSymVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1506:1"]
#[derive(Clone, Debug)]
struct RegAddCondVar0 {}
impl RegAddCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1507:1"]
#[derive(Clone, Debug)]
struct RegAddCondVar1 {
    R1: TableR1,
    R2: TableR2,
}
impl RegAddCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 1i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1508:1"]
#[derive(Clone, Debug)]
struct RegAddCondVar2 {
    R1: TableR1,
    R2: TableR2,
}
impl RegAddCondVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1509:1"]
#[derive(Clone, Debug)]
struct RegAddCondVar3 {
    R1: TableR1,
    R2: TableR2,
}
impl RegAddCondVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 3i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1510:1"]
#[derive(Clone, Debug)]
struct RegAddCondVar4 {
    R1: TableR1,
    R2: TableR2,
}
impl RegAddCondVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 4i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1511:1"]
#[derive(Clone, Debug)]
struct RegAddCondVar5 {
    R1: TableR1,
    R2: TableR2,
}
impl RegAddCondVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 5i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1512:1"]
#[derive(Clone, Debug)]
struct RegAddCondVar6 {
    R1: TableR1,
    R2: TableR2,
}
impl RegAddCondVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1513:1"]
#[derive(Clone, Debug)]
struct RegAddCondVar7 {
    R1: TableR1,
    R2: TableR2,
}
impl RegAddCondVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 7i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[derive(Clone, Debug)]
enum TableRegAddCond {
    Var0(RegAddCondVar0),
    Var1(RegAddCondVar1),
    Var2(RegAddCondVar2),
    Var3(RegAddCondVar3),
    Var4(RegAddCondVar4),
    Var5(RegAddCondVar5),
    Var6(RegAddCondVar6),
    Var7(RegAddCondVar7),
}
impl TableRegAddCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = RegAddCondVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1515:1"]
#[derive(Clone, Debug)]
struct AddCondVar0 {
    RegAddCond: TableRegAddCond,
}
impl AddCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 0i64 {
            return None;
        }
        let RegAddCond = if let Some((len, table)) = TableRegAddCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegAddCond }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1516:1"]
#[derive(Clone, Debug)]
struct AddCondVar1 {
    RegAddCond: TableRegAddCond,
}
impl AddCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 1i64 {
            return None;
        }
        let RegAddCond = if let Some((len, table)) = TableRegAddCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegAddCond }))
    }
}
#[derive(Clone, Debug)]
enum TableAddCond {
    Var0(AddCondVar0),
    Var1(AddCondVar1),
}
impl TableAddCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            AddCondVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            AddCondVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1518:1"]
#[derive(Clone, Debug)]
struct AddCondNullifyVar0 {}
impl AddCondNullifyVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfv().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1519:1"]
#[derive(Clone, Debug)]
struct AddCondNullifyVar1 {
    AddCond: TableAddCond,
}
impl AddCondNullifyVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_nullifyEnable(
            Some(inst_next),
            context.register().read_nullifyEnable_disassembly(),
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_nullifyEnable_disassembly(tmp);
        let AddCond = if let Some((len, table)) = TableAddCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AddCond }))
    }
}
#[derive(Clone, Debug)]
enum TableAddCondNullify {
    Var0(AddCondNullifyVar0),
    Var1(AddCondNullifyVar1),
}
impl TableAddCondNullify {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = AddCondNullifyVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = AddCondNullifyVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1524:1"]
#[derive(Clone, Debug)]
struct AddCondSymVar0 {
    RegAddCondSym: TokenField_RegAddCondSym,
}
impl AddCondSymVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.RegAddCondSym.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 0i64 {
            return None;
        }
        let RegAddCondSym = token_parser.TokenFieldRegAddCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegAddCondSym }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1525:1"]
#[derive(Clone, Debug)]
struct AddCondSymVar1 {
    InvAddCondSym: TokenField_InvAddCondSym,
}
impl AddCondSymVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.InvAddCondSym.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 1i64 {
            return None;
        }
        let InvAddCondSym = token_parser.TokenFieldInvAddCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { InvAddCondSym }))
    }
}
#[derive(Clone, Debug)]
enum TableAddCondSym {
    Var0(AddCondSymVar0),
    Var1(AddCondSymVar1),
}
impl TableAddCondSym {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = AddCondSymVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = AddCondSymVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1527:1"]
#[derive(Clone, Debug)]
struct RegAddCondIVar0 {}
impl RegAddCondIVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1528:1"]
#[derive(Clone, Debug)]
struct RegAddCondIVar1 {
    highlse5: Tablehighlse5,
    R2: TableR2,
}
impl RegAddCondIVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 1i64 {
            return None;
        }
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { highlse5, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1529:1"]
#[derive(Clone, Debug)]
struct RegAddCondIVar2 {
    highlse5: Tablehighlse5,
    R2: TableR2,
}
impl RegAddCondIVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i64 {
            return None;
        }
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { highlse5, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1530:1"]
#[derive(Clone, Debug)]
struct RegAddCondIVar3 {
    highlse5: Tablehighlse5,
    R2: TableR2,
}
impl RegAddCondIVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 3i64 {
            return None;
        }
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { highlse5, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1531:1"]
#[derive(Clone, Debug)]
struct RegAddCondIVar4 {
    highlse5: Tablehighlse5,
    R2: TableR2,
}
impl RegAddCondIVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 4i64 {
            return None;
        }
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { highlse5, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1532:1"]
#[derive(Clone, Debug)]
struct RegAddCondIVar5 {
    highlse5: Tablehighlse5,
    R2: TableR2,
}
impl RegAddCondIVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 5i64 {
            return None;
        }
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { highlse5, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1533:1"]
#[derive(Clone, Debug)]
struct RegAddCondIVar6 {
    highlse5: Tablehighlse5,
    R2: TableR2,
}
impl RegAddCondIVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i64 {
            return None;
        }
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { highlse5, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1534:1"]
#[derive(Clone, Debug)]
struct RegAddCondIVar7 {
    highlse5: Tablehighlse5,
    R2: TableR2,
}
impl RegAddCondIVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 7i64 {
            return None;
        }
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { highlse5, R2 }))
    }
}
#[derive(Clone, Debug)]
enum TableRegAddCondI {
    Var0(RegAddCondIVar0),
    Var1(RegAddCondIVar1),
    Var2(RegAddCondIVar2),
    Var3(RegAddCondIVar3),
    Var4(RegAddCondIVar4),
    Var5(RegAddCondIVar5),
    Var6(RegAddCondIVar6),
    Var7(RegAddCondIVar7),
}
impl TableRegAddCondI {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = RegAddCondIVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondIVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondIVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondIVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondIVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondIVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondIVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondIVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1544:1"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var0 {}
impl RegAddCondI11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1546:1"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var1 {
    lse11: Tablelse11,
    R2: TableR2,
}
impl RegAddCondI11Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 1i64 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse11, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1550:1"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var2 {
    lse11: Tablelse11,
    R2: TableR2,
}
impl RegAddCondI11Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i64 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse11, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1554:1"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var3 {
    lse11: Tablelse11,
    R2: TableR2,
}
impl RegAddCondI11Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 3i64 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse11, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1558:1"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var4 {
    lse11: Tablelse11,
    R2: TableR2,
}
impl RegAddCondI11Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 4i64 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse11, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1562:1"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var5 {
    lse11: Tablelse11,
    R2: TableR2,
}
impl RegAddCondI11Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 5i64 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse11, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1567:1"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var6 {
    lse11: Tablelse11,
    R2: TableR2,
}
impl RegAddCondI11Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i64 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse11, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1571:1"]
#[derive(Clone, Debug)]
struct RegAddCondI11Var7 {
    lse11: Tablelse11,
    R2: TableR2,
}
impl RegAddCondI11Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 7i64 {
            return None;
        }
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse11, R2 }))
    }
}
#[derive(Clone, Debug)]
enum TableRegAddCondI11 {
    Var0(RegAddCondI11Var0),
    Var1(RegAddCondI11Var1),
    Var2(RegAddCondI11Var2),
    Var3(RegAddCondI11Var3),
    Var4(RegAddCondI11Var4),
    Var5(RegAddCondI11Var5),
    Var6(RegAddCondI11Var6),
    Var7(RegAddCondI11Var7),
}
impl TableRegAddCondI11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = RegAddCondI11Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondI11Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondI11Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondI11Var3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondI11Var4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondI11Var5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondI11Var6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = RegAddCondI11Var7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1575:1"]
#[derive(Clone, Debug)]
struct AddCondI11Var0 {
    RegAddCondI11: TableRegAddCondI11,
}
impl AddCondI11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 0i64 {
            return None;
        }
        let RegAddCondI11 = if let Some((len, table)) =
            TableRegAddCondI11::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegAddCondI11 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1576:1"]
#[derive(Clone, Debug)]
struct AddCondI11Var1 {
    RegAddCondI11: TableRegAddCondI11,
}
impl AddCondI11Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 1i64 {
            return None;
        }
        let RegAddCondI11 = if let Some((len, table)) =
            TableRegAddCondI11::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegAddCondI11 }))
    }
}
#[derive(Clone, Debug)]
enum TableAddCondI11 {
    Var0(AddCondI11Var0),
    Var1(AddCondI11Var1),
}
impl TableAddCondI11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = AddCondI11Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = AddCondI11Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1578:1"]
#[derive(Clone, Debug)]
struct AddCondI11NullifyVar0 {}
impl AddCondI11NullifyVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfv().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1579:1"]
#[derive(Clone, Debug)]
struct AddCondI11NullifyVar1 {
    AddCondI11: TableAddCondI11,
}
impl AddCondI11NullifyVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_nullifyEnable(
            Some(inst_next),
            context.register().read_nullifyEnable_disassembly(),
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_nullifyEnable_disassembly(tmp);
        let AddCondI11 = if let Some((len, table)) = TableAddCondI11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { AddCondI11 }))
    }
}
#[derive(Clone, Debug)]
enum TableAddCondI11Nullify {
    Var0(AddCondI11NullifyVar0),
    Var1(AddCondI11NullifyVar1),
}
impl TableAddCondI11Nullify {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = AddCondI11NullifyVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = AddCondI11NullifyVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1587:1"]
#[derive(Clone, Debug)]
struct RegCSCondVar0 {
    R1: TableR1,
    R2: TableR2,
}
impl RegCSCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1588:1"]
#[derive(Clone, Debug)]
struct RegCSCondVar1 {
    R1: TableR1,
    R2: TableR2,
}
impl RegCSCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 1i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1589:1"]
#[derive(Clone, Debug)]
struct RegCSCondVar2 {
    R1: TableR1,
    R2: TableR2,
}
impl RegCSCondVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1590:1"]
#[derive(Clone, Debug)]
struct RegCSCondVar3 {
    R1: TableR1,
    R2: TableR2,
}
impl RegCSCondVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 3i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1591:1"]
#[derive(Clone, Debug)]
struct RegCSCondVar4 {
    R1: TableR1,
    R2: TableR2,
}
impl RegCSCondVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 4i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1592:1"]
#[derive(Clone, Debug)]
struct RegCSCondVar5 {
    R1: TableR1,
    R2: TableR2,
}
impl RegCSCondVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 5i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1593:1"]
#[derive(Clone, Debug)]
struct RegCSCondVar6 {
    R1: TableR1,
    R2: TableR2,
}
impl RegCSCondVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1594:1"]
#[derive(Clone, Debug)]
struct RegCSCondVar7 {
    R1: TableR1,
    R2: TableR2,
}
impl RegCSCondVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 7i64 {
            return None;
        }
        let R1 = if let Some((len, table)) =
            TableR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R1, R2 }))
    }
}
#[derive(Clone, Debug)]
enum TableRegCSCond {
    Var0(RegCSCondVar0),
    Var1(RegCSCondVar1),
    Var2(RegCSCondVar2),
    Var3(RegCSCondVar3),
    Var4(RegCSCondVar4),
    Var5(RegCSCondVar5),
    Var6(RegCSCondVar6),
    Var7(RegCSCondVar7),
}
impl TableRegCSCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            RegCSCondVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            RegCSCondVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            RegCSCondVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            RegCSCondVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            RegCSCondVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            RegCSCondVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            RegCSCondVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            RegCSCondVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1596:1"]
#[derive(Clone, Debug)]
struct CSCondVar0 {
    RegCSCond: TableRegCSCond,
}
impl CSCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 0i64 {
            return None;
        }
        let RegCSCond = if let Some((len, table)) = TableRegCSCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegCSCond }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1597:1"]
#[derive(Clone, Debug)]
struct CSCondVar1 {
    RegCSCond: TableRegCSCond,
}
impl CSCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 1i64 {
            return None;
        }
        let RegCSCond = if let Some((len, table)) = TableRegCSCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegCSCond }))
    }
}
#[derive(Clone, Debug)]
enum TableCSCond {
    Var0(CSCondVar0),
    Var1(CSCondVar1),
}
impl TableCSCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            CSCondVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CSCondVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1599:1"]
#[derive(Clone, Debug)]
struct CSCondNullifyVar0 {}
impl CSCondNullifyVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfv().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1600:1"]
#[derive(Clone, Debug)]
struct CSCondNullifyVar1 {
    CSCond: TableCSCond,
}
impl CSCondNullifyVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_nullifyEnable(
            Some(inst_next),
            context.register().read_nullifyEnable_disassembly(),
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_nullifyEnable_disassembly(tmp);
        let CSCond = if let Some((len, table)) = TableCSCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CSCond }))
    }
}
#[derive(Clone, Debug)]
enum TableCSCondNullify {
    Var0(CSCondNullifyVar0),
    Var1(CSCondNullifyVar1),
}
impl TableCSCondNullify {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = CSCondNullifyVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = CSCondNullifyVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1605:1"]
#[derive(Clone, Debug)]
struct CSCondSymVar0 {
    RegCSCondSym: TokenField_RegCSCondSym,
}
impl CSCondSymVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.RegCSCondSym.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 0i64 {
            return None;
        }
        let RegCSCondSym = token_parser.TokenFieldRegCSCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegCSCondSym }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1606:1"]
#[derive(Clone, Debug)]
struct CSCondSymVar1 {
    InvCSCondSym: TokenField_InvCSCondSym,
}
impl CSCondSymVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.InvCSCondSym.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 1i64 {
            return None;
        }
        let InvCSCondSym = token_parser.TokenFieldInvCSCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { InvCSCondSym }))
    }
}
#[derive(Clone, Debug)]
enum TableCSCondSym {
    Var0(CSCondSymVar0),
    Var1(CSCondSymVar1),
}
impl TableCSCondSym {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            CSCondSymVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CSCondSymVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1610:1"]
#[derive(Clone, Debug)]
struct RegCSCondIVar0 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegCSCondIVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1611:1"]
#[derive(Clone, Debug)]
struct RegCSCondIVar1 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegCSCondIVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 1i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1612:1"]
#[derive(Clone, Debug)]
struct RegCSCondIVar2 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegCSCondIVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1613:1"]
#[derive(Clone, Debug)]
struct RegCSCondIVar3 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegCSCondIVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 3i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1614:1"]
#[derive(Clone, Debug)]
struct RegCSCondIVar4 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegCSCondIVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 4i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1615:1"]
#[derive(Clone, Debug)]
struct RegCSCondIVar5 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegCSCondIVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 5i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1616:1"]
#[derive(Clone, Debug)]
struct RegCSCondIVar6 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegCSCondIVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1617:1"]
#[derive(Clone, Debug)]
struct RegCSCondIVar7 {
    R2: TableR2,
    highlse5: Tablehighlse5,
}
impl RegCSCondIVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 7i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, highlse5 }))
    }
}
#[derive(Clone, Debug)]
enum TableRegCSCondI {
    Var0(RegCSCondIVar0),
    Var1(RegCSCondIVar1),
    Var2(RegCSCondIVar2),
    Var3(RegCSCondIVar3),
    Var4(RegCSCondIVar4),
    Var5(RegCSCondIVar5),
    Var6(RegCSCondIVar6),
    Var7(RegCSCondIVar7),
}
impl TableRegCSCondI {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = RegCSCondIVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondIVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondIVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondIVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondIVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondIVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondIVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondIVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1620:1"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var0 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegCSCondI11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1621:1"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var1 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegCSCondI11Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 1i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1622:1"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var2 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegCSCondI11Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1623:1"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var3 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegCSCondI11Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 3i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1624:1"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var4 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegCSCondI11Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 4i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1625:1"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var5 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegCSCondI11Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 5i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1626:1"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var6 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegCSCondI11Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 6i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1627:1"]
#[derive(Clone, Debug)]
struct RegCSCondI11Var7 {
    R2: TableR2,
    lse11: Tablelse11,
}
impl RegCSCondI11Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 7i64 {
            return None;
        }
        let R2 = if let Some((len, table)) =
            TableR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse11 = if let Some((len, table)) =
            Tablelse11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { R2, lse11 }))
    }
}
#[derive(Clone, Debug)]
enum TableRegCSCondI11 {
    Var0(RegCSCondI11Var0),
    Var1(RegCSCondI11Var1),
    Var2(RegCSCondI11Var2),
    Var3(RegCSCondI11Var3),
    Var4(RegCSCondI11Var4),
    Var5(RegCSCondI11Var5),
    Var6(RegCSCondI11Var6),
    Var7(RegCSCondI11Var7),
}
impl TableRegCSCondI11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = RegCSCondI11Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondI11Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondI11Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondI11Var3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondI11Var4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondI11Var5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondI11Var6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = RegCSCondI11Var7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1629:1"]
#[derive(Clone, Debug)]
struct CSCondI11Var0 {
    RegCSCondI11: TableRegCSCondI11,
}
impl CSCondI11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 0i64 {
            return None;
        }
        let RegCSCondI11 = if let Some((len, table)) = TableRegCSCondI11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegCSCondI11 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1630:1"]
#[derive(Clone, Debug)]
struct CSCondI11Var1 {
    RegCSCondI11: TableRegCSCondI11,
}
impl CSCondI11Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 1i64 {
            return None;
        }
        let RegCSCondI11 = if let Some((len, table)) = TableRegCSCondI11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegCSCondI11 }))
    }
}
#[derive(Clone, Debug)]
enum TableCSCondI11 {
    Var0(CSCondI11Var0),
    Var1(CSCondI11Var1),
}
impl TableCSCondI11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            CSCondI11Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CSCondI11Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1632:1"]
#[derive(Clone, Debug)]
struct CSCondI11NullifyVar0 {}
impl CSCondI11NullifyVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfv().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1633:1"]
#[derive(Clone, Debug)]
struct CSCondI11NullifyVar1 {
    CSCondI11: TableCSCondI11,
}
impl CSCondI11NullifyVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_nullifyEnable(
            Some(inst_next),
            context.register().read_nullifyEnable_disassembly(),
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_nullifyEnable_disassembly(tmp);
        let CSCondI11 = if let Some((len, table)) = TableCSCondI11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CSCondI11 }))
    }
}
#[derive(Clone, Debug)]
enum TableCSCondI11Nullify {
    Var0(CSCondI11NullifyVar0),
    Var1(CSCondI11NullifyVar1),
}
impl TableCSCondI11Nullify {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = CSCondI11NullifyVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = CSCondI11NullifyVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1641:1"]
#[derive(Clone, Debug)]
struct RegLogicCondVar0 {}
impl RegLogicCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1642:1"]
#[derive(Clone, Debug)]
struct RegLogicCondVar1 {
    RT: TableRT,
}
impl RegLogicCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 1i64 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1643:1"]
#[derive(Clone, Debug)]
struct RegLogicCondVar2 {
    RT: TableRT,
}
impl RegLogicCondVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 2i64 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1644:1"]
#[derive(Clone, Debug)]
struct RegLogicCondVar3 {
    RT: TableRT,
}
impl RegLogicCondVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 3i64 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1645:1"]
#[derive(Clone, Debug)]
struct RegLogicCondVar4 {
    RT: TableRT,
}
impl RegLogicCondVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 7i64 {
            return None;
        }
        let RT = if let Some((len, table)) =
            TableRT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RT }))
    }
}
#[derive(Clone, Debug)]
enum TableRegLogicCond {
    Var0(RegLogicCondVar0),
    Var1(RegLogicCondVar1),
    Var2(RegLogicCondVar2),
    Var3(RegLogicCondVar3),
    Var4(RegLogicCondVar4),
}
impl TableRegLogicCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = RegLogicCondVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = RegLogicCondVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = RegLogicCondVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = RegLogicCondVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = RegLogicCondVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1647:1"]
#[derive(Clone, Debug)]
struct LogicCondVar0 {
    RegLogicCond: TableRegLogicCond,
}
impl LogicCondVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 0i64 {
            return None;
        }
        let RegLogicCond = if let Some((len, table)) = TableRegLogicCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegLogicCond }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1648:1"]
#[derive(Clone, Debug)]
struct LogicCondVar1 {
    RegLogicCond: TableRegLogicCond,
}
impl LogicCondVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 1i64 {
            return None;
        }
        let RegLogicCond = if let Some((len, table)) = TableRegLogicCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegLogicCond }))
    }
}
#[derive(Clone, Debug)]
enum TableLogicCond {
    Var0(LogicCondVar0),
    Var1(LogicCondVar1),
}
impl TableLogicCond {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LogicCondVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LogicCondVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1650:1"]
#[derive(Clone, Debug)]
struct LogicCondSymVar0 {
    RegLogicCondSym: TokenField_RegLogicCondSym,
}
impl LogicCondSymVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.RegLogicCondSym.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 0i64 {
            return None;
        }
        let RegLogicCondSym = token_parser.TokenFieldRegLogicCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RegLogicCondSym }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1651:1"]
#[derive(Clone, Debug)]
struct LogicCondSymVar1 {
    InvLogicCondSym: TokenField_InvLogicCondSym,
}
impl LogicCondSymVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.InvLogicCondSym.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldfv().disassembly() != 1i64 {
            return None;
        }
        let InvLogicCondSym = token_parser.TokenFieldInvLogicCondSym();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { InvLogicCondSym }))
    }
}
#[derive(Clone, Debug)]
enum TableLogicCondSym {
    Var0(LogicCondSymVar0),
    Var1(LogicCondSymVar1),
}
impl TableLogicCondSym {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = LogicCondSymVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = LogicCondSymVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1653:1"]
#[derive(Clone, Debug)]
struct LogicCondNullifyVar0 {}
impl LogicCondNullifyVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldc().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldfv().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1654:1"]
#[derive(Clone, Debug)]
struct LogicCondNullifyVar1 {
    LogicCond: TableLogicCond,
}
impl LogicCondNullifyVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_nullifyEnable(
            Some(inst_next),
            context.register().read_nullifyEnable_disassembly(),
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_nullifyEnable_disassembly(tmp);
        let LogicCond = if let Some((len, table)) = TableLogicCond::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LogicCond }))
    }
}
#[derive(Clone, Debug)]
enum TableLogicCondNullify {
    Var0(LogicCondNullifyVar0),
    Var1(LogicCondNullifyVar1),
}
impl TableLogicCondNullify {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = LogicCondNullifyVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = LogicCondNullifyVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1665:1"]
#[derive(Clone, Debug)]
struct indexedByteAccessCmpltVar0 {
    RX: TableRX,
    SPCBASE: TableSPCBASE,
}
impl indexedByteAccessCmpltVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, SPCBASE }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1666:1"]
#[derive(Clone, Debug)]
struct indexedByteAccessCmpltVar1 {
    RX: TableRX,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
}
impl indexedByteAccessCmpltVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",M")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, RB, SPCBASE }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1667:1"]
#[derive(Clone, Debug)]
struct indexedByteAccessCmpltVar2 {
    RX: TableRX,
    SPCBASE: TableSPCBASE,
}
impl indexedByteAccessCmpltVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",S")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, SPCBASE }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1668:1"]
#[derive(Clone, Debug)]
struct indexedByteAccessCmpltVar3 {
    RX: TableRX,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
}
impl indexedByteAccessCmpltVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",SM")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, RB, SPCBASE }))
    }
}
#[derive(Clone, Debug)]
enum TableindexedByteAccessCmplt {
    Var0(indexedByteAccessCmpltVar0),
    Var1(indexedByteAccessCmpltVar1),
    Var2(indexedByteAccessCmpltVar2),
    Var3(indexedByteAccessCmpltVar3),
}
impl TableindexedByteAccessCmplt {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexedByteAccessCmpltVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = indexedByteAccessCmpltVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = indexedByteAccessCmpltVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = indexedByteAccessCmpltVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1671:1"]
#[derive(Clone, Debug)]
struct indexedHalfwordAccessCmpltVar0 {
    RX: TableRX,
    SPCBASE: TableSPCBASE,
}
impl indexedHalfwordAccessCmpltVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, SPCBASE }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1672:1"]
#[derive(Clone, Debug)]
struct indexedHalfwordAccessCmpltVar1 {
    RX: TableRX,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
}
impl indexedHalfwordAccessCmpltVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",M")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, RB, SPCBASE }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1673:1"]
#[derive(Clone, Debug)]
struct indexedHalfwordAccessCmpltVar2 {
    RX: TableRX,
    SPCBASE: TableSPCBASE,
}
impl indexedHalfwordAccessCmpltVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",S")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, SPCBASE }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1674:1"]
#[derive(Clone, Debug)]
struct indexedHalfwordAccessCmpltVar3 {
    RX: TableRX,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
}
impl indexedHalfwordAccessCmpltVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",SM")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, RB, SPCBASE }))
    }
}
#[derive(Clone, Debug)]
enum TableindexedHalfwordAccessCmplt {
    Var0(indexedHalfwordAccessCmpltVar0),
    Var1(indexedHalfwordAccessCmpltVar1),
    Var2(indexedHalfwordAccessCmpltVar2),
    Var3(indexedHalfwordAccessCmpltVar3),
}
impl TableindexedHalfwordAccessCmplt {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexedHalfwordAccessCmpltVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = indexedHalfwordAccessCmpltVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = indexedHalfwordAccessCmpltVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = indexedHalfwordAccessCmpltVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1677:1"]
#[derive(Clone, Debug)]
struct indexedWordAccessCmpltVar0 {
    RX: TableRX,
    SPCBASE: TableSPCBASE,
}
impl indexedWordAccessCmpltVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, SPCBASE }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1678:1"]
#[derive(Clone, Debug)]
struct indexedWordAccessCmpltVar1 {
    RX: TableRX,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
}
impl indexedWordAccessCmpltVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",M")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, RB, SPCBASE }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1679:1"]
#[derive(Clone, Debug)]
struct indexedWordAccessCmpltVar2 {
    RX: TableRX,
    SPCBASE: TableSPCBASE,
}
impl indexedWordAccessCmpltVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",S")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, SPCBASE }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1680:1"]
#[derive(Clone, Debug)]
struct indexedWordAccessCmpltVar3 {
    RX: TableRX,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
}
impl indexedWordAccessCmpltVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",SM")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, RB, SPCBASE }))
    }
}
#[derive(Clone, Debug)]
enum TableindexedWordAccessCmplt {
    Var0(indexedWordAccessCmpltVar0),
    Var1(indexedWordAccessCmpltVar1),
    Var2(indexedWordAccessCmpltVar2),
    Var3(indexedWordAccessCmpltVar3),
}
impl TableindexedWordAccessCmplt {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = indexedWordAccessCmpltVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = indexedWordAccessCmpltVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = indexedWordAccessCmpltVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = indexedWordAccessCmpltVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1683:1"]
#[derive(Clone, Debug)]
struct indexedDoublewordAccessCmpltVar0 {
    RX: TableRX,
    SPCBASE: TableSPCBASE,
}
impl indexedDoublewordAccessCmpltVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, SPCBASE }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1684:1"]
#[derive(Clone, Debug)]
struct indexedDoublewordAccessCmpltVar1 {
    RX: TableRX,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
}
impl indexedDoublewordAccessCmpltVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",M")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, RB, SPCBASE }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1685:1"]
#[derive(Clone, Debug)]
struct indexedDoublewordAccessCmpltVar2 {
    RX: TableRX,
    SPCBASE: TableSPCBASE,
}
impl indexedDoublewordAccessCmpltVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",S")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, SPCBASE }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1686:1"]
#[derive(Clone, Debug)]
struct indexedDoublewordAccessCmpltVar3 {
    RX: TableRX,
    RB: TableRB,
    SPCBASE: TableSPCBASE,
}
impl indexedDoublewordAccessCmpltVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",SM")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RX, RB, SPCBASE }))
    }
}
#[derive(Clone, Debug)]
enum TableindexedDoublewordAccessCmplt {
    Var0(indexedDoublewordAccessCmpltVar0),
    Var1(indexedDoublewordAccessCmpltVar1),
    Var2(indexedDoublewordAccessCmpltVar2),
    Var3(indexedDoublewordAccessCmpltVar3),
}
impl TableindexedDoublewordAccessCmplt {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            indexedDoublewordAccessCmpltVar0::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            )
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexedDoublewordAccessCmpltVar1::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            )
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexedDoublewordAccessCmpltVar2::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            )
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            indexedDoublewordAccessCmpltVar3::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            )
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1691:1"]
#[derive(Clone, Debug)]
struct shortDispCmpltVar0 {
    RB: TableRB,
    RX: TableRX,
    SPCBASE: TableSPCBASE,
    highlse5: Tablehighlse5,
}
impl shortDispCmpltVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",MA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                RX,
                SPCBASE,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1692:1"]
#[derive(Clone, Debug)]
struct shortDispCmpltVar1 {
    RB: TableRB,
    RX: TableRX,
    SPCBASE: TableSPCBASE,
    highlse5: Tablehighlse5,
}
impl shortDispCmpltVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",MB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                RX,
                SPCBASE,
                highlse5,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1690:1"]
#[derive(Clone, Debug)]
struct shortDispCmpltVar2 {
    highlse5: Tablehighlse5,
    SPCBASE: TableSPCBASE,
}
impl shortDispCmpltVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let highlse5 = if let Some((len, table)) = Tablehighlse5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { highlse5, SPCBASE }))
    }
}
#[derive(Clone, Debug)]
enum TableshortDispCmplt {
    Var0(shortDispCmpltVar0),
    Var1(shortDispCmpltVar1),
    Var2(shortDispCmpltVar2),
}
impl TableshortDispCmplt {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = shortDispCmpltVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = shortDispCmpltVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = shortDispCmpltVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1696:1"]
#[derive(Clone, Debug)]
struct storeShortDispCmpltVar0 {
    RB: TableRB,
    RX: TableRX,
    SPCBASE: TableSPCBASE,
    lse5: Tablelse5,
}
impl storeShortDispCmpltVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",MA")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                RX,
                SPCBASE,
                lse5,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1697:1"]
#[derive(Clone, Debug)]
struct storeShortDispCmpltVar1 {
    RB: TableRB,
    RX: TableRX,
    SPCBASE: TableSPCBASE,
    lse5: Tablelse5,
}
impl storeShortDispCmpltVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",MB")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let RB = if let Some((len, table)) =
            TableRB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RX = if let Some((len, table)) =
            TableRX::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RB,
                RX,
                SPCBASE,
                lse5,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1695:1"]
#[derive(Clone, Debug)]
struct storeShortDispCmpltVar2 {
    lse5: Tablelse5,
    SPCBASE: TableSPCBASE,
}
impl storeShortDispCmpltVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { lse5, SPCBASE }))
    }
}
#[derive(Clone, Debug)]
enum TablestoreShortDispCmplt {
    Var0(storeShortDispCmpltVar0),
    Var1(storeShortDispCmpltVar1),
    Var2(storeShortDispCmpltVar2),
}
impl TablestoreShortDispCmplt {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = storeShortDispCmpltVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = storeShortDispCmpltVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = storeShortDispCmpltVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1700:1"]
#[derive(Clone, Debug)]
struct storeBytesShortCmpltVar0 {
    SPCBASE: TableSPCBASE,
    lse5: Tablelse5,
}
impl storeBytesShortCmpltVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPCBASE, lse5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1701:1"]
#[derive(Clone, Debug)]
struct storeBytesShortCmpltVar1 {
    SPCBASE: TableSPCBASE,
    RR: TableRR,
    lse5: Tablelse5,
}
impl storeBytesShortCmpltVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",BM")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPCBASE, RR, lse5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1702:1"]
#[derive(Clone, Debug)]
struct storeBytesShortCmpltVar2 {
    SPCBASE: TableSPCBASE,
    lse5: Tablelse5,
}
impl storeBytesShortCmpltVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",E")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPCBASE, lse5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1703:1"]
#[derive(Clone, Debug)]
struct storeBytesShortCmpltVar3 {
    SPCBASE: TableSPCBASE,
    RR: TableRR,
    lse5: Tablelse5,
}
impl storeBytesShortCmpltVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",EM")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldu().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        let SPCBASE = if let Some((len, table)) = TableSPCBASE::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RR = if let Some((len, table)) =
            TableRR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let lse5 = if let Some((len, table)) =
            Tablelse5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPCBASE, RR, lse5 }))
    }
}
#[derive(Clone, Debug)]
enum TablestoreBytesShortCmplt {
    Var0(storeBytesShortCmpltVar0),
    Var1(storeBytesShortCmpltVar1),
    Var2(storeBytesShortCmpltVar2),
    Var3(storeBytesShortCmpltVar3),
}
impl TablestoreBytesShortCmplt {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = storeBytesShortCmpltVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = storeBytesShortCmpltVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = storeBytesShortCmpltVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = storeBytesShortCmpltVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1706:1"]
#[derive(Clone, Debug)]
struct sysCmpltVar0 {}
impl sysCmpltVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldm().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1707:1"]
#[derive(Clone, Debug)]
struct sysCmpltVar1 {}
impl sysCmpltVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",M")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldm().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablesysCmplt {
    Var0(sysCmpltVar0),
    Var1(sysCmpltVar1),
}
impl TablesysCmplt {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            sysCmpltVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            sysCmpltVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1710:1"]
#[derive(Clone, Debug)]
struct loadCCVar0 {}
impl loadCCVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcc().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1711:1"]
#[derive(Clone, Debug)]
struct loadCCVar1 {}
impl loadCCVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",SL")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcc().disassembly() != 2i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableloadCC {
    Var0(loadCCVar0),
    Var1(loadCCVar1),
}
impl TableloadCC {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            loadCCVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            loadCCVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1714:1"]
#[derive(Clone, Debug)]
struct storeCCVar0 {}
impl storeCCVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcc().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1715:1"]
#[derive(Clone, Debug)]
struct storeCCVar1 {}
impl storeCCVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",BC")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcc().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1716:1"]
#[derive(Clone, Debug)]
struct storeCCVar2 {}
impl storeCCVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",SL")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcc().disassembly() != 2i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablestoreCC {
    Var0(storeCCVar0),
    Var1(storeCCVar1),
    Var2(storeCCVar2),
}
impl TablestoreCC {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            storeCCVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            storeCCVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            storeCCVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1719:1"]
#[derive(Clone, Debug)]
struct loadClearCCVar0 {}
impl loadClearCCVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcc().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1720:1"]
#[derive(Clone, Debug)]
struct loadClearCCVar1 {}
impl loadClearCCVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",CO")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldcc().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableloadClearCC {
    Var0(loadClearCCVar0),
    Var1(loadClearCCVar1),
}
impl TableloadClearCC {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = loadClearCCVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = loadClearCCVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1726:1"]
#[derive(Clone, Debug)]
struct nullifyForBranchVar0 {}
impl nullifyForBranchVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldn().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1727:1"]
#[derive(Clone, Debug)]
struct nullifyForBranchVar1 {}
impl nullifyForBranchVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_nullifyEnable(
            Some(inst_next),
            context.register().read_nullifyEnable_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",N")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldn().disassembly() != 1i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_nullifyEnable_disassembly(tmp);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablenullifyForBranch {
    Var0(nullifyForBranchVar0),
    Var1(nullifyForBranchVar1),
}
impl TablenullifyForBranch {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = nullifyForBranchVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = nullifyForBranchVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1729:1"]
#[derive(Clone, Debug)]
struct nullifySymForBranchVar0 {}
impl nullifySymForBranchVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldn().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1730:1"]
#[derive(Clone, Debug)]
struct nullifySymForBranchVar1 {}
impl nullifySymForBranchVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",N")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldn().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablenullifySymForBranch {
    Var0(nullifySymForBranchVar0),
    Var1(nullifySymForBranchVar1),
}
impl TablenullifySymForBranch {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = nullifySymForBranchVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = nullifySymForBranchVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1733:1"]
#[derive(Clone, Debug)]
struct nullifyForSpecialVar0 {}
impl nullifyForSpecialVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldspn().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1734:1"]
#[derive(Clone, Debug)]
struct nullifyForSpecialVar1 {}
impl nullifyForSpecialVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",N")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldspn().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablenullifyForSpecial {
    Var0(nullifyForSpecialVar0),
    Var1(nullifyForSpecialVar1),
}
impl TablenullifyForSpecial {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = nullifyForSpecialVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = nullifyForSpecialVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PA-RISC/data/languages/pa-risc.sinc:1744:1"]
#[derive(Clone, Debug)]
struct SFUVar0 {
    sfu: TokenField_sfu,
}
impl SFUVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.sfu.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let sfu = token_parser.TokenFieldsfu();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sfu }))
    }
}
#[derive(Clone, Debug)]
enum TableSFU {
    Var0(SFUVar0),
}
impl TableSFU {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            SFUVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
pub fn parse_instruction<T>(
    tokens: &[u8],
    context: &mut T,
    inst_start: u32,
    global_set: &mut impl GlobalSetTrait,
) -> Option<(u32, Vec<DisplayElement>)>
where
    T: ContextTrait + Clone,
{
    let (inst_len, instruction) =
        Tableinstruction::parse(tokens, context, inst_start)?;
    let inst_next = inst_start + inst_len;
    let mut display = vec![];
    instruction.display_extend(
        &mut display,
        context,
        inst_start,
        inst_next,
        global_set,
    );
    Some((inst_next, display))
}
